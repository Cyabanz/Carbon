<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Your Profile - CARBON</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
  <script src="carbon-theme.js"></script>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  
  <!-- DOMPurify for XSS protection -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script>
    // Tailwind config will be dynamically updated by the enhanced theme system
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'rp-base': '#191724',
            'rp-surface': '#1f1d2e',
            'rp-overlay': '#26233a',
            'rp-muted': '#6e6a86',
            'rp-subtle': '#908caa',
            'rp-text': '#e0def4',
            'rp-love': '#eb6f92',
            'rp-gold': '#f6c177',
            'rp-rose': '#ebbcba',
            'rp-pine': '#31748f',
            'rp-foam': '#9ccfd8',
            'rp-iris': '#c4a7e7',
            'rp-highlight-low': '#21202e',
            'rp-highlight-med': '#403d52',
            'rp-highlight-high': '#524f67'
          }
        }
      }
    }
  </script>
  <style>
    :root {
      --text-color: #e0def4;
      --surface-color: #1f1d2e;
      --overlay-color: #26233a;
      --highlight-med: #403d52;
      --highlight-high: #524f67;
      --foam: #9ccfd8;
      --love: #eb6f92;
      --gold: #f6c177;
      --pine: #31748f;
      --iris: #c4a7e7;
      --muted: #6e6a86;
      --subtle: #908caa;

      /* Theme variables - Rose Pine (default) */
      --theme-base: #191724;
      --theme-surface: #1f1d2e;
      --theme-overlay: #26233a;
      --theme-muted: #6e6a86;
      --theme-subtle: #908caa;
      --theme-text: #e0def4;
      --theme-love: #eb6f92;
      --theme-gold: #f6c177;
      --theme-rose: #ebbcba;
      --theme-pine: #31748f;
      --theme-foam: #9ccfd8;
      --theme-iris: #c4a7e7;
      --theme-highlight-low: #21202e;
      --theme-highlight-med: #403d52;
      --theme-highlight-high: #524f67;
      --theme-gradient: linear-gradient(135deg, #191724 0%, #1f1d2e 50%, #26233a 100%);
    }
    
    body {
      background: var(--theme-gradient);
      background-attachment: fixed;
    }
    
    /* Add all theme variations */
    [data-theme="dark"] {
      --theme-base: #0f172a;
      --theme-surface: #1e293b;
      --theme-overlay: #334155;
      --theme-muted: #64748b;
      --theme-subtle: #94a3b8;
      --theme-text: #f1f5f9;
      --theme-love: #ef4444;
      --theme-gold: #f59e0b;
      --theme-rose: #f97316;
      --theme-pine: #059669;
      --theme-foam: #06b6d4;
      --theme-iris: #8b5cf6;
      --theme-highlight-low: #1e293b;
      --theme-highlight-med: #475569;
      --theme-highlight-high: #64748b;
      --theme-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
    }
    
    [data-theme="light"] {
      --theme-base: #f8fafc;
      --theme-surface: #e2e8f0;
      --theme-overlay: #cbd5e1;
      --theme-muted: #64748b;
      --theme-subtle: #475569;
      --theme-text: #0f172a;
      --theme-love: #dc2626;
      --theme-gold: #d97706;
      --theme-rose: #ea580c;
      --theme-pine: #047857;
      --theme-foam: #0891b2;
      --theme-iris: #7c3aed;
      --theme-highlight-low: #f1f5f9;
      --theme-highlight-med: #e2e8f0;
      --theme-highlight-high: #cbd5e1;
      --theme-gradient: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #cbd5e1 100%);
    }
    
    [data-theme="catppuccin"] {
      --theme-base: #1e1e2e;
      --theme-surface: #313244;
      --theme-overlay: #45475a;
      --theme-muted: #6c7086;
      --theme-subtle: #9399b2;
      --theme-text: #cdd6f4;
      --theme-love: #f38ba8;
      --theme-gold: #f9e2af;
      --theme-rose: #fab387;
      --theme-pine: #a6e3a1;
      --theme-foam: #89dceb;
      --theme-iris: #cba6f7;
      --theme-highlight-low: #181825;
      --theme-highlight-med: #313244;
      --theme-highlight-high: #45475a;
      --theme-gradient: linear-gradient(135deg, #1e1e2e 0%, #313244 50%, #45475a 100%);
    }
    
    [data-theme="nord"] {
      --theme-base: #2e3440;
      --theme-surface: #3b4252;
      --theme-overlay: #434c5e;
      --theme-muted: #4c566a;
      --theme-subtle: #d8dee9;
      --theme-text: #eceff4;
      --theme-love: #bf616a;
      --theme-gold: #ebcb8b;
      --theme-rose: #d08770;
      --theme-pine: #a3be8c;
      --theme-foam: #88c0d0;
      --theme-iris: #b48ead;
      --theme-highlight-low: #2e3440;
      --theme-highlight-med: #434c5e;
      --theme-highlight-high: #4c566a;
      --theme-gradient: linear-gradient(135deg, #2e3440 0%, #3b4252 50%, #434c5e 100%);
    }
    
    [data-theme="gruvbox"] {
      --theme-base: #282828;
      --theme-surface: #3c3836;
      --theme-overlay: #504945;
      --theme-muted: #665c54;
      --theme-subtle: #a89984;
      --theme-text: #ebdbb2;
      --theme-love: #fb4934;
      --theme-gold: #fabd2f;
      --theme-rose: #fe8019;
      --theme-pine: #b8bb26;
      --theme-foam: #8ec07c;
      --theme-iris: #d3869b;
      --theme-highlight-low: #1d2021;
      --theme-highlight-med: #3c3836;
      --theme-highlight-high: #504945;
      --theme-gradient: linear-gradient(135deg, #282828 0%, #3c3836 50%, #504945 100%);
    }
    
    [data-theme="tokyo-night"] {
      --theme-base: #1a1b26;
      --theme-surface: #24283b;
      --theme-overlay: #414868;
      --theme-muted: #565f89;
      --theme-subtle: #a9b1d6;
      --theme-text: #c0caf5;
      --theme-love: #f7768e;
      --theme-gold: #e0af68;
      --theme-rose: #ff9e64;
      --theme-pine: #9ece6a;
      --theme-foam: #7dcfff;
      --theme-iris: #bb9af7;
      --theme-highlight-low: #16161e;
      --theme-highlight-med: #24283b;
      --theme-highlight-high: #414868;
      --theme-gradient: linear-gradient(135deg, #1a1b26 0%, #24283b 50%, #414868 100%);
    }
    
    [data-theme="dracula"] {
      --theme-base: #282a36;
      --theme-surface: #44475a;
      --theme-overlay: #6272a4;
      --theme-muted: #6272a4;
      --theme-subtle: #f8f8f2;
      --theme-text: #f8f8f2;
      --theme-love: #ff5555;
      --theme-gold: #f1fa8c;
      --theme-rose: #ffb86c;
      --theme-pine: #50fa7b;
      --theme-foam: #8be9fd;
      --theme-iris: #bd93f9;
      --theme-highlight-low: #21222c;
      --theme-highlight-med: #44475a;
      --theme-highlight-high: #6272a4;
      --theme-gradient: linear-gradient(135deg, #282a36 0%, #44475a 50%, #6272a4 100%);
    }

    /* Activity item hover effect */
    .activity-item {
      transition: all 0.3s ease;
    }
    .activity-item:hover {
      background: rgba(156, 207, 216, 0.05);
    }

    /* Chat Background Styles */
    #chatMessagesContainer {
      border-radius: 0.5rem;
      overflow: hidden;
    }

    #chatParticlesCanvas {
      border-radius: 0.5rem;
    }

    .chat-bg-option {
      transition: all 0.2s ease;
    }

    .chat-bg-option:hover {
      transform: scale(1.05);
    }

    .chat-bg-option.border-rp-foam {
      box-shadow: 0 0 0 2px var(--theme-foam);
    }

    /* Enhanced message bubbles for better visibility on custom backgrounds */
    #chatMessages .max-w-xs {
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Chat settings panel animation */
    #chatBackgroundSettings {
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Profile Frame Styles */
    .profile-frame-red {
      border: 3px solid #ff4444 !important;
      box-shadow: 0 0 15px #ff444450 !important;
    }

    .profile-frame-blue {
      border: 3px solid #4444ff !important;
      box-shadow: 0 0 15px #4444ff50 !important;
    }

    .profile-frame-orange {
      border: 3px solid #ff8844 !important;
      box-shadow: 0 0 15px #ff884450 !important;
    }

    .profile-frame-green {
      border: 3px solid #44ff44 !important;
      box-shadow: 0 0 15px #44ff4450 !important;
    }

    .profile-frame-purple {
      border: 3px solid #8844ff !important;
      box-shadow: 0 0 15px #8844ff50 !important;
    }

    .profile-frame-gold {
      border: 3px solid #ffd700 !important;
      box-shadow: 0 0 20px #ffd70080 !important;
      animation: goldGlow 2s infinite;
    }

    @keyframes goldGlow {
      0%, 100% { box-shadow: 0 0 20px #ffd70080 !important; }
      50% { box-shadow: 0 0 30px #ffd700a0 !important; }
    }

    .profile-frame-silver {
      border: 3px solid #c0c0c0 !important;
      box-shadow: 0 0 15px #c0c0c080 !important;
    }

    .profile-frame-rainbow {
      border: 3px solid !important;
      border-image: linear-gradient(45deg, #ff0000, #ff8000, #ffff00, #00ff00, #0080ff, #8000ff) 1 !important;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5) !important;
      animation: rainbowProfileShift 3s infinite !important;
    }

    @keyframes rainbowProfileShift {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    /* Chat message container with custom backgrounds */
    .chat-bg-gradient {
      background: linear-gradient(135deg, rgba(156, 207, 216, 0.1) 0%, rgba(196, 167, 231, 0.1) 100%);
    }

    .chat-bg-solid {
      background: rgba(49, 116, 143, 0.2);
    }

    .chat-bg-particles {
      background: rgba(25, 23, 36, 0.3);
    }

    /* Enhanced animations and transitions */
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 0 5px rgba(156, 207, 216, 0.5);
      }
      50% {
        box-shadow: 0 0 20px rgba(156, 207, 216, 0.8);
      }
    }

    @keyframes bounceIn {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
      70% {
        transform: scale(0.9);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Enhanced notification styles */
    .notification-enhanced {
      animation: slideInFromRight 0.4s ease-out;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    /* Improved button hover effects */
    .btn-enhanced {
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .btn-enhanced:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .btn-enhanced::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.1),
        transparent
      );
      transition: left 0.5s;
    }

    .btn-enhanced:hover::before {
      left: 100%;
    }

    /* Improved card animations */
    .card-animated {
      animation: fadeInScale 0.5s ease-out;
      transition: all 0.3s ease;
    }

    .card-animated:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    /* Enhanced status indicators */
    .status-indicator {
      position: relative;
    }

    .status-indicator.online::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(34, 197, 94, 0.3) 0%, transparent 70%);
      animation: pulseGlow 2s infinite;
    }

    /* Improved user cards */
    .user-card {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid transparent;
    }

    .user-card:hover {
      border-color: var(--theme-foam);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(156, 207, 216, 0.15);
    }

    /* Enhanced search input */
    .search-input {
      transition: all 0.3s ease;
    }

    .search-input:focus {
      transform: scale(1.02);
      box-shadow: 0 0 0 3px rgba(156, 207, 216, 0.1);
    }

    /* Improved modal animations */
    .modal-content {
      animation: bounceIn 0.6s ease-out;
    }

    /* Enhanced suggestion cards */
    .suggestion-card {
      background: linear-gradient(135deg, var(--theme-overlay) 0%, var(--theme-surface) 100%);
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }

    .suggestion-card:hover {
      border-color: var(--theme-iris);
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(196, 167, 231, 0.2);
    }

    /* Consistent spacing and typography */
    .text-consistent {
      line-height: 1.5;
      letter-spacing: 0.025em;
    }

    /* Enhanced loading states */
    .loading-shimmer {
      background: linear-gradient(90deg, 
        var(--theme-overlay) 25%, 
        var(--theme-highlight-med) 50%, 
        var(--theme-overlay) 75%);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% {
        background-position: -200% 0;
      }
      100% {
        background-position: 200% 0;
      }
    }

    /* Perfect scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--theme-overlay);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--theme-foam);
      border-radius: 4px;
      transition: background 0.3s ease;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--theme-iris);
    }

    /* Consistent focus states */
    .focus-enhanced:focus {
      outline: none;
      ring: 2px solid var(--theme-foam);
      ring-opacity: 0.5;
      border-color: var(--theme-foam);
    }

    /* Enhanced responsive design */
    @media (max-width: 768px) {
      .card-animated {
        animation: none;
      }
      
      .user-card:hover {
        transform: none;
      }
      
      .btn-enhanced:hover {
        transform: none;
      }
    }

    /* Perfect grid layouts */
    .grid-perfect {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    /* Enhanced notification positioning */
    .notification-stack {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-width: 400px;
    }

    /* Enhanced animations and transitions */
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(100px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulseGlow {
      0% {
        box-shadow: 0 0 0 0 rgba(156, 207, 216, 0.4);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(156, 207, 216, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(156, 207, 216, 0);
      }
    }

    .card-animated {
      animation: fadeInUp 0.3s ease-out;
    }

    .user-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(156, 207, 216, 0.15);
    }

    .suggestion-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 20px rgba(156, 207, 216, 0.1);
    }

    .btn-enhanced {
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .btn-enhanced:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .btn-enhanced:active {
      transform: translateY(0);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .search-input:focus {
      transform: scale(1.02);
      box-shadow: 0 0 0 3px rgba(156, 207, 216, 0.2);
    }

    .focus-enhanced:focus {
      animation: pulseGlow 1.5s infinite;
    }

    .text-consistent {
      word-break: break-word;
      overflow-wrap: break-word;
    }

    .notification-item {
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(156, 207, 216, 0.3);
      background: rgba(25, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transform: translateX(100%);
      opacity: 0;
      transition: all 0.3s ease;
      animation: slideInFromRight 0.3s ease forwards;
    }

    .notification-item.show {
      transform: translateX(0);
      opacity: 1;
    }

    .notification-item.hide {
      transform: translateX(100%);
      opacity: 0;
    }

    .notification-follow {
      border-color: rgba(156, 207, 216, 0.5);
    }

    .notification-game {
      border-color: rgba(235, 203, 139, 0.5);
    }

    .notification-success {
      border-color: rgba(166, 227, 161, 0.5);
    }

    .notification-error {
      border-color: rgba(235, 111, 146, 0.5);
    }

    .notification-info {
      border-color: rgba(196, 167, 231, 0.5);
    }

    .modal-content {
      animation: fadeInUp 0.3s ease-out;
    }

    .carbon-profile-avatar {
      transition: all 0.2s ease;
    }

    .carbon-profile-avatar:hover {
      transform: scale(1.05);
      box-shadow: 0 0 0 2px rgba(156, 207, 216, 0.5);
    }

    /* Responsive design improvements */
    @media (max-width: 768px) {
      .suggestion-card {
        flex-direction: column;
        gap: 3;
        text-align: center;
      }
      
      .suggestion-card .flex-1 {
        order: 1;
      }
      
      .suggestion-card .flex.flex-col {
        order: 2;
        flex-direction: row;
        justify-content: center;
        width: 100%;
      }
      
      .notification-stack {
        left: 10px;
        right: 10px;
        max-width: none;
      }
    }
  </style>
</head>
<body class="bg-rp-base min-h-screen text-rp-text font-[Inter] antialiased">

  <!-- Particles Canvas -->
  <canvas id="particles-canvas" class="fixed inset-0 pointer-events-none hidden"></canvas>

  <!-- Navbar -->
  <nav class="flex items-center justify-between px-6 py-4 bg-rp-surface/80 border-b border-rp-overlay backdrop-blur-sm fixed top-0 left-0 right-0 z-50">
    <a href="index.html" class="text-xl font-bold text-rp-foam tracking-tight">CARBON</a>
    <div class="flex items-center gap-4">
      <div id="userSection"></div>
    </div>
  </nav>

  <!-- LOGIN SCREEN -->
  <div id="loginScreen" class="flex flex-col items-center justify-center h-screen w-full bg-rp-base fixed left-0 top-0 z-50">
    <div class="bg-rp-surface rounded-xl shadow-2xl p-8 border border-rp-overlay max-w-md w-full mx-4">
      <div class="text-center mb-8">
        <h1 class="text-2xl font-bold text-rp-foam mb-2">Welcome Back</h1>
        <p class="text-rp-subtle">Sign in to view your profile</p>
      </div>
      <button onclick="googleSignIn()" class="w-full flex items-center justify-center gap-3 bg-rp-foam hover:bg-rp-foam/90 text-rp-base font-medium px-6 py-3 rounded-lg transition-all duration-200">
        <i class='bx bxl-google text-xl'></i>
        Continue with Google
      </button>
      <div id="loginError" class="text-rp-love mt-4 text-sm text-center hidden"></div>
    </div>
  </div>

  <main class="pt-20 pb-12 max-w-4xl mx-auto px-4">
    <!-- PRIVATE PROFILE -->
    <div id="profileContent" class="hidden">
      <!-- Profile Header -->
      <div class="bg-rp-surface rounded-xl p-6 mb-8 border border-rp-overlay">
        <div class="flex flex-col sm:flex-row items-center gap-6">
          <img id="profilePhoto" class="carbon-profile-avatar w-16 h-16 rounded-full ring-2 ring-rp-foam/50" src="" alt="Profile Photo">
          <div class="flex-1 text-center sm:text-left">
            <h1 id="profileName" class="text-2xl font-bold text-rp-text mb-1"></h1>
            <p id="profileEmail" class="text-rp-subtle text-sm"></p>
          </div>
          <button onclick="signOut()" class="text-rp-subtle hover:text-rp-love transition-colors text-sm">
            Sign Out
          </button>
        </div>
        
        <!-- Follower System -->
        <div class="mt-6 pt-6 border-t border-rp-overlay">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-semibold text-rp-text flex items-center gap-2">
              <i class='bx bx-group text-rp-foam'></i>
              Social
            </h3>
            <div class="flex items-center gap-4">
              <div class="text-center">
                <div class="text-xl font-bold text-rp-foam" id="followersCount">0</div>
                <div class="text-xs text-rp-subtle">Followers</div>
              </div>
              <div class="text-center">
                <div class="text-xl font-bold text-rp-iris" id="followingCount">0</div>
                <div class="text-xs text-rp-subtle">Following</div>
              </div>
            </div>
          </div>
          
          <div class="grid grid-cols-2 gap-3 mb-4">
            <button id="viewFollowersBtn" class="px-4 py-2 bg-rp-foam/20 hover:bg-rp-foam/30 text-rp-foam border border-rp-foam/30 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-center gap-2">
              <i class='bx bx-user'></i>
              View Followers
            </button>
            <button id="viewFollowingBtn" class="px-4 py-2 bg-rp-iris/20 hover:bg-rp-iris/30 text-rp-iris border border-rp-iris/30 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-center gap-2">
              <i class='bx bx-user-check'></i>
              View Following
            </button>
          </div>
          

          
          <!-- Follower Privacy Settings -->
          <div class="p-3 bg-rp-overlay rounded-lg mb-4">
            <h4 class="text-sm font-medium text-rp-text mb-2 flex items-center gap-2">
              <i class='bx bx-shield text-rp-gold'></i>
              Follower Privacy
            </h4>
            <div class="space-y-2">
              <label class="flex items-center gap-2">
                <input type="checkbox" id="allowFollowersToSeeGames" class="rounded border-rp-highlight-med text-rp-foam focus:ring-rp-foam/50">
                <span class="text-sm text-rp-text">Allow followers to see what games I'm playing</span>
              </label>
              <label class="flex items-center gap-2">
                <input type="checkbox" id="allowFollowersToSeeNotes" class="rounded border-rp-highlight-med text-rp-foam focus:ring-rp-foam/50">
                <span class="text-sm text-rp-text">Allow followers to see my notes and status</span>
              </label>
              <label class="flex items-center gap-2">
                <input type="checkbox" id="allowFollowersToSeeActivity" class="rounded border-rp-highlight-med text-rp-foam focus:ring-rp-foam/50">
                <span class="text-sm text-rp-text">Allow followers to see my activity feed</span>
              </label>
              <label class="flex items-center gap-2">
                <input type="checkbox" id="allowFollowersToChat" class="rounded border-rp-highlight-med text-rp-foam focus:ring-rp-foam/50">
                <span class="text-sm text-rp-text">Allow followers to message me</span>
              </label>
            </div>
          </div>
        </div>

        <!-- Public Profile Link -->
        <div class="mt-6 pt-6 border-t border-rp-overlay">
          <label class="block text-sm font-medium text-rp-text mb-2">Your Public Profile</label>
          <div class="flex gap-2">
            <input id="publicProfileLink" type="text" class="flex-1 px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text text-sm font-mono focus:outline-none focus:ring-2 focus:ring-rp-foam/50" readonly>
            <button id="copyProfileLinkBtn" class="px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors">
              <i class='bx bx-copy'></i>
            </button>
          </div>
          <div id="copyFeedback" class="text-rp-foam mt-2 text-sm opacity-0 transition-opacity duration-300">Copied to clipboard!</div>
        </div>
      </div>

      <!-- Background Selection -->
      <div class="bg-rp-surface rounded-xl p-6 mb-8 border border-rp-overlay">
        <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
          <i class='bx bx-palette text-rp-iris'></i>
          Background
        </h2>
        <p class="text-rp-subtle text-sm mb-4">Customize your background appearance</p>
        <div class="mb-4">
          <label class="block text-sm font-medium text-rp-text mb-2">Background Type</label>
          <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
            <div class="bg-preview active rounded-lg p-2 cursor-pointer border border-rp-foam transition-all duration-200" data-bg="gradient" style="background: var(--theme-gradient);">
              <div class="text-center text-xs text-white">Gradient</div>
            </div>
            <div class="bg-preview rounded-lg p-2 cursor-pointer border border-transparent hover:border-rp-foam transition-all duration-200" data-bg="solid">
              <div class="text-center text-xs text-white">Solid</div>
            </div>
            <div class="bg-preview rounded-lg p-2 cursor-pointer border border-transparent hover:border-rp-foam transition-all duration-200" data-bg="pattern">
              <div class="text-center text-xs text-white">Pattern</div>
            </div>
            <div class="bg-preview rounded-lg p-2 cursor-pointer border border-transparent hover:border-rp-foam transition-all duration-200" data-bg="particles">
              <div class="text-center text-xs text-white">Particles</div>
            </div>
          </div>
        </div>
        <div>
          <label class="block text-sm font-medium text-rp-text mb-2">Custom Background</label>
          <div id="bg-upload" class="border-2 border-dashed border-rp-highlight-med rounded-lg p-4 text-center cursor-pointer hover:bg-rp-overlay transition-all duration-200">
            <i class="bx bx-cloud-upload text-2xl text-rp-muted mb-1"></i>
            <p class="text-rp-muted text-sm">Upload or drag and drop an image</p>
            <p class="text-xs text-rp-subtle">JPG, PNG, WebP</p>
          </div>
          <input type="file" id="bg-file-input" accept="image/*" class="hidden">
          <div id="custom-bg-preview" class="mt-4 hidden">
            <div id="bg-preview-image" class="w-full h-40 rounded-lg bg-cover bg-center border border-rp-highlight-med hover:border-rp-foam transition-all duration-200"></div>
            <div class="flex gap-2 mt-2">
              <button id="remove-bg" class="px-3 py-1 bg-rp-love text-white rounded-lg text-sm hover:bg-rp-love/80 transition-all duration-200">Remove</button>
              <button id="change-bg" class="px-3 py-1 bg-rp-foam text-rp-base rounded-lg text-sm hover:bg-rp-foam/80 transition-all duration-200">Change</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Game Statistics -->
      <div id="gameStatsContainer" class="mb-8">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-semibold text-rp-text flex items-center gap-2">
            <i class='bx bx-bar-chart text-rp-iris'></i>
            Gaming Statistics
          </h2>
          <button id="refreshStatsBtn" class="px-3 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors text-sm flex items-center gap-2">
            <i class='bx bx-refresh'></i>
            Refresh
          </button>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4 text-center">
            <div class="text-2xl font-bold text-rp-foam" id="totalGamesPlayed">0</div>
            <div class="text-sm text-rp-subtle">Games Played</div>
          </div>
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4 text-center">
            <div class="text-2xl font-bold text-rp-gold" id="totalPlayTime">0h 0m</div>
            <div class="text-sm text-rp-subtle">Total Play Time</div>
          </div>
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4 text-center">
            <div class="text-2xl font-bold text-rp-iris" id="averageSessionTime">0m</div>
            <div class="text-sm text-rp-subtle">Avg Session</div>
          </div>
        </div>
        
        <!-- Top Games by Play Time -->
        <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
          <h3 class="text-lg font-semibold text-rp-text mb-3 flex items-center gap-2">
            <i class='bx bx-game text-rp-pine'></i>
            Most Played Games
          </h3>
          <div id="topGamesList" class="space-y-3">
            <!-- Top games will be populated here -->
          </div>
          <div id="noGameStats" class="text-rp-subtle text-sm text-center py-4">Start playing games to see your statistics!</div>
        </div>
      </div>

      <!-- Recent Games -->
      <div id="recentGamesContainer" class="mb-8">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-semibold text-rp-text flex items-center gap-2">
            <i class='bx bx-time text-rp-gold'></i>
            Recently Played
          </h2>
          <button id="clearRecentGamesBtn" class="px-4 py-2 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love border border-rp-love/30 hover:border-rp-love/50 rounded-lg transition-all duration-200 text-sm font-medium flex items-center gap-2">
            <i class='bx bx-trash'></i>
            Clear History
          </button>
        </div>
        <div id="recentGamesList" class="space-y-3"></div>
      </div>

      <!-- Games Grid -->
      <div class="grid lg:grid-cols-2 gap-8 mb-8">
        <!-- Favorite Games -->
        <div>
          <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
            <i class='bx bx-heart text-rp-love'></i>
            Favorite Games
          </h2>
          <div id="favoriteGamesList" class="space-y-3"></div>
        </div>

        <!-- Liked Games -->
        <div>
          <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
            <i class='bx bx-like text-rp-iris'></i>
            Liked Games
          </h2>
          <div id="likedGamesList" class="space-y-3"></div>
        </div>
      </div>

      <!-- Friends & Social Section -->
      <div class="grid lg:grid-cols-3 gap-8 mb-8">
        <!-- Friends List -->
        <div class="lg:col-span-2">
          <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-semibold text-rp-text flex items-center gap-2">
              <i class='bx bx-group text-rp-foam'></i>
              Friends <span id="friendsCount" class="text-sm bg-rp-foam/20 text-rp-foam px-2 py-1 rounded-full">0</span>
            </h2>
            <div class="flex gap-2">
              <button id="searchUsersBtn" class="px-3 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors text-sm flex items-center gap-2">
                <i class='bx bx-search'></i>
                Find Friends
              </button>
              <button id="friendRequestsBtn" class="relative px-3 py-2 bg-rp-iris hover:bg-rp-iris/90 text-white rounded-lg transition-colors text-sm flex items-center gap-2">
                <i class='bx bx-user-plus'></i>
                Requests
                <span id="requestsBadge" class="absolute -top-2 -right-2 bg-rp-love text-white text-xs rounded-full w-5 h-5 flex items-center justify-center hidden">0</span>
              </button>
            </div>
          </div>
          
          <!-- Friends Grid -->
          <div id="friendsList" class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
            <!-- Friends will be populated here -->
          </div>
          
          <!-- Status Selector -->
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4 mb-6">
            <div class="flex items-center gap-4">
              <div class="relative">
                <img id="userAvatar" src="" alt="Your Avatar" class="carbon-profile-avatar w-14 h-14 rounded-full ring-2 ring-rp-foam/50">
                <div id="statusIndicator" class="absolute -bottom-1 -right-1 w-5 h-5 rounded-full border-2 border-rp-surface bg-green-500"></div>
              </div>
              <div class="flex-1">
                <h4 id="userDisplayName" class="font-semibold text-rp-text text-lg">Loading...</h4>
                <div class="flex items-center gap-3 mt-1">
                  <select id="statusSelector" class="bg-rp-highlight-med text-rp-text border border-rp-overlay rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-rp-foam transition-colors">
                    <option value="online">🟢 Online</option>
                    <option value="idle">🟡 Idle</option>
                    <option value="dnd">🔴 Do Not Disturb</option>
                    <option value="offline">⚫ Offline</option>
                  </select>
                  <div id="currentGameDisplay" class="text-sm text-rp-subtle hidden">
                    Playing <span id="currentGameName" class="text-rp-gold font-medium"></span>
                  </div>
                </div>
                
                <!-- 24-Hour Status Note -->
                <div class="mt-3">
                  <div id="currentStatusNote" class="hidden">
                    <div class="flex items-center gap-2 p-2 bg-rp-overlay rounded-lg">
                      <span class="text-rp-gold">💭</span>
                      <span id="statusNoteText" class="text-sm text-rp-text flex-1"></span>
                      <span id="statusNoteExpiry" class="text-xs text-rp-subtle"></span>
                      <button id="clearStatusNote" class="text-rp-love hover:text-rp-love/80 transition-colors">
                        <i class='bx bx-x'></i>
                      </button>
                    </div>
                  </div>
                  <button id="addStatusNote" class="w-full mt-2 px-3 py-2 bg-rp-highlight-med hover:bg-rp-highlight-high text-rp-text rounded-lg transition-colors text-sm flex items-center justify-center gap-2">
                    <i class='bx bx-message-add'></i>
                    Add 24h Status Note
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Bio Section -->
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold text-rp-text flex items-center gap-2">
                <i class='bx bx-edit text-rp-gold'></i>
                Bio & Profile
              </h3>
              <button id="editBioBtn" class="px-3 py-2 bg-rp-gold hover:bg-rp-gold/90 text-rp-base rounded-lg transition-colors text-sm">
                Edit
              </button>
            </div>
            
            <div id="bioDisplay" class="space-y-4">
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Username</label>
                <p id="displayUsername" class="text-rp-subtle">Not set</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Bio</label>
                <p id="displayBio" class="text-rp-subtle">No bio set</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Last Played Game</label>
                <div id="displayLastGame" class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg">
                  <img id="lastGameImage" src="" alt="Game" class="w-12 h-12 rounded-lg object-cover">
                  <div class="flex-1 min-w-0">
                    <p id="lastGameTitle" class="font-medium text-rp-text truncate">No games played yet</p>
                    <p id="lastGameTime" class="text-xs text-rp-subtle">-</p>
                  </div>
                </div>
              </div>
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Favorite Games</label>
                <div id="displayFavoriteGames" class="flex flex-wrap gap-2">
                  <!-- Favorite games tags will be shown here -->
                </div>
              </div>
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Privacy</label>
                <p id="displayPrivacy" class="text-rp-subtle">Public Profile</p>
              </div>
            </div>
            
            <div id="bioEditor" class="space-y-4 hidden">
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Username</label>
                <input id="editUsername" type="text" maxlength="20" class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50" placeholder="Enter username">
                <p class="text-xs text-rp-muted mt-1">Letters, numbers, and underscores only</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Bio</label>
                <textarea id="editBio" maxlength="200" rows="3" class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50 resize-none" placeholder="Tell others about yourself..."></textarea>
                <p class="text-xs text-rp-muted mt-1"><span id="bioCharCount">0</span>/200 characters</p>
              </div>
              <div>
                <label class="block text-sm font-medium text-rp-text mb-1">Profile Privacy</label>
                <select id="editPrivacy" class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50">
                  <option value="public">Public - Anyone can see</option>
                  <option value="friends">Friends Only</option>
                  <option value="private">Private - Hidden</option>
                </select>
              </div>
              <div class="flex gap-2">
                <button id="saveBioBtn" class="px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors text-sm">
                  Save Changes
                </button>
                <button id="cancelBioBtn" class="px-4 py-2 bg-rp-highlight-med hover:bg-rp-highlight-high text-rp-text rounded-lg transition-colors text-sm">
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
        
                  <!-- Chat & Online Friends -->
        <div class="space-y-6">
          <!-- Online Friends -->
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
            <h3 class="text-lg font-semibold text-rp-text mb-4 flex items-center gap-2">
              <i class='bx bx-wifi text-rp-pine'></i>
              Online Friends
            </h3>
            <div id="onlineFriendsList" class="space-y-2">
              <!-- Online friends will be populated here -->
            </div>
            <div id="noOnlineFriends" class="text-rp-subtle text-sm text-center py-4">No friends online</div>
          </div>
          
          <!-- Friend Streaks -->
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
            <h3 class="text-lg font-semibold text-rp-text mb-4 flex items-center gap-2">
              <i class='bx bx-trending-up text-rp-gold'></i>
              Friend Streaks 🔥
            </h3>
            <div id="friendStreaksList" class="space-y-2">
              <!-- Friend streaks will be populated here -->
            </div>
            <div id="noStreaks" class="text-rp-subtle text-sm text-center py-4">Start messaging friends to build streaks!</div>
          </div>
          
          <!-- Friend Leaderboard -->
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
            <h3 class="text-lg font-semibold text-rp-text mb-4 flex items-center gap-2">
              <i class='bx bx-trophy text-rp-iris'></i>
              Friend Leaderboard 🏆
            </h3>
            <div class="mb-3">
              <select id="leaderboardType" class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text text-sm focus:outline-none focus:ring-2 focus:ring-rp-foam/50">
                <option value="gamesPlayed">Most Games Played</option>
                <option value="totalPlayTime">Most Play Time</option>
                <option value="averageSession">Longest Avg Session</option>
              </select>
            </div>
            <div id="friendLeaderboardList" class="space-y-2">
              <!-- Friend leaderboard will be populated here -->
            </div>
            <div id="noLeaderboardData" class="text-rp-subtle text-sm text-center py-4">No gaming data available yet!</div>
          </div>
          
          <!-- Suggested Users to Follow -->
          <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold text-rp-text flex items-center gap-2">
                <i class='bx bx-user-plus text-rp-iris'></i>
                Suggested Users 💭
              </h3>
              <button id="refreshSuggestionsBtn" class="px-3 py-1 bg-rp-iris/20 text-rp-iris rounded-lg hover:bg-rp-iris/30 transition-colors text-xs">
                <i class='bx bx-refresh mr-1'></i>
                Refresh
              </button>
            </div>
            <div id="suggestedUsersList" class="space-y-2">
              <!-- Suggested users will be populated here -->
            </div>
            <div id="noSuggestedUsers" class="text-rp-subtle text-sm text-center py-4">
              <i class='bx bx-user-circle text-2xl mb-2 block'></i>
              No suggestions available
            </div>
            <div id="suggestionsLoading" class="text-center py-4 hidden">
              <div class="inline-block w-6 h-6 border-2 border-rp-iris border-t-transparent rounded-full animate-spin"></div>
              <p class="text-rp-iris mt-2 text-sm">Finding suggestions...</p>
            </div>
          </div>
          
          <!-- Quick Chat -->
          <div id="quickChatSection" class="bg-rp-surface rounded-xl border border-rp-overlay p-4 hidden">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-lg font-semibold text-rp-text flex items-center gap-2">
                <i class='bx bx-message-dots text-rp-iris'></i>
                Chat with <span id="chatFriendName">Friend</span>
              </h3>
              <div class="flex items-center gap-2">
                <button id="chatSettingsBtn" class="text-rp-subtle hover:text-rp-foam transition-colors" title="Chat Settings">
                  <i class='bx bx-palette text-lg'></i>
                </button>
                <button id="closeChatBtn" class="text-rp-subtle hover:text-rp-love transition-colors">
                  <i class='bx bx-x text-xl'></i>
                </button>
              </div>
            </div>
            
            <!-- Chat Background Settings -->
            <div id="chatBackgroundSettings" class="mb-4 p-3 bg-rp-overlay rounded-lg hidden">
              <h4 class="text-sm font-medium text-rp-text mb-3 flex items-center gap-2">
                <i class='bx bx-palette'></i>
                Chat Background
              </h4>
              <div class="grid grid-cols-4 gap-2">
                <button class="chat-bg-option w-full h-12 rounded-lg border-2 border-transparent hover:border-rp-foam/50 transition-all relative" 
                        data-bg="default" title="Default">
                  <div class="w-full h-full bg-rp-overlay rounded-lg flex items-center justify-center">
                    <i class='bx bx-square text-rp-text'></i>
                  </div>
                </button>
                <button class="chat-bg-option w-full h-12 rounded-lg border-2 border-transparent hover:border-rp-foam/50 transition-all relative" 
                        data-bg="gradient" title="Gradient">
                  <div class="w-full h-full rounded-lg" style="background: linear-gradient(135deg, #9ccfd8 0%, #c4a7e7 100%)"></div>
                </button>
                <button class="chat-bg-option w-full h-12 rounded-lg border-2 border-transparent hover:border-rp-foam/50 transition-all relative" 
                        data-bg="solid" title="Solid Color">
                  <div class="w-full h-full bg-rp-pine rounded-lg"></div>
                </button>
                <button class="chat-bg-option w-full h-12 rounded-lg border-2 border-transparent hover:border-rp-foam/50 transition-all relative" 
                        data-bg="particles" title="Particles">
                  <div class="w-full h-full bg-rp-base rounded-lg flex items-center justify-center">
                    <div class="w-2 h-2 bg-rp-foam rounded-full animate-pulse"></div>
                    <div class="w-1 h-1 bg-rp-gold rounded-full ml-1 animate-bounce"></div>
                    <div class="w-1.5 h-1.5 bg-rp-iris rounded-full ml-1 animate-pulse" style="animation-delay: 0.5s;"></div>
                  </div>
                </button>
              </div>
              <p class="text-xs text-rp-subtle mt-2">Background changes are visible to both you and your friend</p>
            </div>
            
            <div id="chatMessagesContainer" class="relative">
              <!-- Chat background canvas for particles -->
              <canvas id="chatParticlesCanvas" class="absolute inset-0 rounded-lg hidden pointer-events-none"></canvas>
              
              <div id="chatMessages" class="h-48 overflow-y-auto bg-rp-overlay rounded-lg p-3 mb-3 space-y-2 relative z-10">
                <!-- Chat messages will be populated here -->
              </div>
            </div>
            
            <div class="flex gap-2">
              <input id="chatInput" type="text" maxlength="500" placeholder="Type a message..." class="flex-1 px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50 text-sm">
              <button id="sendMessageBtn" class="flex-shrink-0 w-10 h-10 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors flex items-center justify-center">
                <i class='bx bx-send text-sm'></i>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Activity Feed -->
      <div id="activityFeedSection" class="mb-8">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-semibold text-rp-text flex items-center gap-2">
            <i class='bx bx-activity text-rp-pine'></i>
            Recent Activity
          </h2>
          <button onclick="if(document.getElementById('activityFeed')) loadActivityFeed().catch(console.error)" class="px-3 py-1 bg-rp-foam/20 text-rp-foam rounded-lg hover:bg-rp-foam/30 transition-colors text-sm">
            <i class='bx bx-refresh mr-1'></i>
            Refresh
          </button>
        </div>
        <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
          <div id="activityFeed" class="max-h-80 overflow-y-auto space-y-2"></div>
          <div id="activityLoader" class="text-center py-8 hidden">
            <div class="inline-block w-6 h-6 border-2 border-rp-foam border-t-transparent rounded-full animate-spin"></div>
            <p class="text-rp-foam mt-2 text-sm">Loading activity...</p>
          </div>
          <div id="noActivity" class="text-rp-subtle text-sm text-center py-8 hidden">
            <i class='bx bx-time text-2xl mb-2 block'></i>
            No recent activity to show
          </div>
        </div>
      </div>
    </div>

    <!-- PUBLIC PROFILE -->
    <div id="publicProfileContent" class="hidden">
      <!-- Public Profile Header -->
      <div class="bg-rp-surface rounded-xl p-6 mb-8 border border-rp-overlay">
        <div class="flex flex-col sm:flex-row items-center gap-6">
          <img id="publicProfilePhoto" class="carbon-profile-avatar w-16 h-16 rounded-full ring-2 ring-rp-foam/50" src="" alt="Profile Photo">
          <div class="flex-1 text-center sm:text-left">
            <h1 id="publicProfileName" class="text-2xl font-bold text-rp-text mb-1"></h1>
            <p id="publicProfileUsername" class="text-rp-subtle text-sm"></p>
          </div>
        </div>
        
              <!-- Friend Actions & Share Profile -->
      <div class="mt-6 pt-6 border-t border-rp-overlay space-y-4">
        <!-- Friend and Follower Actions -->
        <div id="publicProfileActions" class="hidden">
          <!-- Follower Stats -->
          <div class="flex items-center justify-center gap-6 mb-4 p-3 bg-rp-overlay rounded-lg">
            <div class="text-center">
              <div class="text-lg font-bold text-rp-foam" id="publicFollowersCount">0</div>
              <div class="text-xs text-rp-subtle">Followers</div>
            </div>
            <div class="text-center">
              <div class="text-lg font-bold text-rp-iris" id="publicFollowingCount">0</div>
              <div class="text-xs text-rp-subtle">Following</div>
            </div>
          </div>
          
          <!-- Action Buttons -->
          <div class="grid grid-cols-2 gap-2 mb-3">
            <!-- Follow System -->
            <button id="followUserBtn" class="px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors text-sm flex items-center justify-center gap-2">
              <i class='bx bx-user-plus'></i>
              Follow
            </button>
            <button id="unfollowUserBtn" class="px-4 py-2 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love border border-rp-love/30 rounded-lg transition-colors text-sm hidden flex items-center justify-center gap-2">
              <i class='bx bx-user-minus'></i>
              Unfollow
            </button>
            
            <!-- Friend System -->
            <button id="addFriendBtn" class="px-4 py-2 bg-rp-iris hover:bg-rp-iris/90 text-white rounded-lg transition-colors text-sm flex items-center justify-center gap-2">
              <i class='bx bx-user-check'></i>
              Add Friend
            </button>
            <button id="removeFriendBtn" class="px-4 py-2 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love border border-rp-love/30 rounded-lg transition-colors text-sm hidden">
              <i class='bx bx-user-x'></i>
              Remove Friend
            </button>
          </div>
          
          <!-- Secondary Actions -->
          <div class="flex gap-2">
            <button id="chatWithUserBtn" class="flex-1 px-4 py-2 bg-rp-gold/20 hover:bg-rp-gold/30 text-rp-gold border border-rp-gold/30 rounded-lg transition-colors text-sm flex items-center justify-center gap-2 hidden">
              <i class='bx bx-message'></i>
              Message
            </button>
            <button id="viewFollowersListBtn" class="flex-1 px-4 py-2 bg-rp-foam/20 hover:bg-rp-foam/30 text-rp-foam border border-rp-foam/30 rounded-lg transition-colors text-sm flex items-center justify-center gap-2">
              <i class='bx bx-group'></i>
              Followers
            </button>
          </div>
          
          <div id="followStatus" class="text-center text-sm text-rp-subtle mt-2"></div>
          <div id="friendshipStatus" class="text-center text-sm text-rp-subtle mt-1"></div>
        </div>
        
        <!-- Share Profile -->
        <div>
          <label class="block text-sm font-medium text-rp-text mb-2">Share this profile</label>
          <div class="flex gap-2">
            <input id="publicProfileUrl" type="text" class="flex-1 px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text text-sm font-mono focus:outline-none focus:ring-2 focus:ring-rp-foam/50" readonly>
            <button id="copyPublicProfileUrlBtn" class="px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors">
              <i class='bx bx-copy'></i>
            </button>
          </div>
          <div id="copyPublicFeedback" class="text-rp-foam mt-2 text-sm opacity-0 transition-opacity duration-300">Copied to clipboard!</div>
        </div>
      </div>
      </div>

      <!-- Public Recent Games -->
      <div id="publicRecentGamesContainer" class="mb-8">
        <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
          <i class='bx bx-time text-rp-gold'></i>
          Recently Played
        </h2>
        <div id="publicRecentGamesList" class="space-y-3"></div>
      </div>

      <!-- Public Games Grid -->
      <div class="grid lg:grid-cols-2 gap-8 mb-8">
        <!-- Public Favorite Games -->
        <div>
          <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
            <i class='bx bx-heart text-rp-love'></i>
            Favorite Games
          </h2>
          <div id="publicFavoriteGamesList" class="space-y-3"></div>
        </div>

        <!-- Public Liked Games -->
        <div>
          <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
            <i class='bx bx-like text-rp-iris'></i>
            Liked Games
          </h2>
          <div id="publicLikedGamesList" class="space-y-3"></div>
        </div>
      </div>

      <!-- Public Activity Feed -->
      <div id="publicActivityFeedSection" class="mb-8">
        <h2 class="text-xl font-semibold text-rp-text mb-4 flex items-center gap-2">
          <i class='bx bx-activity text-rp-pine'></i>
          Recent Activity
        </h2>
        <div class="bg-rp-surface rounded-xl border border-rp-overlay p-4">
          <div id="publicActivityFeed" class="max-h-64 overflow-y-auto"></div>
          <div id="publicActivityLoader" class="text-center py-8 hidden">
            <div class="inline-block w-6 h-6 border-2 border-rp-foam border-t-transparent rounded-full animate-spin"></div>
            <p class="text-rp-foam mt-2">Loading activity...</p>
          </div>
          <div id="publicNoActivity" class="text-rp-subtle text-sm text-center py-4 hidden">No recent activity</div>
        </div>
      </div>
    </div>
  </main>

  <!-- Modal Overlays -->
  <!-- User Search Modal -->
  <div id="userSearchModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6 w-full max-w-md mx-4 modal-content">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-rp-text">Find Friends</h3>
        <button id="closeSearchModal" class="text-rp-subtle hover:text-rp-love transition-colors">
          <i class='bx bx-x text-xl'></i>
        </button>
      </div>
      
      <div class="space-y-4">
        <div>
          <input id="userSearchInput" type="text" placeholder="Search by username or UID..." class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50 search-input focus-enhanced">
        </div>
        
        <div id="searchResults" class="max-h-64 overflow-y-auto space-y-2">
          <!-- Search results will be populated here -->
        </div>
        
        <div id="searchLoading" class="text-center py-4 hidden">
          <div class="inline-block w-6 h-6 border-2 border-rp-foam border-t-transparent rounded-full animate-spin"></div>
          <p class="text-rp-foam mt-2 text-sm">Searching...</p>
        </div>
        
        <div id="noSearchResults" class="text-rp-subtle text-sm text-center py-4 hidden">
          No users found
        </div>
      </div>
    </div>
  </div>

  <!-- Friend Requests Modal -->
  <div id="friendRequestsModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6 w-full max-w-lg mx-4">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-rp-text">Friend Requests</h3>
        <button id="closeRequestsModal" class="text-rp-subtle hover:text-rp-love transition-colors">
          <i class='bx bx-x text-xl'></i>
        </button>
      </div>
      
      <div class="space-y-4">
        <!-- Incoming Requests -->
        <div>
          <h4 class="text-md font-medium text-rp-text mb-2 flex items-center gap-2">
            <i class='bx bx-download text-rp-foam'></i>
            Incoming Requests
          </h4>
          <div id="incomingRequests" class="space-y-2">
            <!-- Incoming requests will be populated here -->
          </div>
          <div id="noIncomingRequests" class="text-rp-subtle text-sm text-center py-2">No incoming requests</div>
        </div>
        
        <!-- Outgoing Requests -->
        <div>
          <h4 class="text-md font-medium text-rp-text mb-2 flex items-center gap-2">
            <i class='bx bx-upload text-rp-iris'></i>
            Sent Requests
          </h4>
          <div id="outgoingRequests" class="space-y-2">
            <!-- Outgoing requests will be populated here -->
          </div>
          <div id="noOutgoingRequests" class="text-rp-subtle text-sm text-center py-2">No sent requests</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Invite Modal -->
  <div id="gameInviteModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6 w-full max-w-md mx-4">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-rp-text">Game Invitation</h3>
        <button id="closeInviteModal" class="text-rp-subtle hover:text-rp-love transition-colors">
          <i class='bx bx-x text-xl'></i>
        </button>
      </div>
      
      <div id="inviteContent" class="space-y-4">
        <!-- Invite content will be populated here -->
      </div>
    </div>
  </div>

  <!-- Status Note Modal -->
  <div id="statusNoteModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6 w-full max-w-md mx-4">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-rp-text">Add 24h Status Note</h3>
        <button id="closeStatusNoteModal" class="text-rp-subtle hover:text-rp-love transition-colors">
          <i class='bx bx-x text-xl'></i>
        </button>
      </div>
      
      <div class="space-y-4">
        <div>
          <label class="block text-sm font-medium text-rp-text mb-2">Your Status Note</label>
          <textarea id="statusNoteInput" maxlength="100" rows="3" placeholder="What's on your mind? (visible to friends for 24h)" class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50 resize-none"></textarea>
          <p class="text-xs text-rp-muted mt-1"><span id="statusNoteCharCount">0</span>/100 characters</p>
        </div>
        
        <div class="flex gap-2">
          <button id="saveStatusNote" class="flex-1 px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors text-sm">
            <i class='bx bx-check mr-2'></i>
            Post Note
          </button>
          <button id="cancelStatusNote" class="px-4 py-2 bg-rp-highlight-med hover:bg-rp-highlight-high text-rp-text rounded-lg transition-colors text-sm">
            Cancel
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Followers/Following Modal -->
  <div id="followersModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6 w-full max-w-lg mx-4 max-h-[80vh] overflow-hidden flex flex-col">
      <div class="flex items-center justify-between mb-4">
        <h3 id="followersModalTitle" class="text-lg font-semibold text-rp-text">Followers</h3>
        <button id="closeFollowersModal" class="text-rp-subtle hover:text-rp-love transition-colors">
          <i class='bx bx-x text-xl'></i>
        </button>
      </div>
      
      <!-- Tab Switcher -->
      <div class="flex gap-2 mb-4">
        <button id="followersTab" class="flex-1 px-4 py-2 bg-rp-foam/20 text-rp-foam border border-rp-foam/30 rounded-lg transition-colors text-sm">
          Followers (<span id="followersTabCount">0</span>)
        </button>
        <button id="followingTab" class="flex-1 px-4 py-2 bg-rp-highlight-med text-rp-text rounded-lg transition-colors text-sm">
          Following (<span id="followingTabCount">0</span>)
        </button>
      </div>
      
      <!-- Search Bar -->
      <div class="mb-4">
        <div class="relative">
          <i class='bx bx-search absolute left-3 top-1/2 transform -translate-y-1/2 text-rp-muted'></i>
          <input id="followerSearchInput" type="text" placeholder="Search users..." class="w-full pl-10 pr-4 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50 text-sm">
        </div>
      </div>
      
      <!-- User Lists -->
      <div class="flex-1 overflow-hidden">
        <div id="followersList" class="h-full overflow-y-auto space-y-2">
          <!-- Followers will be populated here -->
        </div>
        <div id="followingList" class="h-full overflow-y-auto space-y-2 hidden">
          <!-- Following will be populated here -->
        </div>
      </div>
      
      <!-- Loading and Empty States -->
      <div id="followersLoading" class="text-center py-8 hidden">
        <div class="inline-block w-6 h-6 border-2 border-rp-foam border-t-transparent rounded-full animate-spin"></div>
        <p class="text-rp-foam mt-2 text-sm">Loading...</p>
      </div>
      
      <div id="noFollowersFound" class="text-center py-8 text-rp-subtle text-sm hidden">
        <i class='bx bx-user text-2xl mb-2 block'></i>
        No followers yet
      </div>
      
      <div id="noFollowingFound" class="text-center py-8 text-rp-subtle text-sm hidden">
        <i class='bx bx-user-check text-2xl mb-2 block'></i>
        Not following anyone yet
      </div>
    </div>
  </div>

  <!-- Friend Notes Modal -->
  <div id="friendNotesModal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
    <div class="bg-rp-surface rounded-xl border border-rp-overlay p-6 w-full max-w-lg mx-4">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-semibold text-rp-text">Private Notes</h3>
        <button id="closeFriendNotesModal" class="text-rp-subtle hover:text-rp-love transition-colors">
          <i class='bx bx-x text-xl'></i>
        </button>
      </div>
      
      <div class="space-y-4">
        <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg">
          <img id="friendNoteAvatar" src="" class="w-10 h-10 rounded-full" alt="">
          <div>
            <h4 id="friendNoteName" class="font-medium text-rp-text"></h4>
            <p class="text-xs text-rp-subtle">Private notes are only visible to you</p>
          </div>
        </div>
        
        <div>
          <label class="block text-sm font-medium text-rp-text mb-2">Your Notes</label>
          <textarea id="friendNoteInput" maxlength="500" rows="5" placeholder="Write private notes about this friend..." class="w-full px-3 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:ring-2 focus:ring-rp-foam/50 resize-none"></textarea>
          <p class="text-xs text-rp-muted mt-1"><span id="friendNoteCharCount">0</span>/500 characters</p>
        </div>
        
        <div class="flex gap-2">
          <button id="saveFriendNote" class="flex-1 px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors text-sm">
            <i class='bx bx-save mr-2'></i>
            Save Notes
          </button>
          <button id="cancelFriendNote" class="px-4 py-2 bg-rp-highlight-med hover:bg-rp-highlight-high text-rp-text rounded-lg transition-colors text-sm">
            Cancel
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Notification Toast -->
  <div id="notificationToast" class="fixed top-4 right-4 bg-rp-surface border border-rp-overlay rounded-lg p-4 shadow-lg z-50 transform translate-x-full transition-transform duration-300">
    <div class="flex items-center gap-3">
      <div id="notificationIcon" class="w-8 h-8 rounded-full bg-rp-foam flex items-center justify-center">
        <i class='bx bx-bell text-rp-base'></i>
      </div>
      <div class="flex-1">
        <p id="notificationTitle" class="text-rp-text font-medium text-sm"></p>
        <p id="notificationMessage" class="text-rp-subtle text-xs"></p>
      </div>
      <button id="closeNotification" class="text-rp-subtle hover:text-rp-love transition-colors">
        <i class='bx bx-x'></i>
      </button>
    </div>
  </div>

  <script>
    // FIREBASE INIT
    const firebaseConfig = {
      apiKey: "AIzaSyC4ilHYP1T-kdXbWPoHJHhD2aj0pNWmMec",
      authDomain: "carbon-services.firebaseapp.com",
      projectId: "carbon-services",
      storageBucket: "carbon-services.firebasestorage.app",
      messagingSenderId: "288385472070",
      appId: "1:288385472070:web:c4be3ff186e248fc645c47",
      measurementId: "G-Y2K1RQYE74"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // XSS Protection Functions using DOMPurify
    function sanitizeHTML(dirty) {
      return DOMPurify.sanitize(dirty, { ALLOWED_TAGS: [], ALLOWED_ATTR: [] });
    }
    
    function sanitizeHTMLWithBasicTags(dirty) {
      return DOMPurify.sanitize(dirty, { 
        ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'br'], 
        ALLOWED_ATTR: [] 
      });
    }
    
    function sanitizeText(text) {
      if (!text) return '';
      return sanitizeHTML(String(text));
    }

    function googleSignIn() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider)
        .catch((error) => {
          document.getElementById('loginError').innerText = error.message;
          document.getElementById('loginError').classList.remove('hidden');
        });
    }
    function signOut() {
      auth.signOut().then(() => location.reload());
    }

    let gamesData = [];
    async function loadGamesData() {
      try {
        const res = await fetch('games.json');
        gamesData = await res.json();
      } catch (error) {
        console.error('Error loading games data:', error);
      }
    }

    async function getUserGameLists(uid) {
      const doc = await db.collection('users').doc(uid).get();
      return doc.exists ? doc.data() : { likedGames: [], favoriteGames: [], playlist: [], history: [] };
    }

    async function getUserPublicProfile(uid) {
      const doc = await db.collection('users').doc(uid).get();
      if (doc.exists) {
        const user = doc.data();
        return {
          displayName: user.displayName || '',
          username: user.username || '',
          photoURL: user.photoURL || '',
          likedGames: user.likedGames || [],
          favoriteGames: user.favoriteGames || [],
          history: user.history || [],
        };
      }
      return null;
    }

    async function ensureUserDoc(user) {
      const userRef = db.collection('users').doc(user.uid);
      const doc = await userRef.get();
      if (!doc.exists) {
        await userRef.set({
          displayName: user.displayName || "",
          photoURL: user.photoURL || "",
          email: user.email || "",
          username: "",
          likedGames: [],
          favoriteGames: [],
          history: [],
          friends: [],
          bio: "",
          privacy: "public",
          status: "online",
          lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
          currentGame: null
        });
      } else {
        let needsUpdate = false;
        const data = doc.data();
        const updateFields = {};
        if (!data.displayName && user.displayName) {
          updateFields.displayName = user.displayName;
          needsUpdate = true;
        }
        if (!data.photoURL && user.photoURL) {
          updateFields.photoURL = user.photoURL;
          needsUpdate = true;
        }
        // Initialize new fields if they don't exist
        if (!data.hasOwnProperty('friends')) {
          updateFields.friends = [];
          needsUpdate = true;
        }
        if (!data.hasOwnProperty('bio')) {
          updateFields.bio = "";
          needsUpdate = true;
        }
        if (!data.hasOwnProperty('privacy')) {
          updateFields.privacy = "public";
          needsUpdate = true;
        }
        if (!data.hasOwnProperty('status')) {
          updateFields.status = "online";
          needsUpdate = true;
        }
        if (needsUpdate) await userRef.update(updateFields);
      }
    }

    // === FRIEND SYSTEM FUNCTIONALITY ===
    
    let currentUser = null;
    let onlineFriends = new Set();
    let friendsStatusListeners = new Map();
    let activeChatUser = null;
    let chatListener = null;

    // Status system functions
    const statusColors = {
      online: 'bg-green-500',
      idle: 'bg-yellow-500', 
      dnd: 'bg-red-500',
      offline: 'bg-gray-500',
      ingame: 'bg-blue-500'
    };

    // Real-time status tracking with localStorage persistence
    async function updateUserStatus(status, gameId = null) {
      if (!currentUser) return;
      
      try {
        const updateData = {
          status: status,
          lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        if (gameId) {
          updateData.currentGame = gameId;
          updateData.status = 'ingame';
        } else if (!gameId && status !== 'ingame') {
          updateData.currentGame = null;
        }
        
        console.log('Updating user status to:', status, 'with data:', updateData);
        await db.collection('users').doc(currentUser.uid).update(updateData);
        console.log('Status updated successfully in Firebase');
        
        // Save status to localStorage for persistence across refreshes
        localStorage.setItem('carbon-user-status', status);
        localStorage.setItem('carbon-user-status-timestamp', Date.now().toString());
        
        // Update UI
        updateStatusIndicator(status);
        
        // Update status selector to reflect current status
        const statusSelector = document.getElementById('statusSelector');
        if (statusSelector && statusSelector.value !== status) {
          statusSelector.value = status;
        }
        
      } catch (error) {
        console.error('Error updating status:', error);
      }
    }

    function updateStatusIndicator(status) {
      const indicator = document.getElementById('statusIndicator');
      if (indicator) {
        // Remove all possible status color classes
        indicator.classList.remove('bg-green-500', 'bg-yellow-500', 'bg-red-500', 'bg-gray-500', 'bg-blue-500');
        
        // Add current status class
        const statusClass = statusColors[status] || statusColors.online;
        indicator.classList.add(statusClass);
        
        console.log('Status indicator updated:', status, 'class:', statusClass);
      }
    }

    // Track game activity for activity feed
    async function trackGameActivity(gameId, action = 'played') {
      if (!currentUser || !gameId) return;
      
      try {
        const game = gamesData.find(g => String(g.id) === String(gameId));
        if (!game) return;
        
        const activityData = {
          userId: currentUser.uid,
          userName: sanitizeText(currentUser.displayName || 'Anonymous'),
          userPhoto: currentUser.photoURL || '/default-avatar.png',
          gameId: gameId,
          gameTitle: sanitizeText(game.title),
          gameImage: game.image || '/default-game.png',
          action: action,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await db.collection('activity').add(activityData);
        
        // Update user's last played game
        await db.collection('users').doc(currentUser.uid).update({
          lastPlayedGame: gameId,
          lastPlayedTime: firebase.firestore.FieldValue.serverTimestamp()
        });
        
      } catch (error) {
        console.error('Error tracking game activity:', error);
      }
    }

    // Functions for play.html to call
    window.trackGameStart = async function(gameId) {
      await updateUserStatus('ingame', gameId);
      await trackGameActivity(gameId, 'started');
    };

    window.trackGameEnd = async function() {
      await updateUserStatus('online');
    };

    // Restore user's saved status or set to online
    async function restoreUserStatus() {
      if (!currentUser) return;
      
      try {
        // Get saved status from localStorage
        const savedStatus = localStorage.getItem('carbon-user-status');
        const savedTimestamp = parseInt(localStorage.getItem('carbon-user-status-timestamp') || '0');
        const currentTime = Date.now();
        const statusAge = currentTime - savedTimestamp;
        
        // If status is less than 1 hour old, restore it. Otherwise default to online.
        const validStatuses = ['online', 'idle', 'dnd'];
        let statusToRestore = 'online';
        
        if (savedStatus && validStatuses.includes(savedStatus) && statusAge < 3600000) { // 1 hour = 3600000ms
          statusToRestore = savedStatus;
          console.log(`Restoring saved status: ${statusToRestore} (saved ${Math.round(statusAge/60000)} minutes ago)`);
        } else {
          console.log('No valid saved status found or status too old, defaulting to online');
        }
        
        await updateUserStatus(statusToRestore);
        
        // Set user offline when page unloads - use multiple reliable methods
        setupOfflineDetection();
        
        // Periodic heartbeat - maintain current status (not force online)
        setInterval(async () => {
          if (currentUser && document.visibilityState === 'visible') {
            const currentStatus = localStorage.getItem('carbon-user-status') || 'online';
            await updateUserStatus(currentStatus);
          }
        }, 30000); // Update every 30 seconds
        
      } catch (error) {
        console.error('Error restoring user status:', error);
        // Fallback to online if there's an error
        await updateUserStatus('online');
      }
    }

    // Load current user status from Firebase and update UI
    async function loadCurrentUserStatus() {
      if (!currentUser) return;
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const currentStatus = userData.status || 'online';
          
          // Update status selector to reflect current status
          const statusSelector = document.getElementById('statusSelector');
          if (statusSelector) {
            statusSelector.value = currentStatus;
          }
          
          // Update status indicator
          updateStatusIndicator(currentStatus);
          
          // Update localStorage to match Firebase
          localStorage.setItem('carbon-user-status', currentStatus);
          localStorage.setItem('carbon-user-status-timestamp', Date.now().toString());
          
          console.log('Current user status loaded from Firebase:', currentStatus);
        }
      } catch (error) {
        console.error('Error loading current user status:', error);
      }
    }

    // Robust offline detection system
    function setupOfflineDetection() {
      if (!currentUser) return;
      
      // Method 1: Page Visibility API - most reliable
      let isPageVisible = !document.hidden;
      let lastHeartbeat = Date.now();
      let offlineCheckInterval = null;
      
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // Page became hidden - start offline timer
          console.log('Page hidden, starting offline detection');
          setTimeout(() => {
            if (document.hidden) {
              setUserOfflineReliably();
            }
          }, 30000); // 30 seconds
        } else {
          // Page became visible - user is back
          console.log('Page visible, user is back');
          isPageVisible = true;
          lastHeartbeat = Date.now();
          if (currentUser) {
            const savedStatus = localStorage.getItem('carbon-user-status') || 'online';
            updateUserStatus(savedStatus);
          }
        }
      });
      
      // Method 2: Heartbeat system with server-side timeout detection
      const heartbeatInterval = setInterval(() => {
        if (!document.hidden && currentUser) {
          lastHeartbeat = Date.now();
          // Send heartbeat to keep user alive
          sendHeartbeat();
        }
      }, 15000); // Every 15 seconds
      
      // Method 3: Use sendBeacon for reliable unload detection
      const setOfflineViaBeacon = () => {
        if (currentUser) {
          const data = JSON.stringify({
            uid: currentUser.uid,
            status: 'offline',
            timestamp: Date.now()
          });
          
          // Use sendBeacon for reliable data transmission during unload
          if (navigator.sendBeacon) {
            // This would need a server endpoint, but we'll use localStorage as fallback
            localStorage.setItem('carbon-pending-offline', data);
          }
          
          // Also try immediate synchronous update
          setUserOfflineReliably();
        }
      };
      
      // Method 4: Multiple unload event listeners
      window.addEventListener('beforeunload', setOfflineViaBeacon);
      window.addEventListener('unload', setOfflineViaBeacon);
      window.addEventListener('pagehide', setOfflineViaBeacon);
      
      // Method 5: Focus/blur detection
      window.addEventListener('blur', () => {
        setTimeout(() => {
          if (document.hidden || !document.hasFocus()) {
            setUserOfflineReliably();
          }
        }, 60000); // 1 minute after losing focus
      });
      
      // Method 6: Detect browser tab/window close
      let isUnloading = false;
      window.addEventListener('beforeunload', () => {
        isUnloading = true;
      });
      
      // Method 7: Check for pending offline status on page load
      checkPendingOfflineStatus();
      
      // Cleanup function
      return () => {
        clearInterval(heartbeatInterval);
        if (offlineCheckInterval) clearInterval(offlineCheckInterval);
      };
    }
    
    // Reliable offline status setting
    function setUserOfflineReliably() {
      if (!currentUser) return;
      
      console.log('Setting user offline reliably');
      
      // Use synchronous localStorage update
      localStorage.setItem('carbon-user-status', 'offline');
      localStorage.setItem('carbon-user-status-timestamp', Date.now().toString());
      localStorage.setItem('carbon-offline-pending', 'true');
      
      // Try Firebase update with timeout
      const updatePromise = updateUserStatus('offline');
      const timeoutPromise = new Promise((resolve) => {
        setTimeout(() => resolve('timeout'), 1000);
      });
      
      Promise.race([updatePromise, timeoutPromise]).then((result) => {
        if (result === 'timeout') {
          console.log('Firebase offline update timed out, will retry on next page load');
        } else {
          localStorage.removeItem('carbon-offline-pending');
        }
      });
    }
    
    // Send heartbeat to maintain online status
    async function sendHeartbeat() {
      if (!currentUser) return;
      
      try {
        // Update lastSeen timestamp to show user is still active
        await db.collection('users').doc(currentUser.uid).update({
          lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
          heartbeat: Date.now()
        });
        
        localStorage.setItem('carbon-last-heartbeat', Date.now().toString());
      } catch (error) {
        console.error('Heartbeat failed:', error);
      }
    }
    
    // Check for pending offline status from previous session
    async function checkPendingOfflineStatus() {
      const pendingOffline = localStorage.getItem('carbon-offline-pending');
      if (pendingOffline === 'true' && currentUser) {
        console.log('Found pending offline status, applying now');
        try {
          await db.collection('users').doc(currentUser.uid).update({
            status: 'offline',
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
          });
          localStorage.removeItem('carbon-offline-pending');
        } catch (error) {
          console.error('Failed to apply pending offline status:', error);
        }
      }
    }
    
    // Server-side offline detection (to be run periodically)
    async function markInactiveUsersOffline() {
      try {
        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
        
        // This would typically be done server-side, but for client-side implementation:
        const usersSnapshot = await db.collection('users')
          .where('status', 'in', ['online', 'idle', 'dnd', 'ingame'])
          .get();
        
        const batch = db.batch();
        let updateCount = 0;
        
        usersSnapshot.forEach(doc => {
          const userData = doc.data();
          const lastSeen = userData.lastSeen?.toDate()?.getTime() || 0;
          const heartbeat = userData.heartbeat || 0;
          
          // If user hasn't been seen or sent heartbeat in 5 minutes, mark offline
          if (Math.max(lastSeen, heartbeat) < fiveMinutesAgo) {
            batch.update(doc.ref, { status: 'offline' });
            updateCount++;
          }
        });
        
        if (updateCount > 0) {
          await batch.commit();
          console.log(`Marked ${updateCount} inactive users as offline`);
        }
      } catch (error) {
        console.error('Error marking inactive users offline:', error);
      }
    }
    
    // Run inactive user cleanup periodically (only on one tab)
    if (!localStorage.getItem('carbon-cleanup-runner')) {
      localStorage.setItem('carbon-cleanup-runner', Date.now().toString());
      setInterval(markInactiveUsersOffline, 60000); // Every minute
      
      // Clear runner flag on unload
      window.addEventListener('beforeunload', () => {
        localStorage.removeItem('carbon-cleanup-runner');
      });
    }

    // Friend management functions
    async function sendFriendRequest(targetUid) {
      console.log('🔄 Attempting to send friend request to:', targetUid);
      
      if (!currentUser) {
        console.error('❌ No current user');
        showNotification('Error', 'Please sign in first', 'error');
        return;
      }
      
      if (targetUid === currentUser.uid) {
        console.error('❌ Cannot send friend request to self');
        showNotification('Error', 'Cannot send friend request to yourself', 'error');
        return;
      }
      
      try {
        // Check if request already exists
        const existingRequest = await db.collection('friendRequests')
          .where('from', '==', currentUser.uid)
          .where('to', '==', targetUid)
          .where('status', '==', 'pending')
          .get();
        
        if (!existingRequest.empty) {
          console.log('⚠️ Friend request already exists');
          showNotification('Already Sent', 'Friend request already sent', 'warning');
          return;
        }
        
        // Check if already friends
        const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = currentUserDoc.data();
        if (userData.friends && userData.friends.includes(targetUid)) {
          console.log('⚠️ Already friends');
          showNotification('Already Friends', 'You are already friends with this user', 'info');
          return;
        }
        
        const requestData = {
          from: currentUser.uid,
          to: targetUid,
          fromName: currentUser.displayName,
          fromPhoto: currentUser.photoURL,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          status: 'pending'
        };
        
        console.log('📤 Sending friend request with data:', requestData);
        await db.collection('friendRequests').add(requestData);
        console.log('✅ Friend request sent successfully');
        
        window.createEnhancedNotification('Friend Request Sent', `Request sent successfully`, 'success');
        
        // Close search modal if open
        const searchModal = document.getElementById('userSearchModal');
        if (!searchModal.classList.contains('hidden')) {
          document.getElementById('closeSearchModal').click();
        }
        
      } catch (error) {
        console.error('❌ Error sending friend request:', error);
        showNotification('Error', `Failed to send friend request: ${error.message}`, 'error');
      }
    }

    async function acceptFriendRequest(requestId, fromUid) {
      console.log('🔄 Attempting to accept friend request:', requestId, 'from:', fromUid);
      
      if (!currentUser) {
        console.error('❌ No current user');
        showNotification('Error', 'Please sign in first', 'error');
        return;
      }
      
      try {
        console.log('📝 Creating batch operation...');
        
        // Add to both users' friends lists
        const batch = db.batch();
        
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        const friendUserRef = db.collection('users').doc(fromUid);
        const requestRef = db.collection('friendRequests').doc(requestId);
        
        batch.update(currentUserRef, {
          friends: firebase.firestore.FieldValue.arrayUnion(fromUid)
        });
        
        batch.update(friendUserRef, {
          friends: firebase.firestore.FieldValue.arrayUnion(currentUser.uid)
        });
        
        batch.update(requestRef, { status: 'accepted' });
        
        console.log('💾 Committing batch operation...');
        await batch.commit();
        console.log('✅ Friend request accepted successfully');
        
        window.createEnhancedNotification('Friend Added', 'Friend request accepted!', 'success');
        await loadFriends();
        await loadFriendRequests();
      } catch (error) {
        console.error('❌ Error accepting friend request:', error);
        showNotification('Error', `Failed to accept request: ${error.message}`, 'error');
      }
    }

    async function declineFriendRequest(requestId) {
      console.log('🔄 Attempting to decline friend request:', requestId);
      
      if (!currentUser) {
        console.error('❌ No current user');
        showNotification('Error', 'Please sign in first', 'error');
        return;
      }
      
      try {
        console.log('📝 Updating request status to declined...');
        await db.collection('friendRequests').doc(requestId).update({
          status: 'declined'
        });
        console.log('✅ Friend request declined successfully');
        
        showNotification('Request Declined', 'Friend request declined', 'info');
        await loadFriendRequests();
      } catch (error) {
        console.error('❌ Error declining friend request:', error);
        showNotification('Error', `Failed to decline request: ${error.message}`, 'error');
      }
    }

    async function removeFriend(friendUid) {
      if (!currentUser || !confirm('Are you sure you want to remove this friend?')) return;
      
      try {
        const batch = db.batch();
        
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        const friendUserRef = db.collection('users').doc(friendUid);
        
        batch.update(currentUserRef, {
          friends: firebase.firestore.FieldValue.arrayRemove(friendUid)
        });
        
        batch.update(friendUserRef, {
          friends: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
        });
        
        await batch.commit();
        
        showNotification('Friend Removed', 'Friend removed successfully', 'info');
        await loadFriends();
      } catch (error) {
        console.error('Error removing friend:', error);
        showNotification('Error', 'Failed to remove friend', 'error');
      }
    }

    // Load and display friends
    async function loadFriends() {
      if (!currentUser) return;
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        const friendUids = userData.friends || [];
        
        document.getElementById('friendsCount').textContent = friendUids.length;
        
        if (friendUids.length === 0) {
          document.getElementById('friendsList').innerHTML = `
            <div class="col-span-full text-center py-8 text-rp-subtle">
              <i class='bx bx-user-plus text-4xl mb-2'></i>
              <p>No friends yet. Start by searching for friends!</p>
            </div>
          `;
          return;
        }
        
        // Load friend data
        const friendsData = await Promise.all(
          friendUids.map(async (uid) => {
            const doc = await db.collection('users').doc(uid).get();
            return { uid, ...doc.data() };
          })
        );
        
        await renderFriendsList(friendsData);
        setupFriendsStatusListeners(friendUids);
        
      } catch (error) {
        console.error('Error loading friends:', error);
      }
    }

    async function renderFriendsList(friends) {
      const friendsList = document.getElementById('friendsList');
      
      const friendsWithStreaks = await Promise.all(friends.map(async (friend) => {
        const streak = await getFriendshipStreak(friend.uid);
        const statusNote = await getFriendStatusNote(friend.uid);
        return { ...friend, streak, statusNote };
      }));
      
      friendsList.innerHTML = friendsWithStreaks.map(friend => {
        const statusColor = statusColors[friend.status] || statusColors.offline;
        const statusText = getStatusText(friend.status);
        
        const currentGameText = friend.currentGame && friend.status === 'ingame' 
          ? `Playing ${getGameTitle(friend.currentGame)}` 
          : '';
        
        // Better display name handling to prevent "Unknown User"
        let displayName = '';
        if (friend.displayName && friend.displayName.trim()) {
          displayName = friend.displayName.trim();
        } else if (friend.username && friend.username.trim()) {
          displayName = '@' + friend.username.trim();
        } else if (friend.email && friend.email.includes('@')) {
          const emailName = friend.email.split('@')[0];
          displayName = emailName.charAt(0).toUpperCase() + emailName.slice(1);
        } else {
          displayName = 'User ' + friend.uid.substring(0, 6).toUpperCase();
        }
        
        // Sanitize friend data to prevent XSS
        const safeDisplayName = sanitizeText(displayName);
        const safeUsername = sanitizeText(friend.username || '');
        const safePhotoURL = friend.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(displayName) + '&background=6e6a86&color=e0def4';
        const safeUid = sanitizeText(friend.uid || '');
        const safeCurrentGame = sanitizeText(friend.currentGame || '');
        
        // Get streak info
        const streak = friend.streak || 0;
        const streakEmoji = streak > 0 ? getStreakEmoji(streak) : '';
        const streakDisplay = streak > 0 ? `${streakEmoji} ${streak} day${streak !== 1 ? 's' : ''}` : '';
        
        return `
          <div class="bg-rp-surface border border-rp-overlay rounded-xl p-4 hover:border-rp-foam/50 transition-all group card-animated user-card">
            <div class="flex items-center gap-3 mb-3">
              <div class="relative">
                <img src="${safePhotoURL}" 
                     alt="${safeDisplayName}" 
                     class="w-12 h-12 rounded-full ring-2 ring-rp-overlay group-hover:ring-rp-foam/50 transition-all">
                <div class="${statusColor} w-4 h-4 rounded-full absolute -bottom-1 -right-1 border-2 border-rp-surface"></div>
              </div>
              <div class="flex-1 min-w-0">
                <h4 class="font-medium text-rp-text truncate">${safeDisplayName}</h4>
                <p class="text-xs text-rp-subtle">${safeUsername ? '@' + safeUsername : ''}</p>
                <p class="text-xs text-rp-foam font-medium">${statusText}</p>
                ${currentGameText ? `<p class="text-xs text-rp-gold truncate">${currentGameText}</p>` : ''}
                ${friend.lastPlayedGame ? `<p class="text-xs text-rp-subtle">Last: ${getGameTitle(friend.lastPlayedGame)}</p>` : ''}
                ${streakDisplay ? `<p class="text-xs text-rp-gold font-semibold">🔥 Streak: ${streakDisplay}</p>` : ''}
                ${friend.statusNote ? `<p class="text-xs text-rp-subtle bg-rp-overlay rounded px-2 py-1 mt-1">💭 ${sanitizeText(friend.statusNote)}</p>` : ''}
              </div>
            </div>
            
            <div class="flex gap-2">
              ${friend.status === 'ingame' && friend.currentGame ? `
                <button onclick="playGame('${safeCurrentGame}')" 
                        class="flex-1 px-3 py-2 bg-rp-gold hover:bg-rp-gold/90 text-rp-base rounded-lg text-xs transition-colors font-medium">
                  <i class='bx bx-play mr-1'></i>
                  Join Game
                </button>
              ` : ''}
              ${friend.status !== 'dnd' ? `
                              <button onclick="startChat('${safeUid}', '${safeDisplayName}')" 
                      class="flex-1 px-3 py-2 bg-rp-iris hover:bg-rp-iris/90 text-white rounded-lg text-xs transition-colors">
                <i class='bx bx-message mr-1'></i>
                Chat
              </button>
            ` : `
              <span class="flex-1 px-3 py-2 bg-rp-subtle/20 text-rp-subtle rounded-lg text-xs text-center">
                <i class='bx bx-minus-circle mr-1'></i>
                Do Not Disturb
              </span>
            `}
          </div>
          
          <!-- Follow/Social Actions Row -->
          <div class="flex gap-2 mt-2">
            ${followerSystemState.currentUserFollowing && followerSystemState.currentUserFollowing.includes(friend.uid) ? `
              <button onclick="window.unfollowUser('${safeUid}')" 
                      class="flex-1 px-3 py-2 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love border border-rp-love/30 rounded-lg text-xs transition-colors">
                <i class='bx bx-user-minus mr-1'></i>
                Unfollow
              </button>
            ` : `
              <button onclick="window.followUser('${safeUid}')" 
                      class="flex-1 px-3 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg text-xs transition-colors">
                <i class='bx bx-user-plus mr-1'></i>
                Follow
              </button>
            `}
            <button onclick="openFriendNotes('${safeUid}', '${safeDisplayName}', '${safePhotoURL}')" 
                    class="px-3 py-2 bg-rp-gold hover:bg-rp-gold/90 text-rp-base rounded-lg text-xs transition-colors"
                    title="Private Notes">
              <i class='bx bx-note'></i>
            </button>
            <button onclick="removeFriend('${safeUid}')" 
                    class="px-3 py-2 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love rounded-lg text-xs transition-colors">
              <i class='bx bx-user-minus'></i>
            </button>
            </div>
          </div>
        `;
      }).join('');
    }

    function getStatusText(status) {
      switch(status) {
        case 'online': return '🟢 Online';
        case 'idle': return '🟡 Idle';
        case 'dnd': return '🔴 Do Not Disturb';
        case 'ingame': return '🎮 In Game';
        case 'offline': 
        default: return '⚫ Offline';
      }
    }

    function playGame(gameId) {
      window.open(`/play.html?id=${gameId}`, '_blank');
    }

    function setupFriendsStatusListeners(friendUids) {
      // Clear existing listeners
      friendsStatusListeners.forEach(unsubscribe => unsubscribe());
      friendsStatusListeners.clear();
      
      // Set up real-time listeners for each friend
      friendUids.forEach(uid => {
        const unsubscribe = db.collection('users').doc(uid).onSnapshot(doc => {
          if (doc.exists) {
            const data = doc.data();
            updateFriendStatus(uid, data.status, data.currentGame);
          }
        });
        friendsStatusListeners.set(uid, unsubscribe);
      });
    }

    function updateFriendStatus(uid, status, currentGame) {
      const friendElement = document.querySelector(`[data-friend-uid="${uid}"]`);
      if (friendElement) {
        // Update status indicator and text
        const statusDot = friendElement.querySelector('.status-dot');
        const statusText = friendElement.querySelector('.status-text');
        const gameText = friendElement.querySelector('.game-text');
        
        if (statusDot && statusText) {
          const isOnline = status === 'online';
          statusDot.className = `status-dot w-3 h-3 rounded-full absolute -bottom-1 -right-1 border-2 border-rp-surface ${isOnline ? 'bg-green-500' : 'bg-gray-500'}`;
          statusText.textContent = status === 'online' ? 'Online' : status === 'ingame' ? 'In Game' : 'Offline';
          
          if (gameText) {
            gameText.textContent = status === 'ingame' && currentGame ? `Playing ${getGameTitle(currentGame)}` : '';
          }
        }
      }
      
      // Update online friends list
      updateOnlineFriendsList();
    }

    function getGameTitle(gameId) {
      if (!gamesData || !gameId) return 'Unknown Game';
      const game = gamesData.find(g => String(g.id) === String(gameId));
      return game ? game.title : 'Unknown Game';
    }

    // Chat background system
    let currentChatBackground = 'default';
    let chatParticlesAnimation = null;
    let activeChatRoomId = null;

    // Chat system
    async function startChat(friendUid, friendName) {
      activeChatUser = { uid: friendUid, name: friendName };
      
      document.getElementById('chatFriendName').textContent = friendName;
      document.getElementById('quickChatSection').classList.remove('hidden');
      document.getElementById('chatMessages').innerHTML = '';
      
      // Create chat room ID (sorted UIDs to ensure consistency)
      const chatRoomId = [currentUser.uid, friendUid].sort().join('_');
      activeChatRoomId = chatRoomId;
      
      // Load chat background
      await loadChatBackground(chatRoomId);
      
      // Set up real-time chat listener
      if (chatListener) chatListener();
      chatListener = db.collection('chats').doc(chatRoomId).collection('messages')
        .orderBy('timestamp', 'asc')
        .onSnapshot(snapshot => {
          const messages = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
          }));
          renderChatMessages(messages);
        });
      
      // Set up chat background listener
      setupChatBackgroundListener(chatRoomId);
      
      // Update streak when chat is opened
      await updateFriendshipStreak(friendUid);
    }

    async function loadChatBackground(chatRoomId) {
      try {
        const chatSettingsDoc = await db.collection('chatSettings').doc(chatRoomId).get();
        if (chatSettingsDoc.exists) {
          const settings = chatSettingsDoc.data();
          currentChatBackground = settings.background || 'default';
        } else {
          currentChatBackground = 'default';
        }
        applyChatBackground(currentChatBackground);
        updateChatBackgroundUI();
      } catch (error) {
        console.error('Error loading chat background:', error);
        currentChatBackground = 'default';
        applyChatBackground('default');
      }
    }

    function setupChatBackgroundListener(chatRoomId) {
      // Listen for background changes in real-time
      const unsubscribe = db.collection('chatSettings').doc(chatRoomId)
        .onSnapshot(doc => {
          if (doc.exists) {
            const settings = doc.data();
            const newBackground = settings.background || 'default';
            if (newBackground !== currentChatBackground) {
              currentChatBackground = newBackground;
              applyChatBackground(newBackground);
              updateChatBackgroundUI();
            }
          }
        });
      
      // Store unsubscribe function to clean up later
      if (window.chatBackgroundListener) {
        window.chatBackgroundListener();
      }
      window.chatBackgroundListener = unsubscribe;
    }

    async function setChatBackground(background) {
      console.log('🎨 Setting chat background to:', background);
      console.log('🔗 Active chat room ID:', activeChatRoomId);
      console.log('👤 Current user:', currentUser?.uid);
      
      // Validation
      if (!background) {
        console.error('❌ No background specified');
        showNotification('Error', 'No background type specified', 'error');
        return;
      }
      
      if (!activeChatRoomId) {
        console.error('❌ No active chat room');
        showNotification('Error', 'No active chat session', 'error');
        return;
      }
      
      if (!currentUser || !currentUser.uid) {
        console.error('❌ User not authenticated');
        showNotification('Error', 'Please log in to change chat background', 'error');
        return;
      }
      
      if (!db) {
        console.error('❌ Database not initialized');
        showNotification('Error', 'Database connection not available', 'error');
        return;
      }
      
      const validBackgrounds = ['default', 'gradient', 'solid', 'particles'];
      if (!validBackgrounds.includes(background)) {
        console.error('❌ Invalid background type:', background);
        showNotification('Error', 'Invalid background type', 'error');
        return;
      }
      
      try {
        console.log('💾 Saving to Firebase...');
        
        const chatSettingsData = {
          background: background,
          updatedBy: currentUser.uid,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        console.log('📝 Chat settings data:', chatSettingsData);
        
        await db.collection('chatSettings').doc(activeChatRoomId).set(chatSettingsData, { merge: true });
        
        console.log('✅ Successfully saved to Firebase');
        
        // Update local state
        currentChatBackground = background;
        
        // Apply the background
        try {
          applyChatBackground(background);
          console.log('✅ Background applied successfully');
        } catch (applyError) {
          console.error('❌ Error applying background:', applyError);
          // Continue anyway, the background was saved
        }
        
        // Update UI
        try {
          updateChatBackgroundUI();
          console.log('✅ UI updated successfully');
        } catch (uiError) {
          console.error('❌ Error updating UI:', uiError);
          // Continue anyway
        }
        
        showNotification('Background Changed', `Chat background set to ${background}`, 'success');
        
      } catch (error) {
        console.error('❌ Error setting chat background:', error);
        console.error('❌ Error details:', {
          message: error.message,
          code: error.code,
          stack: error.stack
        });
        
        let errorMessage = 'Failed to change chat background';
        if (error.message) {
          errorMessage += ': ' + error.message;
        }
        showNotification('Error', errorMessage, 'error');
      }
    }

    function applyChatBackground(background) {
      console.log('🎨 Applying chat background:', background);
      
      const chatMessages = document.getElementById('chatMessages');
      const chatParticlesCanvas = document.getElementById('chatParticlesCanvas');
      const chatContainer = document.getElementById('chatMessagesContainer');
      
      console.log('📍 Chat elements found:', {
        chatMessages: !!chatMessages,
        chatParticlesCanvas: !!chatParticlesCanvas,
        chatContainer: !!chatContainer
      });
      
      if (!chatMessages) {
        console.warn('⚠️ Chat messages element not found');
        return;
      }
      
      if (!chatParticlesCanvas) {
        console.warn('⚠️ Chat particles canvas not found');
        return;
      }
      
      if (!chatContainer) {
        console.warn('⚠️ Chat container not found');
        return;
      }
      
      try {
        // Stop any existing particles animation
        if (chatParticlesAnimation && typeof chatParticlesAnimation.stop === 'function') {
          console.log('🛑 Stopping existing particles animation');
          chatParticlesAnimation.stop();
          chatParticlesAnimation = null;
        }
        
        // Hide particles canvas by default
        chatParticlesCanvas.classList.add('hidden');
        
        // Reset chat messages background
        chatMessages.style.background = '';
        chatMessages.classList.remove('bg-transparent');
        chatContainer.style.background = '';
        
        console.log('🔄 Applying background type:', background);
        
        switch (background) {
          case 'gradient':
            chatMessages.style.background = 'linear-gradient(135deg, rgba(156, 207, 216, 0.1) 0%, rgba(196, 167, 231, 0.1) 100%)';
            chatMessages.classList.add('bg-transparent');
            chatContainer.style.background = 'linear-gradient(135deg, #9ccfd8 0%, #c4a7e7 100%)';
            console.log('✅ Gradient background applied');
            break;
            
          case 'solid':
            chatMessages.style.background = 'rgba(49, 116, 143, 0.2)';
            chatMessages.classList.add('bg-transparent');
            chatContainer.style.background = '#31748f'; // Use hex instead of CSS variable for reliability
            console.log('✅ Solid background applied');
            break;
            
          case 'particles':
            chatMessages.style.background = 'rgba(25, 23, 36, 0.3)';
            chatMessages.classList.add('bg-transparent');
            chatContainer.style.background = '#191724'; // Use hex instead of CSS variable
            chatParticlesCanvas.classList.remove('hidden');
            
            try {
              initChatParticles();
              console.log('✅ Particles background applied');
            } catch (particlesError) {
              console.error('❌ Error initializing particles:', particlesError);
              // Fallback to solid background
              chatContainer.style.background = '#191724';
              chatParticlesCanvas.classList.add('hidden');
            }
            break;
            
          case 'default':
          default:
            chatMessages.classList.remove('bg-transparent');
            chatMessages.style.background = '';
            chatContainer.style.background = '';
            console.log('✅ Default background applied');
            break;
        }
        
        console.log('✅ Chat background applied successfully');
        
      } catch (error) {
        console.error('❌ Error in applyChatBackground:', error);
        // Fallback to default
        try {
          chatMessages.classList.remove('bg-transparent');
          chatMessages.style.background = '';
          chatContainer.style.background = '';
          chatParticlesCanvas.classList.add('hidden');
          console.log('🔄 Fallback to default background');
        } catch (fallbackError) {
          console.error('❌ Even fallback failed:', fallbackError);
        }
      }
    }

    function updateChatBackgroundUI() {
      console.log('🔄 Updating chat background UI for:', currentChatBackground);
      
      try {
        // Update active state of background options
        const backgroundOptions = document.querySelectorAll('.chat-bg-option');
        console.log('📍 Found background options:', backgroundOptions.length);
        
        backgroundOptions.forEach(option => {
          if (option && option.classList) {
            option.classList.remove('border-rp-foam');
            option.classList.add('border-transparent');
          }
        });
        
        const activeOption = document.querySelector(`[data-bg="${currentChatBackground}"]`);
        console.log('📍 Active option found:', !!activeOption);
        
        if (activeOption && activeOption.classList) {
          activeOption.classList.remove('border-transparent');
          activeOption.classList.add('border-rp-foam');
          console.log('✅ Active option updated');
        } else {
          console.warn('⚠️ Active option not found for background:', currentChatBackground);
        }
        
        console.log('✅ Chat background UI updated successfully');
        
      } catch (error) {
        console.error('❌ Error updating chat background UI:', error);
      }
    }

    function initChatParticles() {
      console.log('✨ Initializing chat particles');
      
      const canvas = document.getElementById('chatParticlesCanvas');
      if (!canvas) {
        console.error('❌ Chat particles canvas not found');
        return;
      }
      
      const container = document.getElementById('chatMessagesContainer');
      if (!container) {
        console.error('❌ Chat messages container not found');
        return;
      }
      
      try {
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('❌ Could not get 2D context');
          return;
        }
        
        // Set canvas size to match container
        const rect = container.getBoundingClientRect();
        canvas.width = container.offsetWidth || 300;
        canvas.height = container.offsetHeight || 200;
        
        console.log('📐 Canvas size:', canvas.width + 'x' + canvas.height);
        
        const particlesArray = [];
        const particleCount = 15; // Fewer particles for chat area
        
        class ChatParticle {
          constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.vx = (Math.random() - 0.5) * 1;
            this.vy = (Math.random() - 0.5) * 1;
            this.radius = Math.random() * 2 + 1;
            this.opacity = Math.random() * 0.3 + 0.1;
            this.color = this.getRandomColor();
          }
          
          getRandomColor() {
            const colors = [
              'rgba(156, 207, 216, ', // foam
              'rgba(196, 167, 231, ', // iris
              'rgba(246, 193, 119, ', // gold
              'rgba(235, 188, 186, '  // love
            ];
            return colors[Math.floor(Math.random() * colors.length)];
          }
          
          update() {
            this.x += this.vx;
            this.y += this.vy;
            
            if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
            if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
          }
          
          draw() {
            try {
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
              ctx.fillStyle = this.color + this.opacity + ')';
              ctx.fill();
            } catch (drawError) {
              console.warn('⚠️ Error drawing particle:', drawError);
            }
          }
        }
        
        function createChatParticles() {
          particlesArray.length = 0;
          for (let i = 0; i < particleCount; i++) {
            particlesArray.push(new ChatParticle());
          }
          console.log('🎨 Created', particleCount, 'particles');
        }
        
        function animateChatParticles() {
          try {
            if (!canvas || canvas.classList.contains('hidden') || currentChatBackground !== 'particles') {
              console.log('🛑 Stopping particles animation - conditions not met');
              return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particlesArray.forEach(particle => {
              particle.update();
              particle.draw();
            });
            
            chatParticlesAnimation = requestAnimationFrame(animateChatParticles);
            
          } catch (animError) {
            console.error('❌ Error in particles animation:', animError);
            // Stop animation on error
            if (chatParticlesAnimation && typeof chatParticlesAnimation === 'number') {
              cancelAnimationFrame(chatParticlesAnimation);
            }
            chatParticlesAnimation = null;
          }
        }
        
        createChatParticles();
        animateChatParticles();
        
        // Store animation reference for cleanup with better error handling
        const animationId = chatParticlesAnimation;
        chatParticlesAnimation = {
          stop: () => {
            try {
              if (animationId && typeof animationId === 'number') {
                cancelAnimationFrame(animationId);
                console.log('🛑 Particles animation stopped');
              }
              if (chatParticlesAnimation && typeof chatParticlesAnimation === 'number') {
                cancelAnimationFrame(chatParticlesAnimation);
              }
              chatParticlesAnimation = null;
            } catch (stopError) {
              console.error('❌ Error stopping particles:', stopError);
              chatParticlesAnimation = null;
            }
          }
        };
        
        console.log('✅ Chat particles initialized successfully');
        
      } catch (error) {
        console.error('❌ Error initializing chat particles:', error);
        chatParticlesAnimation = null;
      }
    }

    function renderChatMessages(messages) {
      const chatContainer = document.getElementById('chatMessages');
      
      chatContainer.innerHTML = messages.map(message => {
        const isOwn = message.sender === currentUser.uid;
        const messageTime = message.timestamp?.toDate()?.toLocaleTimeString() || '';
        
        // Sanitize message content to prevent XSS
        const safeMessageText = sanitizeHTMLWithBasicTags(message.text || '');
        
        return `
          <div class="flex ${isOwn ? 'justify-end' : 'justify-start'} mb-2">
            <div class="max-w-xs ${isOwn ? 'bg-rp-foam text-rp-base' : 'bg-rp-highlight-med text-rp-text'} 
                        rounded-lg px-3 py-2 text-sm">
              <p>${safeMessageText}</p>
              <p class="text-xs opacity-70 mt-1">${messageTime}</p>
            </div>
          </div>
        `;
      }).join('');
      
      // Scroll to bottom
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      
      if (!text || !activeChatUser) return;
      
      // Sanitize message text to prevent XSS
      const safeText = sanitizeText(text);
      
      // Validate message length
      if (safeText.length > 500) {
        showNotification('Message Too Long', 'Messages must be 500 characters or less', 'error');
        return;
      }
      
      const chatRoomId = [currentUser.uid, activeChatUser.uid].sort().join('_');
      
      try {
        await db.collection('chats').doc(chatRoomId).collection('messages').add({
          text: safeText,
          sender: currentUser.uid,
          senderName: sanitizeText(currentUser.displayName),
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Update friendship streak when message is sent
        await updateFriendshipStreak(activeChatUser.uid);
        
        input.value = '';
      } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Error', 'Failed to send message', 'error');
      }
    }

    // ===== FRIENDSHIP STREAK SYSTEM =====
    
    async function updateFriendshipStreak(friendUid) {
      if (!currentUser || !friendUid) return;
      
      try {
        const streakId = [currentUser.uid, friendUid].sort().join('_');
        const streakRef = db.collection('friendStreaks').doc(streakId);
        const today = new Date().toDateString();
        
        const streakDoc = await streakRef.get();
        
        if (streakDoc.exists) {
          const streakData = streakDoc.data();
          const lastActivity = streakData.lastActivity;
          const currentStreak = streakData.streak || 0;
          
          if (lastActivity === today) {
            // Already updated today, don't change streak
            return;
          }
          
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          const yesterdayStr = yesterday.toDateString();
          
          let newStreak;
          if (lastActivity === yesterdayStr) {
            // Consecutive day, increment streak
            newStreak = currentStreak + 1;
          } else {
            // Streak broken, start new streak
            newStreak = 1;
          }
          
          await streakRef.update({
            streak: newStreak,
            lastActivity: today,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        } else {
          // Create new streak
          await streakRef.set({
            users: [currentUser.uid, friendUid].sort(),
            streak: 1,
            lastActivity: today,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        }
        
        // Reload streaks to update UI
        await loadFriendshipStreaks();
        
      } catch (error) {
        console.error('Error updating friendship streak:', error);
      }
    }

    async function loadFriendshipStreaks() {
      if (!currentUser) return;
      
      try {
        const streaksQuery = await db.collection('friendStreaks')
          .where('users', 'array-contains', currentUser.uid)
          .orderBy('streak', 'desc')
          .limit(10)
          .get();
        
        const streaksList = document.getElementById('friendStreaksList');
        const noStreaks = document.getElementById('noStreaks');
        
        if (streaksQuery.empty) {
          streaksList.innerHTML = '';
          noStreaks.classList.remove('hidden');
          return;
        }
        
        noStreaks.classList.add('hidden');
        
        const streaksHtml = await Promise.all(streaksQuery.docs.map(async (doc) => {
          const streakData = doc.data();
          const friendUid = streakData.users.find(uid => uid !== currentUser.uid);
          
          if (!friendUid) return '';
          
          // Get friend's info
          const friendDoc = await db.collection('users').doc(friendUid).get();
          const friendData = friendDoc.exists ? friendDoc.data() : null;
          
          if (!friendData) return '';
          
          const friendName = sanitizeText(friendData.displayName || 'Unknown User');
          const friendPhoto = friendData.photoURL || '/default-avatar.png';
          const streak = streakData.streak || 0;
          
          // Check if streak is still active (last activity was today or yesterday)
          const today = new Date().toDateString();
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          const yesterdayStr = yesterday.toDateString();
          
          const isActive = streakData.lastActivity === today || streakData.lastActivity === yesterdayStr;
          const streakEmoji = getStreakEmoji(streak);
          
          return `
            <div class="flex items-center justify-between p-3 bg-rp-overlay rounded-lg ${isActive ? 'border border-rp-gold/30' : 'opacity-60'}">
              <div class="flex items-center gap-3">
                <img src="${sanitizeText(friendPhoto)}" class="w-10 h-10 rounded-full" alt="${friendName}">
                <div>
                  <p class="font-medium text-rp-text">${friendName}</p>
                  <p class="text-sm text-rp-subtle">${isActive ? 'Active streak' : 'Streak ended'}</p>
                </div>
              </div>
              <div class="flex items-center gap-2">
                <span class="text-lg">${streakEmoji}</span>
                <span class="text-xl font-bold text-rp-gold">${streak}</span>
                <span class="text-sm text-rp-subtle">day${streak !== 1 ? 's' : ''}</span>
              </div>
            </div>
          `;
        }));
        
        streaksList.innerHTML = streaksHtml.filter(html => html).join('');
        
      } catch (error) {
        console.error('Error loading friendship streaks:', error);
      }
    }

    function getStreakEmoji(streak) {
      if (streak >= 365) return '👑'; // Year streak
      if (streak >= 100) return '💎'; // 100+ days
      if (streak >= 30) return '🚀';  // Month streak
      if (streak >= 14) return '⭐';  // Two weeks
      if (streak >= 7) return '🔥';   // Week streak
      if (streak >= 3) return '✨';   // 3+ days
      return '🌟'; // New streak
    }

    async function getFriendshipStreak(friendUid) {
      if (!currentUser || !friendUid) return 0;
      
      try {
        const streakId = [currentUser.uid, friendUid].sort().join('_');
        const streakDoc = await db.collection('friendStreaks').doc(streakId).get();
        
        if (streakDoc.exists) {
          const streakData = streakDoc.data();
          const today = new Date().toDateString();
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          const yesterdayStr = yesterday.toDateString();
          
          // Check if streak is still active
          const isActive = streakData.lastActivity === today || streakData.lastActivity === yesterdayStr;
          return isActive ? (streakData.streak || 0) : 0;
        }
        
        return 0;
      } catch (error) {
        console.error('Error getting friendship streak:', error);
        return 0;
      }
    }

    // Get friend's status note if they have one
    async function getFriendStatusNote(friendUid) {
      try {
        const statusNoteDoc = await db.collection('statusNotes').doc(friendUid).get();
        if (statusNoteDoc.exists) {
          const noteData = statusNoteDoc.data();
          const now = new Date();
          
          // Handle different date formats safely
          let expiry;
          if (noteData.expiresAt && typeof noteData.expiresAt.toDate === 'function') {
            // Firestore timestamp
            expiry = noteData.expiresAt.toDate();
          } else if (noteData.expiresAt instanceof Date) {
            // Regular Date object
            expiry = noteData.expiresAt;
          } else if (noteData.expiresAt && noteData.expiresAt.seconds) {
            // Firestore timestamp in seconds format
            expiry = new Date(noteData.expiresAt.seconds * 1000);
          } else {
            // Invalid date format, treat as expired
            return '';
          }
          
          if (expiry > now) {
            return noteData.text || '';
          }
        }
        return '';
      } catch (error) {
        console.error('Error loading friend status note:', error);
        return '';
      }
    }

    // ===== GAME STATISTICS SYSTEM =====
    
    // Format duration in milliseconds to readable string
    function formatDuration(ms) {
      const hours = Math.floor(ms / 3600000);
      const minutes = Math.floor((ms % 3600000) / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      } else if (minutes > 0) {
        return `${minutes}m`;
      } else {
        return `${seconds}s`;
      }
    }

    async function loadGameStatistics() {
      if (!currentUser) return;
      
      try {
        console.log('📊 Loading game statistics for user:', currentUser.uid);
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.exists ? userDoc.data() : {};
        const gameStats = userData.gameStats || {};
        
        console.log('📊 Raw gameStats data:', gameStats);
        
        // Calculate overall statistics
        let totalGamesPlayed = 0;
        let totalPlayTime = 0;
        let totalSessions = 0;
        const gamesList = [];
        
        Object.entries(gameStats).forEach(([gameId, stats]) => {
          console.log(`📊 Processing game ${gameId}:`, stats);
          if (stats && (stats.sessionsPlayed > 0 || stats.totalPlayTime > 0)) {
            totalGamesPlayed++; // This counts unique games played
            totalPlayTime += stats.totalPlayTime || 0;
            totalSessions += stats.sessionsPlayed || 0;
            
            // Find game info
            const game = gamesData.find(g => String(g.id) === String(gameId));
            if (game) {
              gamesList.push({
                ...game,
                stats: stats
              });
              console.log(`📊 Added game to list: ${game.title}`);
            } else {
              console.warn(`📊 Game not found in gamesData: ${gameId}`);
            }
          }
        });
        
        console.log(`📊 Final stats - Games: ${totalGamesPlayed}, Time: ${totalPlayTime}ms, Sessions: ${totalSessions}`);
        
        // Update UI
        document.getElementById('totalGamesPlayed').textContent = totalGamesPlayed;
        document.getElementById('totalPlayTime').textContent = formatDuration(totalPlayTime);
        document.getElementById('averageSessionTime').textContent = 
          totalSessions > 0 ? formatDuration(Math.round(totalPlayTime / totalSessions)) : '0m';
        
        // Show top games by play time
        renderTopGames(gamesList);
        
      } catch (error) {
        console.error('❌ Error loading game statistics:', error);
      }
    }

    function renderTopGames(gamesList) {
      const topGamesList = document.getElementById('topGamesList');
      const noGameStats = document.getElementById('noGameStats');
      
      if (gamesList.length === 0) {
        topGamesList.innerHTML = '';
        noGameStats.classList.remove('hidden');
        return;
      }
      
      noGameStats.classList.add('hidden');
      
      // Sort by total play time and take top 5
      const topGames = gamesList
        .sort((a, b) => (b.stats.totalPlayTime || 0) - (a.stats.totalPlayTime || 0))
        .slice(0, 5);
      
      topGamesList.innerHTML = topGames.map((game, index) => {
        const stats = game.stats;
        const playTime = formatDuration(stats.totalPlayTime || 0);
        const sessions = stats.sessionsPlayed || 0;
        const avgSession = formatDuration(stats.averageSessionTime || 0);
        
        // Medal emoji for top 3
        const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
        
        return `
          <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg">
            <div class="text-lg font-bold text-rp-gold w-8">${medal}</div>
            <img src="${game.image || '/default-game.png'}" class="w-12 h-12 rounded-lg object-cover" alt="${game.title}">
            <div class="flex-1 min-w-0">
              <h4 class="font-medium text-rp-text truncate">${sanitizeText(game.title)}</h4>
              <div class="flex gap-4 text-xs text-rp-subtle">
                <span>⏱️ ${playTime}</span>
                <span>🎮 ${sessions} sessions</span>
                <span>📊 ${avgSession} avg</span>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // ===== FRIEND LEADERBOARD SYSTEM =====
    
    async function loadFriendLeaderboard() {
      if (!currentUser) return;
      
      try {
        // Get current user's friends list
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        const friendUids = userData.friends || [];
        
        if (friendUids.length === 0) {
          document.getElementById('noLeaderboardData').classList.remove('hidden');
          document.getElementById('friendLeaderboardList').innerHTML = '';
          return;
        }
        
        // Load friends' data in batches (Firestore 'in' limit is 10)
        const friendsData = [];
        for (let i = 0; i < friendUids.length; i += 10) {
          const batch = friendUids.slice(i, i + 10);
          const friendsQuery = await db.collection('users')
            .where(firebase.firestore.FieldPath.documentId(), 'in', batch)
            .get();
          
          friendsQuery.forEach(doc => {
            friendsData.push({ uid: doc.id, ...doc.data() });
          });
        }
        
        await renderFriendLeaderboard(friendsData);
        
      } catch (error) {
        console.error('Error loading friend leaderboard:', error);
      }
    }

    async function renderFriendLeaderboard(friendsData) {
      const leaderboardList = document.getElementById('friendLeaderboardList');
      const noLeaderboardData = document.getElementById('noLeaderboardData');
      const leaderboardType = document.getElementById('leaderboardType').value;
      
      // Process friends' game statistics
      const leaderboardData = friendsData.map(friend => {
        const gameStats = friend.gameStats || {};
        let totalGamesPlayed = 0;
        let totalPlayTime = 0;
        let totalSessions = 0;
        
        Object.values(gameStats).forEach(stats => {
          if (stats && stats.sessionsPlayed > 0) {
            totalGamesPlayed++;
            totalPlayTime += stats.totalPlayTime || 0;
            totalSessions += stats.sessionsPlayed || 0;
          }
        });
        
        return {
          ...friend,
          totalGamesPlayed,
          totalPlayTime,
          averageSessionTime: totalSessions > 0 ? Math.round(totalPlayTime / totalSessions) : 0
        };
      });
      
      // Sort based on selected leaderboard type
      let sortedData;
      switch (leaderboardType) {
        case 'totalPlayTime':
          sortedData = leaderboardData.sort((a, b) => b.totalPlayTime - a.totalPlayTime);
          break;
        case 'averageSession':
          sortedData = leaderboardData.sort((a, b) => b.averageSessionTime - a.averageSessionTime);
          break;
        case 'gamesPlayed':
        default:
          sortedData = leaderboardData.sort((a, b) => b.totalGamesPlayed - a.totalGamesPlayed);
          break;
      }
      
      // Filter out friends with no gaming data
      const filteredData = sortedData.filter(friend => {
        return friend.totalGamesPlayed > 0 || friend.totalPlayTime > 0;
      });
      
      if (filteredData.length === 0) {
        leaderboardList.innerHTML = '';
        noLeaderboardData.classList.remove('hidden');
        return;
      }
      
      noLeaderboardData.classList.add('hidden');
      
      leaderboardList.innerHTML = filteredData.slice(0, 10).map((friend, index) => {
        const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
        
        let statValue;
        let statLabel;
        switch (leaderboardType) {
          case 'totalPlayTime':
            statValue = formatDuration(friend.totalPlayTime);
            statLabel = 'Total Time';
            break;
          case 'averageSession':
            statValue = formatDuration(friend.averageSessionTime);
            statLabel = 'Avg Session';
            break;
          case 'gamesPlayed':
          default:
            statValue = friend.totalGamesPlayed;
            statLabel = 'Games Played';
            break;
        }
        
        return `
          <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg">
            <div class="text-lg font-bold text-rp-gold w-8">${medal}</div>
            <img src="${friend.photoURL || '/default-avatar.png'}" class="w-10 h-10 rounded-full" alt="${friend.displayName}">
            <div class="flex-1 min-w-0">
              <h4 class="font-medium text-rp-text truncate">${sanitizeText(friend.displayName || 'Unknown User')}</h4>
              <div class="flex gap-4 text-xs text-rp-subtle">
                <span>🎮 ${friend.totalGamesPlayed} games</span>
                <span>⏱️ ${formatDuration(friend.totalPlayTime)}</span>
              </div>
            </div>
            <div class="text-right">
              <div class="text-lg font-bold text-rp-foam">${statValue}</div>
              <div class="text-xs text-rp-subtle">${statLabel}</div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Initialize game statistics events
    function initializeGameStatsEvents() {
      const leaderboardTypeSelect = document.getElementById('leaderboardType');
      if (leaderboardTypeSelect) {
        leaderboardTypeSelect.addEventListener('change', async () => {
          await loadFriendLeaderboard();
        });
      }
      
      const refreshStatsBtn = document.getElementById('refreshStatsBtn');
      if (refreshStatsBtn) {
        refreshStatsBtn.addEventListener('click', async () => {
          console.log('🔄 Manual refresh triggered');
          await loadGameStatistics();
          await loadFriendLeaderboard();
          showNotification('Statistics Updated', 'Your gaming statistics have been refreshed!', 'info');
        });
      }
    }

    // Debug function for checking game statistics (call from console)
    window.debugGameStats = async function() {
      if (!currentUser) {
        console.log('❌ No user logged in');
        return;
      }
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.exists ? userDoc.data() : {};
        console.log('🔍 Full user data:', userData);
        console.log('🔍 Game stats:', userData.gameStats);
        
        if (userData.gameStats) {
          Object.entries(userData.gameStats).forEach(([gameId, stats]) => {
            console.log(`🎮 Game ${gameId}:`, stats);
          });
        } else {
          console.log('⚠️ No gameStats found - have you played any games yet?');
        }
      } catch (error) {
        console.error('❌ Error fetching debug data:', error);
      }
    };

    // User search functionality
    async function searchUsers(query) {
      if (!query.trim()) return [];
      
      try {
        const searchResults = [];
        
        // Search by username
        const usernameQuery = await db.collection('users')
          .where('username', '>=', query.toLowerCase())
          .where('username', '<=', query.toLowerCase() + '\uf8ff')
          .limit(10)
          .get();
        
        usernameQuery.forEach(doc => {
          const data = doc.data();
          if (doc.id !== currentUser.uid) {
            searchResults.push({ uid: doc.id, ...data });
          }
        });
        
        // Search by UID if it looks like a UID
        if (query.length > 10) {
          try {
            const uidDoc = await db.collection('users').doc(query).get();
            if (uidDoc.exists && query !== currentUser.uid) {
              const data = uidDoc.data();
              const alreadyIncluded = searchResults.some(user => user.uid === query);
              if (!alreadyIncluded) {
                searchResults.push({ uid: query, ...data });
              }
            }
          } catch (error) {
            // Ignore UID search errors
          }
        }
        
        return searchResults;
      } catch (error) {
        console.error('Error searching users:', error);
        return [];
      }
    }

    function renderUserSearchResults(users) {
      console.log('🔍 Rendering search results:', users);
      const resultsContainer = document.getElementById('searchResults');
      
      if (users.length === 0) {
        document.getElementById('noSearchResults').classList.remove('hidden');
        resultsContainer.innerHTML = '';
        return;
      }
      
      document.getElementById('noSearchResults').classList.add('hidden');
      
      resultsContainer.innerHTML = users.map(user => {
        // Check if already friends
        let isAlreadyFriend = false;
        let isAlreadyFollowing = false;
        if (currentUser) {
          // We need to check the current user's friends list
          const currentUserData = currentUser.userData || {};
          isAlreadyFriend = currentUserData.friends && currentUserData.friends.includes(user.uid);
          
          // Check if already following
          isAlreadyFollowing = followerSystemState.currentUserFollowing && 
                             followerSystemState.currentUserFollowing.includes(user.uid);
        }
        
        console.log('👤 Rendering user:', user.displayName, 'Already friend:', isAlreadyFriend, 'Already following:', isAlreadyFollowing);
        
        // Better display name handling to prevent "Unknown User"
        let displayName = '';
        if (user.displayName && user.displayName.trim()) {
          displayName = user.displayName.trim();
        } else if (user.username && user.username.trim()) {
          displayName = '@' + user.username.trim();
        } else if (user.email && user.email.includes('@')) {
          const emailName = user.email.split('@')[0];
          displayName = emailName.charAt(0).toUpperCase() + emailName.slice(1);
        } else {
          displayName = 'User ' + user.uid.substring(0, 6).toUpperCase();
        }
        
        // Sanitize user data to prevent XSS
        const safeDisplayName = sanitizeText(displayName);
        const safeUsername = sanitizeText(user.username || '');
        const safeBio = sanitizeText(user.bio || '');
        const safePhotoURL = user.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(displayName) + '&background=6e6a86&color=e0def4';
        const safeUid = sanitizeText(user.uid || '');
        
        return `
          <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg" data-user-id="${safeUid}">
            <img src="${safePhotoURL}" 
                 alt="${safeDisplayName}" 
                 class="w-10 h-10 rounded-full">
            <div class="flex-1 min-w-0">
              <h4 class="font-medium text-rp-text truncate">${safeDisplayName}</h4>
              <p class="text-xs text-rp-subtle">${safeUsername ? '@' + safeUsername : safeUid.substring(0, 8) + '...'}</p>
              ${safeBio ? `<p class="text-xs text-rp-muted truncate">${safeBio}</p>` : ''}
            </div>
            <div class="flex gap-2">
              ${isAlreadyFriend ? `
                <span class="px-3 py-1 bg-rp-foam/20 text-rp-foam rounded text-xs">Friends</span>
              ` : `
                <button onclick="window.sendFriendRequest('${safeUid}')" 
                        class="px-3 py-1 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded text-xs transition-colors"
                        data-uid="${safeUid}">
                  Add Friend
                </button>
              `}
              ${isAlreadyFollowing ? `
                <button onclick="window.unfollowUser('${safeUid}')" 
                        class="px-3 py-1 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love border border-rp-love/30 rounded text-xs transition-colors"
                        data-uid="${safeUid}">
                  Unfollow
                </button>
              ` : `
                <button onclick="window.followUser('${safeUid}')" 
                        class="px-3 py-1 bg-rp-iris hover:bg-rp-iris/90 text-white rounded text-xs transition-colors"
                        data-uid="${safeUid}">
                  Follow
                </button>
              `}
              <button onclick="window.viewUserProfile('${safeUid}')" 
                      class="px-3 py-1 bg-rp-gold/20 text-rp-gold rounded text-xs hover:bg-rp-gold/30 transition-colors">
                View
              </button>
            </div>
          </div>
        `;
      }).join('');
      
      console.log('✅ Search results rendered');
    }

    // Friend requests handling
    async function loadFriendRequests() {
      console.log('🔄 Loading friend requests...');
      
      if (!currentUser) {
        console.error('❌ No current user when loading friend requests');
        return;
      }
      
      try {
        console.log('📥 Loading incoming requests...');
        // Load incoming requests
        const incomingSnapshot = await db.collection('friendRequests')
          .where('to', '==', currentUser.uid)
          .where('status', '==', 'pending')
          .get(); // Remove orderBy for now to avoid index issues
        
        console.log(`📨 Found ${incomingSnapshot.docs.length} incoming requests`);
        
        const incomingRequests = [];
        for (const doc of incomingSnapshot.docs) {
          const data = doc.data();
          console.log('📨 Processing incoming request:', doc.id, data);
          
          try {
            const fromUserDoc = await db.collection('users').doc(data.from).get();
            const fromUserData = fromUserDoc.exists ? fromUserDoc.data() : null;
            
            if (fromUserData) {
              incomingRequests.push({
                id: doc.id,
                ...data,
                fromUserData
              });
            } else {
              console.warn('⚠️ From user not found:', data.from);
            }
          } catch (userError) {
            console.error('❌ Error loading from user:', data.from, userError);
          }
        }
        
        console.log('📤 Loading outgoing requests...');
        // Load outgoing requests
        const outgoingSnapshot = await db.collection('friendRequests')
          .where('from', '==', currentUser.uid)
          .where('status', '==', 'pending')
          .get(); // Remove orderBy for now to avoid index issues
        
        console.log(`📤 Found ${outgoingSnapshot.docs.length} outgoing requests`);
        
        const outgoingRequests = [];
        for (const doc of outgoingSnapshot.docs) {
          const data = doc.data();
          console.log('📤 Processing outgoing request:', doc.id, data);
          
          try {
            const toUserDoc = await db.collection('users').doc(data.to).get();
            const toUserData = toUserDoc.exists ? toUserDoc.data() : null;
            
            if (toUserData) {
              outgoingRequests.push({
                id: doc.id,
                ...data,
                toUserData
              });
            } else {
              console.warn('⚠️ To user not found:', data.to);
            }
          } catch (userError) {
            console.error('❌ Error loading to user:', data.to, userError);
          }
        }
        
        console.log(`✅ Loaded ${incomingRequests.length} incoming and ${outgoingRequests.length} outgoing requests`);
        renderFriendRequests(incomingRequests, outgoingRequests);
        
        // Update badge
        const badge = document.getElementById('requestsBadge');
        if (incomingRequests.length > 0) {
          badge.textContent = incomingRequests.length;
          badge.classList.remove('hidden');
        } else {
          badge.classList.add('hidden');
        }
        
      } catch (error) {
        console.error('❌ Error loading friend requests:', error);
        showNotification('Error', `Failed to load friend requests: ${error.message}`, 'error');
      }
    }

    function renderFriendRequests(incoming, outgoing) {
      // Render incoming requests
      const incomingContainer = document.getElementById('incomingRequests');
      const noIncoming = document.getElementById('noIncomingRequests');
      
      if (incoming.length === 0) {
        incomingContainer.innerHTML = '';
        noIncoming.classList.remove('hidden');
      } else {
        noIncoming.classList.add('hidden');
        incomingContainer.innerHTML = incoming.map(request => {
          // Sanitize incoming request data to prevent XSS
          const safeDisplayName = sanitizeText(request.fromUserData.displayName || 'Unknown User');
          const safeUsername = sanitizeText(request.fromUserData.username || '');
          const safePhotoURL = request.fromUserData.photoURL || '/default-avatar.png';
          const safeRequestId = sanitizeText(request.id || '');
          const safeFromUid = sanitizeText(request.from || '');
          
          return `
            <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg">
              <img src="${safePhotoURL}" 
                   alt="${safeDisplayName}" 
                   class="w-10 h-10 rounded-full">
              <div class="flex-1 min-w-0">
                <h4 class="font-medium text-rp-text">${safeDisplayName}</h4>
                <p class="text-xs text-rp-subtle">${safeUsername ? '@' + safeUsername : ''}</p>
              </div>
              <div class="flex gap-2">
                <button onclick="acceptFriendRequest('${safeRequestId}', '${safeFromUid}')" 
                        class="px-3 py-1 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded text-xs">
                  Accept
                </button>
                <button onclick="declineFriendRequest('${safeRequestId}')" 
                        class="px-3 py-1 bg-rp-love/20 hover:bg-rp-love/30 text-rp-love rounded text-xs">
                  Decline
                </button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      // Render outgoing requests
      const outgoingContainer = document.getElementById('outgoingRequests');
      const noOutgoing = document.getElementById('noOutgoingRequests');
      
      if (outgoing.length === 0) {
        outgoingContainer.innerHTML = '';
        noOutgoing.classList.remove('hidden');
      } else {
        noOutgoing.classList.add('hidden');
        outgoingContainer.innerHTML = outgoing.map(request => {
          // Sanitize outgoing request data to prevent XSS
          const safeDisplayName = sanitizeText(request.toUserData.displayName || 'Unknown User');
          const safePhotoURL = request.toUserData.photoURL || '/default-avatar.png';
          const safeRequestId = sanitizeText(request.id || '');
          
          return `
            <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg">
              <img src="${safePhotoURL}" 
                   alt="${safeDisplayName}" 
                   class="w-10 h-10 rounded-full">
              <div class="flex-1 min-w-0">
                <h4 class="font-medium text-rp-text">${safeDisplayName}</h4>
                <p class="text-xs text-rp-subtle">Request sent</p>
              </div>
              <div>
                <button onclick="cancelFriendRequest('${safeRequestId}')" 
                        class="px-3 py-1 bg-rp-subtle/20 hover:bg-rp-subtle/30 text-rp-subtle rounded text-xs">
                  Cancel
                </button>
              </div>
            </div>
          `;
        }).join('');
      }
    }

    async function cancelFriendRequest(requestId) {
      try {
        await db.collection('friendRequests').doc(requestId).delete();
        showNotification('Request Cancelled', 'Friend request cancelled', 'info');
        await loadFriendRequests();
      } catch (error) {
        console.error('Error cancelling friend request:', error);
      }
    }

    // Activity Feed Functions - only load if element exists
    async function loadActivityFeed() {
      const activityContainer = document.getElementById('activityFeed');
      const activityLoader = document.getElementById('activityLoader');
      const noActivity = document.getElementById('noActivity');
      
      // If activity feed elements don't exist, don't try to load
      if (!activityContainer) {
        console.log('Activity feed elements not found, skipping activity feed load');
        return;
      }
      
      if (!currentUser) return;
      
      try {
        if (activityLoader) activityLoader.classList.remove('hidden');
        if (noActivity) noActivity.classList.add('hidden');
        
        // Get current user's friends
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        const friendUids = userData.friends || [];
        
        // Include current user in activity
        const allUids = [currentUser.uid, ...friendUids];
        
                // Load recent activity from friends and self (simplified to avoid index issues)
        const activities = [];
        
        // Load activities for each user individually to avoid complex index requirements
        const userBatches = [];
        for (let i = 0; i < allUids.length; i += 10) {
          userBatches.push(allUids.slice(i, i + 10));
        }
        
        for (const batch of userBatches.slice(0, 1)) { // Limit to first 10 friends for now
          try {
            const activityQuery = await db.collection('activity')
              .where('userId', 'in', batch)
              .limit(5) // 5 activities per user batch
              .get();
              
            activityQuery.forEach(doc => {
              activities.push({ id: doc.id, ...doc.data() });
            });
          } catch (batchError) {
            console.warn('Error loading activity batch:', batchError);
          }
        }
        
        // Sort activities by timestamp (client-side since we can't use orderBy with where)
        activities.sort((a, b) => {
          const aTime = a.timestamp?.toDate?.() || new Date(0);
          const bTime = b.timestamp?.toDate?.() || new Date(0);
          return bTime - aTime;
        });
        
        if (activityLoader) activityLoader.classList.add('hidden');
        
        if (activities.length === 0) {
          if (noActivity) noActivity.classList.remove('hidden');
          activityContainer.innerHTML = '';
          return;
        }
        
        renderActivityFeed(activities);
        
      } catch (error) {
        console.error('Error loading activity feed:', error);
        if (activityLoader) activityLoader.classList.add('hidden');
        if (noActivity) noActivity.classList.remove('hidden');
      }
    }

    function renderActivityFeed(activities) {
      const activityContainer = document.getElementById('activityFeed');
      if (!activityContainer) return;
      
      activityContainer.innerHTML = activities.map(activity => {
        const timeAgo = getTimeAgo(activity.timestamp?.toDate());
        const isCurrentUser = activity.userId === currentUser.uid;
        const userName = isCurrentUser ? 'You' : sanitizeText(activity.userName);
        const actionText = activity.action === 'started' ? 'started playing' : 'played';
        
        return `
          <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg hover:bg-rp-highlight-med transition-colors">
            <div class="w-8 h-8 rounded-full bg-rp-foam/20 flex items-center justify-center flex-shrink-0">
              <i class='bx bx-game text-rp-foam text-sm'></i>
            </div>
            <div class="flex-1 min-w-0">
              <p class="text-sm text-rp-text">
                <span class="font-medium ${isCurrentUser ? 'text-rp-foam' : 'text-rp-text'}">${userName}</span>
                ${actionText}
                <span class="font-medium text-rp-gold">${sanitizeText(activity.gameTitle)}</span>
              </p>
              <p class="text-xs text-rp-subtle">${timeAgo}</p>
            </div>
            <img src="${activity.gameImage || '/default-game.png'}" 
                 alt="${activity.gameTitle}" 
                 class="w-8 h-8 rounded object-cover">
          </div>
        `;
      }).join('');
    }

    function getTimeAgo(date) {
      if (!date) return 'recently';
      
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (minutes < 1) return 'just now';
      if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
      if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
      if (days < 30) return `${days} day${days === 1 ? '' : 's'} ago`;
      return date.toLocaleDateString();
    }

    // Profile bio editing
    async function loadUserProfile() {
      if (!currentUser) return;
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        
        // Update user avatar and name in status section
        document.getElementById('userAvatar').src = currentUser.photoURL || '/default-avatar.png';
        document.getElementById('userDisplayName').textContent = sanitizeText(currentUser.displayName || 'Anonymous');
        
        // Set status selector and indicator
        const statusSelector = document.getElementById('statusSelector');
        const currentStatus = userData.status || 'online';
        statusSelector.value = currentStatus;
        updateStatusIndicator(currentStatus);
        console.log('Loaded user status from Firebase:', currentStatus);
        
        // Show current game if playing
        if (userData.currentGame && userData.status === 'ingame') {
          const game = gamesData.find(g => String(g.id) === String(userData.currentGame));
          if (game) {
            document.getElementById('currentGameDisplay').classList.remove('hidden');
            document.getElementById('currentGameName').textContent = sanitizeText(game.title);
          }
        }
        
        // Sanitize and display current profile info
        const safeUsername = sanitizeText(userData.username || 'Not set');
        const safeBio = sanitizeText(userData.bio || 'No bio set');
        
        document.getElementById('displayUsername').textContent = safeUsername;
        document.getElementById('displayBio').textContent = safeBio;
        document.getElementById('displayPrivacy').textContent = 
          userData.privacy === 'public' ? 'Public Profile' :
          userData.privacy === 'friends' ? 'Friends Only' : 'Private Profile';
        
        // Show last played game
        if (userData.lastPlayedGame) {
          const lastGame = gamesData.find(g => String(g.id) === String(userData.lastPlayedGame));
          if (lastGame) {
            document.getElementById('lastGameImage').src = lastGame.image || '/default-game.png';
            document.getElementById('lastGameTitle').textContent = sanitizeText(lastGame.title);
            if (userData.lastPlayedTime) {
              document.getElementById('lastGameTime').textContent = getTimeAgo(userData.lastPlayedTime.toDate());
            }
          }
        }
        
        // Show favorite games
        const favoriteGamesContainer = document.getElementById('displayFavoriteGames');
        if (userData.favoriteGames && userData.favoriteGames.length > 0) {
          favoriteGamesContainer.innerHTML = userData.favoriteGames.slice(0, 3).map(gameId => {
            const game = gamesData.find(g => String(g.id) === String(gameId));
            if (game) {
              const safeGameTitle = sanitizeText(game.title);
              return `<span class="px-2 py-1 bg-rp-foam/20 text-rp-foam rounded text-xs">${safeGameTitle}</span>`;
            }
            return '';
          }).join('');
        } else {
          favoriteGamesContainer.innerHTML = '<span class="text-rp-subtle text-xs">None selected</span>';
        }
        
      } catch (error) {
        console.error('Error loading user profile:', error);
      }
    }

    function editBio() {
      const displaySection = document.getElementById('bioDisplay');
      const editorSection = document.getElementById('bioEditor');
      
      // Populate editor with current values
      const currentUsername = document.getElementById('displayUsername').textContent;
      const currentBio = document.getElementById('displayBio').textContent;
      const currentPrivacy = document.getElementById('displayPrivacy').textContent;
      
      document.getElementById('editUsername').value = currentUsername === 'Not set' ? '' : currentUsername;
      document.getElementById('editBio').value = currentBio === 'No bio set' ? '' : currentBio;
      document.getElementById('editPrivacy').value = 
        currentPrivacy === 'Public Profile' ? 'public' :
        currentPrivacy === 'Friends Only' ? 'friends' : 'private';
      
      displaySection.classList.add('hidden');
      editorSection.classList.remove('hidden');
      
      // Setup character counter
      const bioTextarea = document.getElementById('editBio');
      const charCount = document.getElementById('bioCharCount');
      
      function updateCharCount() {
        charCount.textContent = bioTextarea.value.length;
      }
      
      updateCharCount();
      bioTextarea.addEventListener('input', updateCharCount);
    }

    async function saveBio() {
      const username = document.getElementById('editUsername').value.trim();
      const bio = document.getElementById('editBio').value.trim();
      const privacy = document.getElementById('editPrivacy').value;
      
      // Sanitize inputs to prevent XSS
      const safeUsername = sanitizeText(username);
      const safeBio = sanitizeText(bio);
      const safePrivacy = ['public', 'friends', 'private'].includes(privacy) ? privacy : 'public';
      
      // Validate username
      if (safeUsername && !/^[a-zA-Z0-9_]+$/.test(safeUsername)) {
        showNotification('Invalid Username', 'Username can only contain letters, numbers, and underscores', 'error');
        return;
      }
      
      if (safeUsername && safeUsername.length < 3) {
        showNotification('Invalid Username', 'Username must be at least 3 characters', 'error');
        return;
      }
      
      // Validate bio length
      if (safeBio.length > 200) {
        showNotification('Bio Too Long', 'Bio must be 200 characters or less', 'error');
        return;
      }
      
      try {
        // Check if username is already taken
        if (safeUsername) {
          const usernameQuery = await db.collection('users')
            .where('username', '==', safeUsername.toLowerCase())
            .get();
          
          if (!usernameQuery.empty && usernameQuery.docs[0].id !== currentUser.uid) {
            showNotification('Username Taken', 'This username is already taken', 'error');
            return;
          }
        }
        
        // Update user profile with sanitized data
        await db.collection('users').doc(currentUser.uid).update({
          username: safeUsername.toLowerCase(),
          bio: safeBio,
          privacy: safePrivacy
        });
        
        showNotification('Profile Updated', 'Your profile has been updated successfully', 'success');
        await loadUserProfile();
        cancelBioEdit();
        
      } catch (error) {
        console.error('Error saving profile:', error);
        showNotification('Error', 'Failed to update profile', 'error');
      }
    }

    function cancelBioEdit() {
      document.getElementById('bioDisplay').classList.remove('hidden');
      document.getElementById('bioEditor').classList.add('hidden');
    }

    // Online friends tracking
    async function updateOnlineFriendsList() {
      if (!currentUser) return;
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const friendUids = userDoc.data().friends || [];
        
        if (friendUids.length === 0) {
          document.getElementById('onlineFriendsList').innerHTML = '';
          document.getElementById('noOnlineFriends').classList.remove('hidden');
          return;
        }
        
        const onlineFriendsData = [];
        for (const uid of friendUids) {
          const friendDoc = await db.collection('users').doc(uid).get();
          if (friendDoc.exists) {
            const friendData = friendDoc.data();
            if (friendData.status && friendData.status !== 'offline') {
              onlineFriendsData.push({ uid, ...friendData });
            }
          }
        }
        
        const onlineContainer = document.getElementById('onlineFriendsList');
        const noOnlineEl = document.getElementById('noOnlineFriends');
        
        if (onlineFriendsData.length === 0) {
          onlineContainer.innerHTML = '';
          noOnlineEl.classList.remove('hidden');
        } else {
          noOnlineEl.classList.add('hidden');
          onlineContainer.innerHTML = onlineFriendsData.map(friend => {
            const statusColor = statusColors[friend.status] || statusColors.online;
            const statusText = getStatusText(friend.status);
            const gameText = friend.currentGame && friend.status === 'ingame' 
              ? getGameTitle(friend.currentGame) : '';
            
            // Sanitize friend data to prevent XSS
            const safeDisplayName = sanitizeText(friend.displayName || 'Unknown User');
            const safePhotoURL = friend.photoURL || '/default-avatar.png';
            const safeUid = sanitizeText(friend.uid || '');
            const safeGameText = sanitizeText(gameText || '');
            
            const clickAction = friend.status !== 'dnd' ? 
              `onclick="startChat('${safeUid}', '${safeDisplayName}')"` : '';
            
            return `
              <div class="flex items-center gap-3 p-3 bg-rp-overlay rounded-lg hover:bg-rp-highlight-med transition-colors ${friend.status !== 'dnd' ? 'cursor-pointer' : ''}"
                   ${clickAction}>
                <div class="relative">
                  <img src="${safePhotoURL}" 
                       alt="${safeDisplayName}" 
                       class="w-10 h-10 rounded-full ring-2 ring-rp-overlay">
                  <div class="${statusColor} w-3 h-3 rounded-full absolute -bottom-0.5 -right-0.5 border-2 border-rp-surface"></div>
                </div>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium text-rp-text truncate">${safeDisplayName}</p>
                  <p class="text-xs text-rp-foam font-medium">${statusText}</p>
                  ${safeGameText ? `<p class="text-xs text-rp-gold truncate">${safeGameText}</p>` : ''}
                </div>
                ${friend.status === 'ingame' && friend.currentGame ? `
                  <button onclick="event.stopPropagation(); playGame('${sanitizeText(friend.currentGame)}')" 
                          class="px-2 py-1 bg-rp-gold/20 hover:bg-rp-gold/30 text-rp-gold rounded text-xs transition-colors">
                    <i class='bx bx-play'></i>
                  </button>
                ` : ''}
              </div>
            `;
          }).join('');
        }
        
      } catch (error) {
        console.error('Error updating online friends:', error);
      }
    }

    // Game invitations
    async function inviteToGame(friendUid, gameId) {
      if (!currentUser) return;
      
      try {
        const game = gamesData.find(g => String(g.id) === String(gameId));
        if (!game) return;
        
        const inviteData = {
          from: currentUser.uid,
          to: friendUid,
          fromName: currentUser.displayName,
          gameId: gameId,
          gameTitle: game.title,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          status: 'pending'
        };
        
        await db.collection('gameInvites').add(inviteData);
        showNotification('Invite Sent', `Game invitation sent!`, 'success');
        
      } catch (error) {
        console.error('Error sending game invite:', error);
        showNotification('Error', 'Failed to send game invitation', 'error');
      }
    }

    function viewUserProfile(uid) {
      // Open user's public profile in new tab
      window.open(`/profile.html?uid=${uid}`, '_blank');
    }

    // Notification system
    function showNotification(title, message, type = 'info') {
      const toast = document.getElementById('notificationToast');
      const titleEl = document.getElementById('notificationTitle');
      const messageEl = document.getElementById('notificationMessage');
      const iconEl = document.getElementById('notificationIcon');
      
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // Update icon based on type
      let iconClass = 'bx-bell';
      let iconBg = 'bg-rp-foam';
      
      switch (type) {
        case 'success':
          iconClass = 'bx-check';
          iconBg = 'bg-green-500';
          break;
        case 'error':
          iconClass = 'bx-x';
          iconBg = 'bg-red-500';
          break;
        case 'warning':
          iconClass = 'bx-warning';
          iconBg = 'bg-yellow-500';
          break;
      }
      
      iconEl.className = `w-8 h-8 rounded-full ${iconBg} flex items-center justify-center`;
      iconEl.innerHTML = `<i class='bx ${iconClass} text-white'></i>`;
      
      // Show notification
      toast.classList.remove('translate-x-full');
      
      // Auto hide after 4 seconds
      setTimeout(() => {
        toast.classList.add('translate-x-full');
      }, 4000);
    }

    // Enhanced notification system for better UX
    window.createEnhancedNotification = function(title, message, type = 'info') {
      // Create notification container if it doesn't exist
      let notificationContainer = document.getElementById('enhancedNotificationContainer');
      if (!notificationContainer) {
        notificationContainer = document.createElement('div');
        notificationContainer.id = 'enhancedNotificationContainer';
        notificationContainer.className = 'notification-stack';
        document.body.appendChild(notificationContainer);
      }

      // Create notification element
      const notification = document.createElement('div');
      notification.className = 'notification-enhanced bg-rp-surface border border-rp-overlay rounded-lg p-4 shadow-lg max-w-sm transform translate-x-full transition-transform duration-300';
      
      // Set notification styling based on type
      let iconClass, borderColor, iconBg;
      switch (type) {
        case 'success':
          iconClass = 'bx-check-circle';
          borderColor = 'border-green-500';
          iconBg = 'bg-green-500';
          break;
        case 'error':
          iconClass = 'bx-error-circle';
          borderColor = 'border-red-500';
          iconBg = 'bg-red-500';
          break;
        case 'warning':
          iconClass = 'bx-error';
          borderColor = 'border-yellow-500';
          iconBg = 'bg-yellow-500';
          break;
        case 'follow':
          iconClass = 'bx-user-plus';
          borderColor = 'border-rp-iris';
          iconBg = 'bg-rp-iris';
          break;
        case 'game':
          iconClass = 'bx-game';
          borderColor = 'border-rp-gold';
          iconBg = 'bg-rp-gold';
          break;
        default:
          iconClass = 'bx-info-circle';
          borderColor = 'border-rp-foam';
          iconBg = 'bg-rp-foam';
      }

      notification.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 rounded-full ${iconBg} flex items-center justify-center flex-shrink-0">
            <i class='bx ${iconClass} text-white'></i>
          </div>
          <div class="flex-1 min-w-0">
            <p class="text-rp-text font-medium text-sm text-consistent">${sanitizeText(title)}</p>
            <p class="text-rp-subtle text-xs text-consistent">${sanitizeText(message)}</p>
          </div>
          <button onclick="this.parentElement.parentElement.remove()" class="text-rp-subtle hover:text-rp-love transition-colors">
            <i class='bx bx-x'></i>
          </button>
        </div>
      `;

      // Add border color
      notification.classList.add(borderColor);

      // Add to container
      notificationContainer.appendChild(notification);

      // Animate in
      setTimeout(() => {
        notification.classList.remove('translate-x-full');
      }, 100);

      // Auto-remove after delay
      const delay = type === 'error' ? 5000 : 3000;
      setTimeout(() => {
        if (notification.parentNode) {
          notification.classList.add('translate-x-full');
          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 300);
        }
      }, delay);

      // Clean up container if empty
      setTimeout(() => {
        if (notificationContainer && notificationContainer.children.length === 0) {
          notificationContainer.remove();
        }
      }, delay + 500);
    };

    // Status Notes Functions - 24 Hour Status Notes
    let currentStatusNote = null;
    let activeStatusNoteTimer = null;
    let activeFriendForNote = null;

    async function loadStatusNote() {
      if (!currentUser) return;
      
      try {
        const statusNoteDoc = await db.collection('statusNotes').doc(currentUser.uid).get();
        if (statusNoteDoc.exists) {
          const noteData = statusNoteDoc.data();
          const now = new Date();
          
          // Handle different date formats (Firestore timestamp or regular Date)
          let expiry;
          if (noteData.expiresAt && typeof noteData.expiresAt.toDate === 'function') {
            // Firestore timestamp
            expiry = noteData.expiresAt.toDate();
          } else if (noteData.expiresAt instanceof Date) {
            // Regular Date object
            expiry = noteData.expiresAt;
          } else if (noteData.expiresAt && noteData.expiresAt.seconds) {
            // Firestore timestamp in seconds format
            expiry = new Date(noteData.expiresAt.seconds * 1000);
          } else {
            console.warn('Unable to parse expiry date:', noteData.expiresAt);
            return;
          }
          
          if (expiry > now) {
            currentStatusNote = noteData;
            displayStatusNote(noteData);
            scheduleStatusNoteExpiry(expiry);
          } else {
            // Note expired, remove it
            await db.collection('statusNotes').doc(currentUser.uid).delete();
          }
        }
      } catch (error) {
        console.error('Error loading status note:', error);
      }
    }

    function displayStatusNote(noteData) {
      const noteContainer = document.getElementById('currentStatusNote');
      const noteText = document.getElementById('statusNoteText');
      const noteExpiry = document.getElementById('statusNoteExpiry');
      
      if (noteContainer && noteText && noteExpiry) {
        // Parse expiry date safely
        let expiryDate;
        if (noteData.expiresAt && typeof noteData.expiresAt.toDate === 'function') {
          // Firestore timestamp
          expiryDate = noteData.expiresAt.toDate();
        } else if (noteData.expiresAt instanceof Date) {
          // Regular Date object
          expiryDate = noteData.expiresAt;
        } else if (noteData.expiresAt && noteData.expiresAt.seconds) {
          // Firestore timestamp in seconds format
          expiryDate = new Date(noteData.expiresAt.seconds * 1000);
        } else {
          console.warn('Unable to display status note - invalid expiry date:', noteData.expiresAt);
          return;
        }
        
        noteText.textContent = noteData.text || '';
        noteExpiry.textContent = getTimeUntilExpiry(expiryDate);
        noteContainer.classList.remove('hidden');
        
        // Update expiry text every minute
        if (activeStatusNoteTimer) clearInterval(activeStatusNoteTimer);
        activeStatusNoteTimer = setInterval(() => {
          const timeLeft = getTimeUntilExpiry(expiryDate);
          if (timeLeft === 'Expired') {
            clearStatusNote();
          } else {
            noteExpiry.textContent = timeLeft;
          }
        }, 60000);
      }
    }

    function getTimeUntilExpiry(expiryDate) {
      const now = new Date();
      const diff = expiryDate - now;
      
      if (diff <= 0) return 'Expired';
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      
      if (hours > 0) {
        return `${hours}h ${minutes}m left`;
      } else {
        return `${minutes}m left`;
      }
    }

    function scheduleStatusNoteExpiry(expiryDate) {
      const now = new Date();
      const timeUntilExpiry = expiryDate - now;
      
      if (timeUntilExpiry > 0) {
        setTimeout(() => {
          clearStatusNote();
        }, timeUntilExpiry);
      }
    }

    async function clearStatusNote() {
      try {
        await db.collection('statusNotes').doc(currentUser.uid).delete();
        currentStatusNote = null;
        
        const noteContainer = document.getElementById('currentStatusNote');
        if (noteContainer) {
          noteContainer.classList.add('hidden');
        }
        
        if (activeStatusNoteTimer) {
          clearInterval(activeStatusNoteTimer);
          activeStatusNoteTimer = null;
        }
      } catch (error) {
        console.error('Error clearing status note:', error);
      }
    }

    async function saveStatusNote() {
      const noteInput = document.getElementById('statusNoteInput');
      if (!noteInput) {
        console.error('Status note input element not found');
        return;
      }
      
      const noteText = noteInput.value.trim();
      
      // Validation
      if (!noteText) {
        showNotification('Empty Note', 'Please enter a status note before saving', 'warning');
        return;
      }
      
      if (!currentUser) {
        showNotification('Not Logged In', 'Please log in to save status notes', 'error');
        return;
      }
      
      if (noteText.length > 100) {
        showNotification('Note Too Long', 'Status notes must be 100 characters or less', 'error');
        return;
      }
      
      try {
        // Sanitize the note text
        const safeNoteText = sanitizeText(noteText);
        
        if (!safeNoteText) {
          showNotification('Invalid Text', 'Please enter valid text for your status note', 'error');
          return;
        }
        
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 24);
        
        const statusNoteData = {
          userId: currentUser.uid,
          text: safeNoteText,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          expiresAt: expiresAt // Use regular Date object - Firestore will handle conversion
        };
        
        console.log('📝 Saving status note:', statusNoteData);
        
        await db.collection('statusNotes').doc(currentUser.uid).set(statusNoteData);
        
        // Create a properly formatted object for display
        currentStatusNote = { 
          ...statusNoteData, 
          expiresAt: expiresAt // Use the actual date for consistent handling
        };
        
        // Close modal and clear input
        const modal = document.getElementById('statusNoteModal');
        if (modal) modal.classList.add('hidden');
        noteInput.value = '';
        
        // Update character count
        updateStatusNoteCharCount();
        
        displayStatusNote(currentStatusNote);
        showNotification('Status Note Posted', 'Your 24-hour status note is now visible to friends!', 'success');
        
      } catch (error) {
        console.error('Error saving status note:', error);
        console.error('Error details:', error.message || error);
        
        let errorMessage = 'Failed to save status note';
        if (error.message) {
          errorMessage += ': ' + error.message;
        }
        showNotification('Error', errorMessage, 'error');
      }
    }

    // Friend Notes Functions - Private Notes
    async function openFriendNotes(friendUid, friendName, friendPhoto) {
      activeFriendForNote = friendUid;
      
      // Set friend info in modal
      document.getElementById('friendNoteAvatar').src = friendPhoto || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(friendName) + '&background=6e6a86&color=e0def4';
      document.getElementById('friendNoteName').textContent = friendName;
      
      // Load existing notes
      try {
        const noteDoc = await db.collection('friendNotes').doc(`${currentUser.uid}_${friendUid}`).get();
        if (noteDoc.exists) {
          document.getElementById('friendNoteInput').value = noteDoc.data().note || '';
        } else {
          document.getElementById('friendNoteInput').value = '';
        }
        updateFriendNoteCharCount();
      } catch (error) {
        console.error('Error loading friend note:', error);
      }
      
      document.getElementById('friendNotesModal').classList.remove('hidden');
    }

    async function saveFriendNote() {
      const noteText = document.getElementById('friendNoteInput').value.trim();
      if (!activeFriendForNote || !currentUser) return;
      
      try {
        const noteData = {
          userId: currentUser.uid,
          friendId: activeFriendForNote,
          note: noteText,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        if (noteText) {
          await db.collection('friendNotes').doc(`${currentUser.uid}_${activeFriendForNote}`).set(noteData);
          showNotification('Notes Saved', 'Your private notes have been saved', 'success');
        } else {
          // Delete note if empty
          await db.collection('friendNotes').doc(`${currentUser.uid}_${activeFriendForNote}`).delete();
          showNotification('Notes Cleared', 'Your private notes have been cleared', 'success');
        }
        
        document.getElementById('friendNotesModal').classList.add('hidden');
        activeFriendForNote = null;
        
      } catch (error) {
        console.error('Error saving friend note:', error);
        showNotification('Error', 'Failed to save notes', 'error');
      }
    }

    function updateStatusNoteCharCount() {
      const input = document.getElementById('statusNoteInput');
      const counter = document.getElementById('statusNoteCharCount');
      if (input && counter) {
        counter.textContent = input.value.length;
      }
    }

    function updateFriendNoteCharCount() {
      const input = document.getElementById('friendNoteInput');
      const counter = document.getElementById('friendNoteCharCount');
      if (input && counter) {
        counter.textContent = input.value.length;
      }
    }

    // Load friend notes for display in friend cards
    async function loadFriendNote(friendUid) {
      if (!currentUser) return '';
      
      try {
        const noteDoc = await db.collection('friendNotes').doc(`${currentUser.uid}_${friendUid}`).get();
        return noteDoc.exists ? noteDoc.data().note || '' : '';
      } catch (error) {
        console.error('Error loading friend note:', error);
        return '';
      }
    }

    // Initialize friend system event listeners
    function initializeFriendSystemEvents() {
      // Status Notes Event Listeners
      document.getElementById('addStatusNote').addEventListener('click', () => {
        document.getElementById('statusNoteModal').classList.remove('hidden');
        document.getElementById('statusNoteInput').focus();
      });
      
      document.getElementById('closeStatusNoteModal').addEventListener('click', () => {
        document.getElementById('statusNoteModal').classList.add('hidden');
        document.getElementById('statusNoteInput').value = '';
      });
      
      document.getElementById('saveStatusNote').addEventListener('click', saveStatusNote);
      document.getElementById('cancelStatusNote').addEventListener('click', () => {
        document.getElementById('statusNoteModal').classList.add('hidden');
        document.getElementById('statusNoteInput').value = '';
      });
      
      document.getElementById('statusNoteInput').addEventListener('input', updateStatusNoteCharCount);
      
      document.getElementById('clearStatusNote').addEventListener('click', clearStatusNote);
      
      // Friend Notes Event Listeners
      document.getElementById('closeFriendNotesModal').addEventListener('click', () => {
        document.getElementById('friendNotesModal').classList.add('hidden');
        activeFriendForNote = null;
      });
      
      document.getElementById('saveFriendNote').addEventListener('click', saveFriendNote);
      document.getElementById('cancelFriendNote').addEventListener('click', () => {
        document.getElementById('friendNotesModal').classList.add('hidden');
        activeFriendForNote = null;
      });
      
      document.getElementById('friendNoteInput').addEventListener('input', updateFriendNoteCharCount);
      
      // Search users modal
      document.getElementById('searchUsersBtn').addEventListener('click', () => {
        document.getElementById('userSearchModal').classList.remove('hidden');
        document.getElementById('userSearchInput').focus();
      });
      
      document.getElementById('closeSearchModal').addEventListener('click', () => {
        document.getElementById('userSearchModal').classList.add('hidden');
        document.getElementById('userSearchInput').value = '';
        document.getElementById('searchResults').innerHTML = '';
        document.getElementById('noSearchResults').classList.add('hidden');
      });
      
      // User search input
      let searchTimeout;
      document.getElementById('userSearchInput').addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        
        if (!query) {
          document.getElementById('searchResults').innerHTML = '';
          document.getElementById('noSearchResults').classList.add('hidden');
          return;
        }
        
        document.getElementById('searchLoading').classList.remove('hidden');
        document.getElementById('noSearchResults').classList.add('hidden');
        
        searchTimeout = setTimeout(async () => {
          const results = await searchUsers(query);
          document.getElementById('searchLoading').classList.add('hidden');
          renderUserSearchResults(results);
        }, 500);
      });
      
      // Friend requests modal
      document.getElementById('friendRequestsBtn').addEventListener('click', () => {
        document.getElementById('friendRequestsModal').classList.remove('hidden');
        loadFriendRequests();
      });
      
      document.getElementById('closeRequestsModal').addEventListener('click', () => {
        document.getElementById('friendRequestsModal').classList.add('hidden');
      });
      
      // Bio editing
      document.getElementById('editBioBtn').addEventListener('click', editBio);
      document.getElementById('saveBioBtn').addEventListener('click', saveBio);
      document.getElementById('cancelBioBtn').addEventListener('click', cancelBioEdit);
      
      // Status selector
      document.getElementById('statusSelector').addEventListener('change', async (e) => {
        const newStatus = e.target.value;
        console.log('Status selector changed to:', newStatus);
        
        // Update status in Firebase and UI
        await updateUserStatus(newStatus);
        
        // Hide current game display if not in game
        if (newStatus !== 'ingame') {
          document.getElementById('currentGameDisplay').classList.add('hidden');
        }
        
        // Force update status indicator
        updateStatusIndicator(newStatus);
      });
      
      // Chat system
      document.getElementById('closeChatBtn').addEventListener('click', () => {
        document.getElementById('quickChatSection').classList.add('hidden');
        
        // Clean up chat listeners
        if (chatListener) {
          chatListener();
          chatListener = null;
        }
        
        if (window.chatBackgroundListener) {
          window.chatBackgroundListener();
          window.chatBackgroundListener = null;
        }
        
        // Stop particles animation
        if (chatParticlesAnimation && chatParticlesAnimation.stop) {
          chatParticlesAnimation.stop();
        }
        
        activeChatUser = null;
        activeChatRoomId = null;
        currentChatBackground = 'default';
      });
      
      // Chat settings toggle
      document.getElementById('chatSettingsBtn').addEventListener('click', () => {
        const settingsPanel = document.getElementById('chatBackgroundSettings');
        if (settingsPanel) {
          settingsPanel.classList.toggle('hidden');
        }
      });
      
      // Chat background options
      document.querySelectorAll('.chat-bg-option').forEach(option => {
        option.addEventListener('click', () => {
          const background = option.dataset.bg;
          if (background) {
            setChatBackground(background);
          }
        });
      });
      
      document.getElementById('sendMessageBtn').addEventListener('click', sendMessage);
      
      document.getElementById('chatInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Notification close
      document.getElementById('closeNotification').addEventListener('click', () => {
        document.getElementById('notificationToast').classList.add('translate-x-full');
      });
      
      // Suggested users refresh
      document.getElementById('refreshSuggestionsBtn').addEventListener('click', async () => {
        await forceRefreshSuggestedUsers();
      });
      
      // Modal click outside to close
      document.getElementById('userSearchModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          document.getElementById('closeSearchModal').click();
        }
      });
      
      document.getElementById('friendRequestsModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          document.getElementById('closeRequestsModal').click();
        }
      });
      
      document.getElementById('gameInviteModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          document.getElementById('closeInviteModal').click();
        }
      });
      
      // Periodic updates
      setInterval(updateOnlineFriendsList, 15000); // Update every 15 seconds
      setInterval(loadActivityFeed, 30000); // Update activity feed every 30 seconds
    }

    // Test function to verify friend system is working
    window.testFriendSystem = function() {
      console.log('🧪 Testing friend system...');
      console.log('Current user:', currentUser);
      console.log('Functions available:');
      console.log('- sendFriendRequest:', typeof sendFriendRequest);
      console.log('- acceptFriendRequest:', typeof acceptFriendRequest);
      console.log('- declineFriendRequest:', typeof declineFriendRequest);
      console.log('- loadFriendRequests:', typeof loadFriendRequests);
      console.log('- searchUsers:', typeof searchUsers);
      
      if (currentUser) {
        console.log('✅ User is authenticated');
        loadFriendRequests();
      } else {
        console.log('❌ User not authenticated');
      }
    };

    // Make functions globally available - direct assignment to avoid recursion
    window.sendFriendRequest = sendFriendRequest;
    window.acceptFriendRequest = acceptFriendRequest;
    window.declineFriendRequest = declineFriendRequest;
    window.cancelFriendRequest = cancelFriendRequest;
    window.removeFriend = removeFriend;
    window.startChat = startChat;
    window.inviteToGame = inviteToGame;
    window.viewUserProfile = viewUserProfile;
    window.followUser = followUser;
    window.unfollowUser = unfollowUser;
    
    // Manual cleanup function for duplicate followers
    window.cleanupMyDuplicateFollowers = async function() {
      if (!currentUser) {
        console.log('❌ Please sign in first');
        return;
      }
      
      try {
        console.log('🧹 Starting manual cleanup of your duplicate followers...');
        
        // Clean up duplicates
        await cleanupDuplicateFollowers(currentUser.uid);
        
        // Reload data
        await loadFollowerData(currentUser.uid);
        updateFollowerCounts();
        
        // Refresh the modal if it's open
        const followersModal = document.getElementById('followersModal');
        if (!followersModal.classList.contains('hidden')) {
          const activeTab = document.querySelector('#followersTab.bg-rp-foam\\/20') ? 'followers' : 'following';
          await showFollowersModal(activeTab);
        }
        
        window.createEnhancedNotification('Cleanup Complete', 'Duplicate followers have been removed', 'success');
        console.log('✅ Manual cleanup completed successfully');
        
      } catch (error) {
        console.error('❌ Error during cleanup:', error);
        window.createEnhancedNotification('Cleanup Failed', 'Failed to cleanup duplicates', 'error');
      }
    };
    
    // Function to manually remove a specific user from following list
    window.unfollowSpecificUser = async function(uid) {
      if (!currentUser || !uid) {
        console.log('❌ Please provide a valid user ID');
        return;
      }
      
      try {
        console.log(`🔄 Attempting to unfollow user: ${uid}`);
        
        // Check if actually following
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data();
        const following = userData.following || [];
        
        if (!following.includes(uid)) {
          console.log('❌ You are not following this user');
          return;
        }
        
        // Get info about the user being unfollowed
        const targetDoc = await db.collection('users').doc(uid).get();
        const targetData = targetDoc.exists ? targetDoc.data() : {};
        const targetName = targetData.displayName || 'User ' + uid.substring(0, 6);
        
        if (!confirm(`Are you sure you want to unfollow ${targetName} (${uid})?`)) {
          return;
        }
        
        // Perform unfollow
        await unfollowUser(uid);
        
        console.log(`✅ Successfully unfollowed ${targetName}`);
        
        // Refresh the modal if open
        const followersModal = document.getElementById('followersModal');
        if (!followersModal.classList.contains('hidden')) {
          await showFollowersModal('following');
        }
        
      } catch (error) {
        console.error('❌ Error unfollowing user:', error);
      }
    };
    
    // Analyze duplicate users issue
    window.analyzeDuplicateUsers = async function(displayName = 'SpawnCamperKid') {
      if (!currentUser) {
        console.log('❌ Please sign in first');
        return;
      }
      
      try {
        console.log(`🔍 Analyzing duplicate users with display name: "${displayName}"`);
        
        // Get current user's data
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (!userDoc.exists) {
          console.log('❌ Current user document not found');
          return;
        }
        
        const userData = userDoc.data();
        const followers = userData.followers || [];
        const following = userData.following || [];
        
        console.log('📊 Current user stats:');
        console.log(`- Followers: ${followers.length}`);
        console.log(`- Following: ${following.length}`);
        
        // Check for users with the specified display name
        const matchingFollowers = [];
        const matchingFollowing = [];
        
        // Check followers
        for (const uid of followers) {
          try {
            const doc = await db.collection('users').doc(uid).get();
            if (doc.exists) {
              const data = doc.data();
              if (data.displayName === displayName) {
                matchingFollowers.push({
                  uid: uid,
                  displayName: data.displayName,
                  username: data.username || 'none',
                  email: data.email || 'none'
                });
              }
            }
          } catch (error) {
            console.error(`Error checking follower ${uid}:`, error);
          }
        }
        
        // Check following
        for (const uid of following) {
          try {
            const doc = await db.collection('users').doc(uid).get();
            if (doc.exists) {
              const data = doc.data();
              if (data.displayName === displayName) {
                matchingFollowing.push({
                  uid: uid,
                  displayName: data.displayName,
                  username: data.username || 'none',
                  email: data.email || 'none'
                });
              }
            }
          } catch (error) {
            console.error(`Error checking following ${uid}:`, error);
          }
        }
        
        console.log(`\n🎯 Users with display name "${displayName}":`);
        
        if (matchingFollowers.length > 0) {
          console.log('\n📥 In your FOLLOWERS list:');
          matchingFollowers.forEach((user, index) => {
            console.log(`${index + 1}. UID: ${user.uid}`);
            console.log(`   Username: ${user.username}`);
            console.log(`   Email: ${user.email}`);
          });
        }
        
        if (matchingFollowing.length > 0) {
          console.log('\n📤 In your FOLLOWING list:');
          matchingFollowing.forEach((user, index) => {
            console.log(`${index + 1}. UID: ${user.uid}`);
            console.log(`   Username: ${user.username}`);
            console.log(`   Email: ${user.email}`);
          });
        }
        
        if (matchingFollowers.length === 0 && matchingFollowing.length === 0) {
          console.log(`✅ No users found with display name "${displayName}"`);
        } else {
          console.log(`\n⚠️ Found ${matchingFollowers.length + matchingFollowing.length} users with the same display name`);
          console.log('This might indicate duplicate accounts or users with the same display name.');
          
          if (matchingFollowing.length > 1) {
            console.log('\n💡 You are following multiple users with the same display name.');
            console.log('To unfollow one of them, run:');
            matchingFollowing.forEach(user => {
              console.log(`   unfollowSpecificUser('${user.uid}')`);
            });
          }
          
          console.log('\n💡 To clean up any duplicate UIDs, run: cleanupMyDuplicateFollowers()');
        }
        
      } catch (error) {
        console.error('❌ Error analyzing duplicate users:', error);
      }
    };
    
    // Debug function to test follower system
    window.testFollowerSystem = function() {
      console.log('🔍 Follower System Debug Info:');
      console.log('Current User:', currentUser ? currentUser.uid : 'Not logged in');
      console.log('Follower System State:', followerSystemState);
      
      if (currentUser) {
        console.log('Running follower data reload...');
        loadFollowerData(currentUser.uid).then(() => {
          console.log('Updated Follower System State:', followerSystemState);
        });
      }
    };

    // Debug function to test modal elements
    window.testFollowerModal = function() {
      console.log('🔍 Follower Modal Debug Info:');
      
      // Check if modal exists
      const modal = document.getElementById('followersModal');
      console.log('Modal element:', modal ? 'Found' : 'Not found');
      
      // Check containers
      const followersList = document.getElementById('followersList');
      const followingList = document.getElementById('followingList');
      console.log('Followers container:', followersList ? 'Found' : 'Not found');
      console.log('Following container:', followingList ? 'Found' : 'Not found');
      
      // Check buttons
      const viewFollowersBtn = document.getElementById('viewFollowersBtn');
      const viewFollowingBtn = document.getElementById('viewFollowingBtn');
      console.log('View Followers button:', viewFollowersBtn ? 'Found' : 'Not found');
      console.log('View Following button:', viewFollowingBtn ? 'Found' : 'Not found');
      
      // Check data
      console.log('Follower System State:', followerSystemState);
      console.log('Current User Followers:', followerSystemState.currentUserFollowers);
      console.log('Current User Following:', followerSystemState.currentUserFollowing);
      
      // Test opening modal
      console.log('Testing modal opening...');
      if (modal) {
        showFollowersModal('followers');
      }
    };

    // Manual test with sample data
    window.testWithSampleData = function() {
      console.log('🧪 Testing with sample data...');
      
      // Create sample follower data
      const sampleFollowers = ['user1', 'user2'];
      const sampleFollowing = ['user3', 'user4', 'user5', 'user6'];
      
      // Update state
      followerSystemState.currentUserFollowers = sampleFollowers;
      followerSystemState.currentUserFollowing = sampleFollowing;
      
      // Update UI counts
      updateFollowerCounts();
      
      console.log('Sample data set:', followerSystemState);
      console.log('Now try clicking View Followers or View Following');
    };

    // Direct test of modal with real data
    window.testModalDirectly = function() {
      console.log('🚀 Testing modal directly with real data...');
      console.log('Current follower data:', {
        followers: followerSystemState.currentUserFollowers,
        following: followerSystemState.currentUserFollowing
      });
      
      // Open followers modal directly
      showFollowersModal('followers', null);
    };

    // Test follow/unfollow functionality
    window.testFollowSystem = async function() {
      console.log('🧪 Testing follow system...');
      console.log('Current following list:', followerSystemState.currentUserFollowing);
      
      // Update all button states
      updateAllFollowButtonStates();
      
      // Refresh suggested users to remove already followed users
      await forceRefreshSuggestedUsers();
      
      console.log('✅ Follow system updated and refreshed');
    };

    // Test suggested users system
    window.testSuggestedUsers = async function() {
      console.log('🧪 Testing suggested users system...');
      
      if (!currentUser) {
        console.log('❌ No current user logged in');
        return;
      }
      
      console.log('Current follower state:', {
        followers: followerSystemState.currentUserFollowers,
        following: followerSystemState.currentUserFollowing
      });
      
      // Force refresh suggested users
      await forceRefreshSuggestedUsers();
      
      // Check if any suggested users are already being followed
      const suggestedUsersList = document.getElementById('suggestedUsersList');
      if (suggestedUsersList) {
        const suggestedCards = suggestedUsersList.querySelectorAll('.suggestion-card');
        console.log('Suggested users found:', suggestedCards.length);
        
        suggestedCards.forEach(card => {
          const uid = card.getAttribute('data-user-id');
          const isFollowing = followerSystemState.currentUserFollowing && followerSystemState.currentUserFollowing.includes(uid);
          const followBtn = card.querySelector('button[onclick*="followUser"]');
          const unfollowBtn = card.querySelector('button[onclick*="unfollowUser"]');
          
          console.log(`User ${uid}:`, {
            isFollowing,
            hasFollowBtn: !!followBtn,
            hasUnfollowBtn: !!unfollowBtn,
            shouldShowFollow: !isFollowing,
            shouldShowUnfollow: isFollowing
          });
        });
      }
      
      console.log('✅ Suggested users test completed');
    };

    // Manual validation and cleanup of suggestions
    window.validateSuggestions = function() {
      console.log('🧹 Manual validation of suggestions...');
      validateAndCleanupSuggestions();
    };

    // Force remove a specific user from suggestions
    window.removeFromSuggestions = function(uid) {
      if (!uid) {
        console.log('❌ No UID provided');
        return;
      }
      
      const suggestionCard = document.querySelector(`.suggestion-card[data-user-id="${uid}"]`);
      if (suggestionCard) {
        console.log(`🗑️ Removing user ${uid} from suggestions`);
        suggestionCard.remove();
      } else {
        console.log(`❌ User ${uid} not found in suggestions`);
      }
    };

    // Global cleanup function to fix all users' duplicate followers
    window.cleanupAllDuplicateFollowers = async function() {
      if (!currentUser) {
        console.log('❌ No current user logged in');
        return;
      }
      
      try {
        console.log('🧹 Starting global duplicate follower cleanup...');
        
        // Get all users
        const usersSnapshot = await db.collection('users').get();
        let cleanedCount = 0;
        
        for (const userDoc of usersSnapshot.docs) {
          try {
            const userData = userDoc.data();
            const updates = {};
            
            // Deduplicate followers array
            if (userData.followers && Array.isArray(userData.followers)) {
              const uniqueFollowers = [...new Set(userData.followers)].filter(uid => uid && typeof uid === 'string');
              if (uniqueFollowers.length !== userData.followers.length) {
                updates.followers = uniqueFollowers;
                updates.followersCount = uniqueFollowers.length;
                console.log(`🧹 User ${userData.displayName || userDoc.id}: cleaned followers ${userData.followers.length} → ${uniqueFollowers.length}`);
              }
            }
            
            // Deduplicate following array
            if (userData.following && Array.isArray(userData.following)) {
              const uniqueFollowing = [...new Set(userData.following)].filter(uid => uid && typeof uid === 'string');
              if (uniqueFollowing.length !== userData.following.length) {
                updates.following = uniqueFollowing;
                updates.followingCount = uniqueFollowing.length;
                console.log(`🧹 User ${userData.displayName || userDoc.id}: cleaned following ${userData.following.length} → ${uniqueFollowing.length}`);
              }
            }
            
            // Update document if cleanup was needed
            if (Object.keys(updates).length > 0) {
              await userDoc.ref.update(updates);
              cleanedCount++;
            }
          } catch (error) {
            console.error(`Error cleaning up user ${userDoc.id}:`, error);
          }
        }
        
        console.log(`✅ Global cleanup completed. Cleaned ${cleanedCount} users.`);
        window.createEnhancedNotification('Cleanup Complete', `Cleaned up duplicate followers for ${cleanedCount} users`, 'success');
        
      } catch (error) {
        console.error('Error during global cleanup:', error);
        window.createEnhancedNotification('Cleanup Failed', 'Error during cleanup process', 'error');
      }
    };

    // Test duplicate follower prevention
    window.testDuplicatePrevention = function() {
      console.log('🧪 Testing duplicate follower prevention...');
      
      if (!currentUser) {
        console.log('❌ No current user logged in');
        return;
      }
      
      console.log('Current follower state:');
      console.log('- Followers:', followerSystemState.currentUserFollowers);
      console.log('- Following:', followerSystemState.currentUserFollowing);
      
      // Test deduplication function
      const testArray = ['user1', 'user2', 'user1', 'user3', 'user2'];
      const deduplicated = [...new Set(testArray)].filter(uid => uid && typeof uid === 'string');
      console.log('Deduplication test:', testArray, '→', deduplicated);
      
      // Test button state
      const followButtons = document.querySelectorAll('button[onclick*="followUser"]');
      const unfollowButtons = document.querySelectorAll('button[onclick*="unfollowUser"]');
      console.log('Follow buttons found:', followButtons.length);
      console.log('Unfollow buttons found:', unfollowButtons.length);
      
      console.log('✅ Duplicate prevention test completed');
    };

    // Force refresh follower data and UI state
    window.refreshFollowerState = async function() {
      if (!currentUser) {
        console.log('❌ No current user logged in');
        return;
      }
      
      try {
        console.log('🔄 Force refreshing follower state...');
        
        // Clean up any duplicates
        await cleanupDuplicateFollowers(currentUser.uid);
        
        // Reload data from database
        await loadFollowerData(currentUser.uid);
        
        // Update all UI elements
        updateFollowerCounts();
        updateAllFollowButtonStates();
        
        console.log('✅ Follower state refreshed successfully');
        console.log('Current state:', {
          followers: followerSystemState.currentUserFollowers,
          following: followerSystemState.currentUserFollowing
        });
        
        window.createEnhancedNotification('State Refreshed', 'Follower state has been refreshed', 'success');
        
      } catch (error) {
        console.error('Error refreshing follower state:', error);
        window.createEnhancedNotification('Refresh Failed', 'Failed to refresh follower state', 'error');
      }
    };

    // Comprehensive test for duplicate follower prevention
    window.testDuplicateFollowerFix = async function() {
      if (!currentUser) {
        console.log('❌ No current user logged in');
        return;
      }
      
      console.log('🧪 Comprehensive duplicate follower prevention test...');
      
      // Test 1: Check current state
      console.log('📊 Current follower state:');
      console.log('- Followers:', followerSystemState.currentUserFollowers);
      console.log('- Following:', followerSystemState.currentUserFollowing);
      console.log('- Operation in progress:', followerSystemState.isOperationInProgress);
      
      // Test 2: Check for duplicates in current state
      const followerDuplicates = followerSystemState.currentUserFollowers.filter((item, index) => followerSystemState.currentUserFollowers.indexOf(item) !== index);
      const followingDuplicates = followerSystemState.currentUserFollowing.filter((item, index) => followerSystemState.currentUserFollowing.indexOf(item) !== index);
      
      console.log('🔍 Duplicate check:');
      console.log('- Follower duplicates:', followerDuplicates);
      console.log('- Following duplicates:', followingDuplicates);
      
      // Test 3: Check UI button states
      const followButtons = document.querySelectorAll('button[onclick*="followUser"]');
      const unfollowButtons = document.querySelectorAll('button[onclick*="unfollowUser"]');
      console.log('🔘 UI Button check:');
      console.log('- Follow buttons:', followButtons.length);
      console.log('- Unfollow buttons:', unfollowButtons.length);
      
      // Test 4: Check if any buttons are disabled
      const disabledButtons = document.querySelectorAll('button[disabled]');
      console.log('- Disabled buttons:', disabledButtons.length);
      
      // Test 5: Verify counts match
      const followersCountEl = document.getElementById('followersCount');
      const followingCountEl = document.getElementById('followingCount');
      console.log('📈 Count verification:');
      console.log('- Followers count element:', followersCountEl ? followersCountEl.textContent : 'Not found');
      console.log('- Following count element:', followingCountEl ? followingCountEl.textContent : 'Not found');
      console.log('- Expected followers count:', followerSystemState.currentUserFollowers.length);
      console.log('- Expected following count:', followerSystemState.currentUserFollowing.length);
      
      // Test 6: Check database consistency
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const dbFollowers = userData.followers || [];
          const dbFollowing = userData.following || [];
          
          console.log('🗄️ Database consistency check:');
          console.log('- DB followers count:', dbFollowers.length);
          console.log('- DB following count:', dbFollowing.length);
          console.log('- Local followers count:', followerSystemState.currentUserFollowers.length);
          console.log('- Local following count:', followerSystemState.currentUserFollowing.length);
          
          const followersMatch = dbFollowers.length === followerSystemState.currentUserFollowers.length;
          const followingMatch = dbFollowing.length === followerSystemState.currentUserFollowing.length;
          
          console.log('- Followers match:', followersMatch);
          console.log('- Following match:', followingMatch);
        }
      } catch (error) {
        console.error('Error checking database consistency:', error);
      }
      
      console.log('✅ Comprehensive test completed');
      
      // Summary
      const hasDuplicates = followerDuplicates.length > 0 || followingDuplicates.length > 0;
      const hasDisabledButtons = disabledButtons.length > 0;
      
      if (hasDuplicates) {
        console.log('⚠️ ISSUES FOUND: Duplicates detected');
        window.createEnhancedNotification('Test Results', 'Duplicates found - run refreshFollowerState() to fix', 'warning');
      } else if (hasDisabledButtons) {
        console.log('⚠️ ISSUES FOUND: Buttons are disabled');
        window.createEnhancedNotification('Test Results', 'Buttons are disabled - operation in progress', 'info');
      } else {
        console.log('✅ NO ISSUES FOUND: System is working correctly');
        window.createEnhancedNotification('Test Results', 'No issues found - system is working correctly', 'success');
      }
    };

    async function clearRecentGames() {
      const user = auth.currentUser;
      if (!user) return;

      if (confirm('Are you sure you want to clear your entire game history? This action cannot be undone.')) {
        try {
          const userRef = db.collection('users').doc(user.uid);
          await userRef.update({
            history: []
          });
          
          // Refresh the recent games list
          renderGamesList('recentGamesList', [], 'recent games');
          
          // Show success message
          showTemporaryMessage('Game history cleared successfully!', 'success');
        } catch (error) {
          console.error('Error clearing game history:', error);
          showTemporaryMessage('Failed to clear game history. Please try again.', 'error');
        }
      }
    }

    function showTemporaryMessage(message, type = 'info') {
      const messageEl = document.createElement('div');
      messageEl.className = `fixed top-4 right-4 px-6 py-3 rounded-lg font-medium shadow-lg z-50 transition-all duration-300 transform translate-x-full`;
      
      if (type === 'success') {
        messageEl.className += ' bg-green-500 text-white';
      } else if (type === 'error') {
        messageEl.className += ' bg-red-500 text-white';
      } else {
        messageEl.className += ' bg-rp-foam text-rp-base';
      }
      
      messageEl.textContent = message;
      document.body.appendChild(messageEl);
      
      // Animate in
      setTimeout(() => {
        messageEl.classList.remove('translate-x-full');
      }, 100);
      
      // Animate out and remove
      setTimeout(() => {
        messageEl.classList.add('translate-x-full');
        setTimeout(() => {
          if (messageEl.parentNode) {
            document.body.removeChild(messageEl);
          }
        }, 300);
      }, 3000);
    }

    function renderUserSection(user) {
      const section = document.getElementById('userSection');
      if (!user) {
        section.innerHTML = '';
      } else {
        section.innerHTML = `
          <div class="flex items-center gap-3">
            <img src="${user.photoURL}" class="w-8 h-8 rounded-full ring-1 ring-rp-foam/30">
            <span class="text-rp-text font-medium">${user.displayName}</span>
          </div>
        `;
      }
    }

    function renderGamesList(listId, gameIds, label) {
      const listEl = document.getElementById(listId);
      if (!Array.isArray(gameIds) || gameIds.length === 0) {
        listEl.innerHTML = `<div class="text-rp-subtle text-sm italic py-4 text-center">No ${label} yet</div>`;
        return;
      }
      const seen = {};
      const uniqueIds = [];
      for (const id of gameIds) {
        if (!seen[id]) {
          seen[id] = true;
          uniqueIds.push(id);
        }
      }
      listEl.innerHTML = uniqueIds.map(id => {
        const game = gamesData.find(g => String(g.id) === String(id));
        if (!game) return '';
        return `
          <a href="play.html?id=${game.id}" class="group block bg-rp-surface border border-rp-overlay rounded-lg p-4 hover:border-rp-foam/50 transition-all duration-200">
            <div class="flex items-center gap-4">
              <div class="w-16 h-12 flex-shrink-0 rounded-lg overflow-hidden bg-rp-overlay">
                <img src="${game.image}" alt="${game.title}" class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300">
              </div>
              <div class="flex-1 min-w-0">
                <h3 class="font-medium text-rp-text truncate">${game.title}</h3>
                <p class="text-sm text-rp-subtle truncate">${game.description}</p>
                <div class="flex items-center gap-2 mt-1">
                  <span class="text-xs px-2 py-1 bg-rp-foam/20 text-rp-foam rounded">${game.category}</span>
                  ${game.featured ? '<span class="text-xs px-2 py-1 bg-rp-iris/20 text-rp-iris rounded">Featured</span>' : ''}
                </div>
              </div>
              <div class="flex items-center text-rp-foam group-hover:text-rp-foam/80 transition-colors">
                <i class='bx bx-play-circle text-xl'></i>
              </div>
            </div>
          </a>
        `;
      }).join('');
    }

    function getActivityDescription(activity) {
      const gameTitle = activity.data && activity.data.gameId 
        ? (gamesData.find(g => String(g.id) === String(activity.data.gameId))?.title || 'Unknown Game') 
        : '';
      switch (activity.action) {
        case 'play':
          return `Started playing ${gameTitle}`;
        case 'continue':
          return `Continued playing ${gameTitle}`;
        case 'random-play':
          return `Played random game: ${gameTitle}`;
        case 'search':
          return `Searched for "${activity.data.query || 'unknown'}"`;
        case 'pin':
          return `Pinned ${gameTitle}`;
        case 'unpin':
          return `Unpinned ${gameTitle}`;
        case 'page-view':
          return `Visited ${activity.data.page || 'unknown'} page`;
        case 'like':
          return `Liked ${gameTitle}`;
        case 'unlike':
          return `Unliked ${gameTitle}`;
        case 'favorite':
          return `Favorited ${gameTitle}`;
        case 'unfavorite':
          return `Unfavorited ${gameTitle}`;
        case 'comment':
          return `Commented on ${gameTitle}`;
        case 'reply':
          return `Replied to a comment on ${gameTitle}`;
        case 'rate':
          return `Rated ${gameTitle} ${activity.data.rating || 0} stars`;
        default:
          return 'Performed an action';
      }
    }

    function getActivityIcon(action) {
      switch (action) {
        case 'play':
        case 'continue':
        case 'random-play':
          return 'bx-play-circle';
        case 'search':
          return 'bx-search';
        case 'pin':
        case 'favorite':
          return 'bx-heart';
        case 'unpin':
        case 'unfavorite':
          return 'bx-heart';
        case 'page-view':
          return 'bx-globe';
        case 'like':
        case 'unlike':
          return 'bx-like';
        case 'comment':
        case 'reply':
          return 'bx-message-square-dots';
        case 'rate':
          return 'bx-star';
        default:
          return 'bx-activity';
      }
    }

    function getTimeAgo(timestamp) {
      if (!timestamp || !timestamp.toDate) return 'Just now';
      const now = Date.now();
      const diff = now - timestamp.toDate().getTime();
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      if (days > 0) return `${days}d ago`;
      if (hours > 0) return `${hours}h ago`;
      if (minutes > 0) return `${minutes}m ago`;
      return 'Just now';
    }

    function renderActivityFeed(activities, feedId = 'activityFeed') {
      // If feedId is not provided or is undefined, use default
      if (!feedId || feedId === 'undefined') {
        feedId = 'activityFeed';
      }
      
      const feed = document.getElementById(feedId);
      
      // If feed element doesn't exist, don't try to render
      if (!feed) {
        console.log('Activity feed element not found for feedId:', feedId, ', skipping render');
        return;
      }
      
      const loader = document.getElementById(feedId === 'activityFeed' ? 'activityLoader' : 'publicActivityLoader');
      const noActivity = document.getElementById(feedId === 'activityFeed' ? 'noActivity' : 'publicNoActivity');

      if (loader) loader.classList.add('hidden');
      if (!activities || activities.length === 0) {
        feed.innerHTML = '';
        if (noActivity) noActivity.classList.remove('hidden');
        return;
      }

      if (noActivity) noActivity.classList.add('hidden');
      feed.innerHTML = activities.map(activity => {
        if (!activity.action || !activity.timestamp) return '';
        const timeAgo = getTimeAgo(activity.timestamp);
        const description = getActivityDescription(activity);
        return `
          <div class="activity-item flex items-start gap-3 py-3 border-b border-rp-overlay last:border-0">
            <div class="w-8 h-8 rounded-full bg-rp-overlay flex items-center justify-center flex-shrink-0">
              <i class='bx ${getActivityIcon(activity.action)} text-rp-foam text-sm'></i>
            </div>
            <div class="flex-1 min-w-0">
              <p class="text-rp-text text-sm">${description}</p>
              <p class="text-rp-muted text-xs mt-1">${timeAgo}</p>
            </div>
          </div>
        `;
      }).filter(item => item).join('');
    }

    async function loadPublicActivityFeed(uid, feedId) {
      const loader = document.getElementById(feedId === 'activityFeed' ? 'activityLoader' : 'publicActivityLoader');
      const noActivity = document.getElementById(feedId === 'activityFeed' ? 'noActivity' : 'publicNoActivity');
      if (loader) loader.classList.remove('hidden');
      if (noActivity) noActivity.classList.add('hidden');

      try {
        const doc = await db.collection('user-activity').doc(uid).get();
        const activities = doc.exists ? (doc.data().activities || []).filter(activity => 
          activity.action && activity.timestamp
        ) : [];
        renderActivityFeed(activities.slice(-10).reverse(), feedId);
      } catch (error) {
        console.error('Error loading activity feed:', error);
        renderActivityFeed([], feedId);
      }
    }

    function getUidFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return params.get('uid');
    }

    async function showPublicProfile(uid) {
      await loadGamesData();
      const userProfile = await getUserPublicProfile(uid);
      if (!userProfile || !userProfile.displayName) {
        document.getElementById('publicProfileContent').innerHTML = `
          <div class="text-center py-16">
            <div class="bg-rp-surface rounded-xl p-8 border border-rp-overlay">
              <i class='bx bx-user-x text-4xl text-rp-muted mb-4'></i>
              <h2 class="text-xl font-semibold text-rp-text mb-2">User not found</h2>
              <p class="text-rp-subtle">This profile doesn't exist or has been removed.</p>
            </div>
          </div>
        `;
        document.getElementById('publicProfileContent').classList.remove('hidden');
        return;
      }
      document.getElementById('publicProfilePhoto').src = userProfile.photoURL;
      document.getElementById('publicProfileName').textContent = userProfile.displayName || "Unknown User";
      document.getElementById('publicProfileUsername').textContent = userProfile.username ? `@${userProfile.username}` : '';
      renderGamesList('publicRecentGamesList', (userProfile.history || []).slice().reverse(), 'recent games');
      renderGamesList('publicFavoriteGamesList', userProfile.favoriteGames, 'favorite games');
      renderGamesList('publicLikedGamesList', userProfile.likedGames, 'liked games');
      await loadPublicActivityFeed(uid, 'publicActivityFeed');
      
      // Setup friend actions if user is logged in
      if (currentUser && currentUser.uid !== uid) {
        await setupPublicProfileFriendActions(uid, userProfile);
      } else if (!currentUser) {
        // Show login prompt for non-logged in users
        const actionsContainer = document.getElementById('publicProfileActions');
        actionsContainer.innerHTML = `
          <div class="text-center p-4 bg-rp-overlay rounded-lg">
            <p class="text-rp-subtle mb-3">Sign in to add friends and message users</p>
            <button onclick="googleSignIn()" class="px-4 py-2 bg-rp-foam hover:bg-rp-foam/90 text-rp-base rounded-lg transition-colors">
              <i class='bx bxl-google mr-2'></i>
              Sign In with Google
            </button>
          </div>
        `;
        actionsContainer.classList.remove('hidden');
      }
      
      const url = `${window.location.origin}${window.location.pathname}?uid=${encodeURIComponent(uid)}`;
      const urlInput = document.getElementById('publicProfileUrl');
      urlInput.value = url;
      const copyBtn = document.getElementById('copyPublicProfileUrlBtn');
      const feedback = document.getElementById('copyPublicFeedback');
      copyBtn.onclick = function() {
        urlInput.select();
        urlInput.setSelectionRange(0, 99999);
        navigator.clipboard.writeText(urlInput.value).then(function() {
          feedback.style.opacity = 1;
          setTimeout(() => feedback.style.opacity = 0, 1200);
        });
      };
    }

    async function setupPublicProfileFriendActions(uid, userProfile) {
      const actionsContainer = document.getElementById('publicProfileActions');
      const addBtn = document.getElementById('addFriendBtn');
      const removeBtn = document.getElementById('removeFriendBtn');
      const chatBtn = document.getElementById('chatWithUserBtn');
      const statusEl = document.getElementById('friendshipStatus');
      
      actionsContainer.classList.remove('hidden');
      
      try {
        // Check current friendship status
        const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
        const currentUserData = currentUserDoc.data();
        const isFriend = currentUserData.friends && currentUserData.friends.includes(uid);
        
        // Check for pending requests
        const pendingOutgoing = await db.collection('friendRequests')
          .where('from', '==', currentUser.uid)
          .where('to', '==', uid)
          .where('status', '==', 'pending')
          .get();
        
        const pendingIncoming = await db.collection('friendRequests')
          .where('from', '==', uid)
          .where('to', '==', currentUser.uid)
          .where('status', '==', 'pending')
          .get();
        
        // Update UI based on status
        if (isFriend) {
          addBtn.classList.add('hidden');
          removeBtn.classList.remove('hidden');
          chatBtn.classList.remove('hidden');
          statusEl.textContent = 'You are friends';
          statusEl.className = 'text-center text-sm text-rp-foam mt-2';
          
          removeBtn.onclick = () => removeFriend(uid);
          chatBtn.onclick = () => startChat(uid, userProfile.displayName);
        } else if (!pendingOutgoing.empty) {
          addBtn.textContent = 'Request Sent';
          addBtn.disabled = true;
          addBtn.className = 'flex-1 px-4 py-2 bg-rp-subtle/20 text-rp-subtle rounded-lg text-sm flex items-center justify-center gap-2 cursor-not-allowed';
          statusEl.textContent = 'Friend request sent';
          statusEl.className = 'text-center text-sm text-rp-gold mt-2';
        } else if (!pendingIncoming.empty) {
          addBtn.textContent = 'Accept Request';
          addBtn.innerHTML = '<i class="bx bx-check"></i> Accept Request';
          statusEl.textContent = 'Has sent you a friend request';
          statusEl.className = 'text-center text-sm text-rp-iris mt-2';
          
          addBtn.onclick = () => acceptFriendRequest(pendingIncoming.docs[0].id, uid);
        } else {
          addBtn.onclick = () => sendFriendRequest(uid);
        }
        
      } catch (error) {
        console.error('Error setting up friend actions:', error);
        actionsContainer.classList.add('hidden');
      }
    }

    // Game tracking integration - call this when user starts playing a game
    async function trackGameStart(gameId) {
      if (!currentUser) return;
      
      try {
        await updateUserStatus('ingame', gameId);
        
        // Also track in activity
        const activityRef = db.collection('user-activity').doc(currentUser.uid);
        const activityData = {
          activities: firebase.firestore.FieldValue.arrayUnion({
            action: 'play',
            data: { gameId: gameId },
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          })
        };
        
        await activityRef.set(activityData, { merge: true });
        
      } catch (error) {
        console.error('Error tracking game start:', error);
      }
    }

    // Call this when user stops playing a game
    async function trackGameEnd() {
      if (!currentUser) return;
      
      try {
        await updateUserStatus('online', null);
      } catch (error) {
        console.error('Error tracking game end:', error);
      }
    }

    // Make game tracking functions globally available
    window.trackGameStart = trackGameStart;
    window.trackGameEnd = trackGameEnd;

    document.addEventListener('DOMContentLoaded', async () => {
      const publicUid = getUidFromUrl();
      if (publicUid) {
        document.getElementById('loginScreen').classList.add('hidden');
        document.getElementById('profileContent').classList.add('hidden');
        document.getElementById('publicProfileContent').classList.remove('hidden');
        await showPublicProfile(publicUid);
        return;
      }

      document.getElementById('profileContent').classList.add('hidden');
      document.getElementById('loginScreen').classList.remove('hidden');
      await loadGamesData();
      auth.onAuthStateChanged(async (user) => {
        renderUserSection(user);
        if (!user) {
          document.getElementById('loginScreen').classList.remove('hidden');
          document.getElementById('profileContent').classList.add('hidden');
          document.getElementById('publicProfileContent').classList.add('hidden');
          return;
        }
        await ensureUserDoc(user);
        document.getElementById('loginScreen').classList.add('hidden');
        document.getElementById('profileContent').classList.remove('hidden');
        document.getElementById('publicProfileContent').classList.add('hidden');
        document.getElementById('profilePhoto').src = user.photoURL;
        document.getElementById('profileName').textContent = user.displayName;
        document.getElementById('profileEmail').textContent = user.email;
        
        // Initialize friend system
        currentUser = user;
        
        // Load current user's full data including friends list
        try {
          const userDoc = await db.collection('users').doc(user.uid).get();
          if (userDoc.exists) {
            currentUser.userData = userDoc.data();
            console.log('✅ Loaded current user data:', currentUser.userData);
          }
        } catch (error) {
          console.error('❌ Error loading current user data:', error);
        }
        
        await restoreUserStatus();
        await loadFriends();
        await loadFriendRequests();
        await loadUserProfile();
        await loadCurrentUserStatus();
        await updateOnlineFriendsList();
        await loadFriendshipStreaks();
        await loadGameStatistics();
        await loadFriendLeaderboard();
        await loadStatusNote();
        
        // Initialize follower system
        await initializeFollowerSystem();
        
        // Load suggested users
        await loadSuggestedUsers();
        
        // Setup game activity notifications
        await setupGameActivityNotifications();
        
        // Set up periodic refresh of statistics (every 30 seconds)
        setInterval(async () => {
          await loadGameStatistics();
          await loadFriendLeaderboard();
        }, 30000);
        
        // Refresh statistics when page regains focus (user returns from playing)
        window.addEventListener('focus', async () => {
          console.log('🔄 Page regained focus, refreshing statistics');
          await loadGameStatistics();
          await loadFriendLeaderboard();
        });
        // Only load activity feed if elements exist
        if (document.getElementById('activityFeed')) {
          try {
            await loadActivityFeed();
          } catch (error) {
            console.log('Activity feed load failed, skipping:', error.message);
          }
        }
        initializeFriendSystemEvents();
        initializeGameStatsEvents();
        
        console.log('🎉 Friend system initialized successfully!');
        
        // Load background settings from Firebase
        await loadBackgroundFromFirebase(user.uid);
        
        const lists = await getUserGameLists(user.uid);
        renderGamesList('recentGamesList', (lists.history || []).slice().reverse(), 'recent games');
        renderGamesList('favoriteGamesList', lists.favoriteGames, 'favorite games');
        renderGamesList('likedGamesList', lists.likedGames, 'liked games');
        
        // Set up clear recent games button
        const clearBtn = document.getElementById('clearRecentGamesBtn');
        if (clearBtn) {
          clearBtn.onclick = clearRecentGames;
        }
        
        const url = `${window.location.origin}${window.location.pathname}?uid=${encodeURIComponent(user.uid)}`;
        const linkInput = document.getElementById('publicProfileLink');
        linkInput.value = url;
        const copyBtn = document.getElementById('copyProfileLinkBtn');
        const feedback = document.getElementById('copyFeedback');
        copyBtn.onclick = function() {
          linkInput.select();
          linkInput.setSelectionRange(0, 99999);
          navigator.clipboard.writeText(linkInput.value).then(function() {
            feedback.style.opacity = 1;
            setTimeout(() => feedback.style.opacity = 0, 1200);
          });
        };
      });
    });

    // THEME SYNC - Auto-syncs from settings.html via enhanced theme system
    // The carbon-theme.js handles theme application automatically from global storage
    
    // Listen for theme changes from settings page
    window.addEventListener('storage', (event) => {
      if (event.key === 'carbon-theme-global' && event.newValue) {
        // Theme changed in another tab/window - apply automatically
        if (window.carbonTheme) {
          window.carbonTheme.applyTheme(event.newValue);
        }
      }
    });
    
    // Listen for theme broadcast messages
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'carbon-theme-change') {
        // Theme changed in settings - apply automatically
        if (window.carbonTheme) {
          window.carbonTheme.applyTheme(event.data.theme);
        }
      }
    });

    // Initialize theme on load (carbon-theme.js handles this automatically)

    // Background Selection Functionality
    let currentBackground = 'gradient';
    const validBackgrounds = ['gradient', 'solid', 'pattern', 'particles', 'custom'];

    function initializeBackgroundSystem() {
      // Load saved background preference
      const savedBg = localStorage.getItem('carbon-background-global') || 'gradient';
      if (validBackgrounds.includes(savedBg)) {
        currentBackground = savedBg;
        updateBackgroundUI();
      }

      // Background selection event listeners
      document.querySelectorAll('.bg-preview').forEach(preview => {
        preview.addEventListener('click', () => {
          const bgType = preview.dataset.bg;
          if (bgType && validBackgrounds.includes(bgType)) {
            currentBackground = bgType;
            localStorage.setItem('carbon-background-global', bgType);
            updateBackgroundUI();
            saveBackgroundToFirebase();
          }
        });
      });

      // Custom background upload
      const bgUpload = document.getElementById('bg-upload');
      const bgFileInput = document.getElementById('bg-file-input');
      
      if (bgUpload && bgFileInput) {
        bgUpload.addEventListener('click', () => bgFileInput.click());
        bgUpload.addEventListener('dragover', (e) => {
          e.preventDefault();
          bgUpload.classList.add('bg-rp-highlight-med');
        });
        bgUpload.addEventListener('dragleave', () => {
          bgUpload.classList.remove('bg-rp-highlight-med');
        });
        bgUpload.addEventListener('drop', (e) => {
          e.preventDefault();
          bgUpload.classList.remove('bg-rp-highlight-med');
          const files = e.dataTransfer.files;
          if (files.length > 0) handleCustomBackground(files[0]);
        });
        
        bgFileInput.addEventListener('change', (e) => {
          if (e.target.files.length > 0) {
            handleCustomBackground(e.target.files[0]);
          }
        });
      }

      // Custom background remove/change buttons
      const removeBtn = document.getElementById('remove-bg');
      const changeBtn = document.getElementById('change-bg');
      
      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          localStorage.removeItem('carbon-custom-bg-global');
          document.getElementById('custom-bg-preview').classList.add('hidden');
          if (currentBackground === 'custom') {
            currentBackground = 'gradient';
            localStorage.setItem('carbon-background-global', 'gradient');
            updateBackgroundUI();
          }
          saveBackgroundToFirebase();
        });
      }
      
      if (changeBtn) {
        changeBtn.addEventListener('click', () => bgFileInput.click());
      }

      // Check for custom background on load
      const savedCustomBg = localStorage.getItem('carbon-custom-bg-global');
      if (savedCustomBg && currentBackground === 'custom') {
        showCustomBgPreview(savedCustomBg);
      }
    }

    function updateBackgroundUI() {
      // Update active states
      document.querySelectorAll('.bg-preview').forEach(el => {
        el.classList.remove('active', 'border-rp-foam');
        el.classList.add('border-transparent');
      });
      
      if (currentBackground !== 'custom') {
        const bgElement = document.querySelector(`[data-bg="${currentBackground}"]`);
        if (bgElement) {
          bgElement.classList.add('active', 'border-rp-foam');
          bgElement.classList.remove('border-transparent');
        }
      }
      
      applyBackground();
      updateBackgroundPreviews();
    }

    function updateBackgroundPreviews() {
      const gradientPreview = document.querySelector('[data-bg="gradient"]');
      const solidPreview = document.querySelector('[data-bg="solid"]');
      const patternPreview = document.querySelector('[data-bg="pattern"]');
      const particlesPreview = document.querySelector('[data-bg="particles"]');
      
      const baseColor = getComputedStyle(document.documentElement).getPropertyValue('--theme-base').trim();
      
      if (gradientPreview) gradientPreview.style.background = 'var(--theme-gradient)';
      if (solidPreview) solidPreview.style.background = baseColor;
      if (patternPreview) {
        patternPreview.style.background = `${baseColor} url('data:image/svg+xml,<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="2" fill="%23ffffff" fill-opacity="0.2"/></svg>') repeat`;
      }
      if (particlesPreview) particlesPreview.style.background = baseColor;
    }

    function applyBackground() {
      const body = document.body;
      const particlesCanvas = document.getElementById('particles-canvas');
      const baseColor = getComputedStyle(document.documentElement).getPropertyValue('--theme-base').trim();
      
      // Hide particles canvas by default
      if (particlesCanvas) particlesCanvas.classList.add('hidden');
      
      // Reset body background
      body.style.background = '';
      
      const customBg = localStorage.getItem('carbon-custom-bg-global');
      
      if (currentBackground === 'custom' && customBg) {
        body.style.background = `url(${customBg}) center/cover fixed`;
      } else {
        switch (currentBackground) {
          case 'solid':
            body.style.background = baseColor;
            break;
          case 'pattern':
            body.style.background = `${baseColor} url('data:image/svg+xml,<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="2" fill="%23ffffff" fill-opacity="0.2"/></svg>') repeat`;
            break;
          case 'particles':
            body.style.background = baseColor;
            if (particlesCanvas) {
              particlesCanvas.classList.remove('hidden');
              initParticles();
            }
            break;
          case 'gradient':
          default:
            body.style.background = 'var(--theme-gradient)';
            body.style.backgroundAttachment = 'fixed';
            break;
        }
      }
    }

    function handleCustomBackground(file) {
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target.result;
        localStorage.setItem('carbon-custom-bg-global', dataUrl);
        showCustomBgPreview(dataUrl);
        currentBackground = 'custom';
        localStorage.setItem('carbon-background-global', 'custom');
        updateBackgroundUI();
        saveBackgroundToFirebase();
      };
      reader.readAsDataURL(file);
    }

    function showCustomBgPreview(dataUrl) {
      const preview = document.getElementById('custom-bg-preview');
      const image = document.getElementById('bg-preview-image');
      if (preview && image) {
        image.style.backgroundImage = `url(${dataUrl})`;
        preview.classList.remove('hidden');
      }
    }

    function initParticles() {
      const canvas = document.getElementById('particles-canvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const particlesArray = [];
      const particleCount = 50;
      
      class Particle {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = (Math.random() - 0.5) * 2;
          this.radius = Math.random() * 3 + 1;
          this.opacity = Math.random() * 0.5 + 0.2;
        }
        
        update() {
          this.x += this.vx;
          this.y += this.vy;
          
          if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
          if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
        }
        
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(156, 207, 216, ${this.opacity})`;
          ctx.fill();
        }
      }
      
      function createParticles() {
        particlesArray.length = 0;
        for (let i = 0; i < particleCount; i++) {
          particlesArray.push(new Particle());
        }
      }
      
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        particlesArray.forEach(particle => {
          particle.update();
          particle.draw();
        });
        
        if (!canvas.classList.contains('hidden')) {
          requestAnimationFrame(animate);
        }
      }
      
      createParticles();
      animate();
      
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        createParticles();
      });
    }

    async function saveBackgroundToFirebase() {
      const user = firebase.auth().currentUser;
      if (!user) return;
      
      try {
        const settings = {
          background: currentBackground,
          customBackground: localStorage.getItem('carbon-custom-bg-global') || '',
        };
        await db.collection('users').doc(user.uid).set({ settings }, { merge: true });
      } catch (error) {
        console.error('Error saving background to Firebase:', error);
      }
    }

    async function loadBackgroundFromFirebase(uid) {
      try {
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const settings = userData.settings || {};
          
          if (settings.background && validBackgrounds.includes(settings.background)) {
            currentBackground = settings.background;
            localStorage.setItem('carbon-background-global', currentBackground);
          }
          
          if (settings.customBackground) {
            localStorage.setItem('carbon-custom-bg-global', settings.customBackground);
            if (currentBackground === 'custom') {
              showCustomBgPreview(settings.customBackground);
            }
          }
          
          updateBackgroundUI();
        }
      } catch (error) {
        console.error('Error loading background from Firebase:', error);
      }
    }

    // Initialize background system when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeBackgroundSystem, 100);
    });

    // Update background when theme changes
    window.addEventListener('storage', (event) => {
      if (event.key === 'carbon-background-global' && event.newValue) {
        currentBackground = event.newValue;
        updateBackgroundUI();
      }
    });

    // Profile Frame Update System
    function applyProfileFrame() {
      const selectedFrame = localStorage.getItem('carbon-selected-profile-frame');
      const profileElements = document.querySelectorAll('.carbon-profile-avatar, .user-avatar, .profile-avatar, [data-profile-avatar]');
      
      profileElements.forEach(element => {
        // Remove all existing profile frame classes
        ['red', 'blue', 'orange', 'green', 'purple', 'gold', 'silver', 'rainbow'].forEach(color => {
          element.classList.remove(`profile-frame-${color}`);
        });
        
        // Apply active frame class
        if (selectedFrame && selectedFrame !== 'default') {
          element.classList.add(`profile-frame-${selectedFrame}`);
        }
      });
    }

    // Listen for profile frame updates from parent window
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'carbon-profile-frame-update') {
        localStorage.setItem('carbon-selected-profile-frame', event.data.frameId);
        applyProfileFrame();
      }
    });

    // Apply active profile frame on page load
    setTimeout(() => {
      applyProfileFrame();
    }, 1000);

    // =============================================
    // FOLLOWER SYSTEM - Instagram-like follow functionality
    // =============================================
    // 
    // DUPLICATE FOLLOWER PREVENTION:
    // - Database level: Uses arrayUnion/arrayRemove to prevent duplicates
    // - Client level: Checks if already following before attempting to follow
    // - UI level: Disables buttons during operations to prevent rapid clicks
    // - Data loading: Deduplicates arrays when loading from database
    // - UI rendering: Deduplicates UIDs before rendering follower lists
    // - Cleanup: Automatically cleans up existing duplicates on initialization
    // - Global cleanup: Function to fix all users' duplicate followers
    //
    
    let followerSystemState = {
      currentUserFollowers: [],
      currentUserFollowing: [],
      viewingUserFollowers: [],
      viewingUserFollowing: [],
      privacySettings: {
        allowFollowersToSeeGames: true,
        allowFollowersToSeeNotes: true,
        allowFollowersToSeeActivity: true,
        allowFollowersToChat: true
      },
      isOperationInProgress: false // Flag to prevent multiple simultaneous operations
    };

    // Initialize follower system
    async function initializeFollowerSystem() {
      if (!currentUser) return;
      
      try {
        // Ensure user document has follower fields
        await ensureUserFollowerFields(currentUser.uid);
        
        // Clean up any existing duplicate data
        await cleanupDuplicateFollowers(currentUser.uid);
        
        // Load current user's follower data
        await loadFollowerData(currentUser.uid);
        
        // Load privacy settings
        await loadFollowerPrivacySettings();
        
        // Set up event listeners
        setupFollowerEventListeners();
        
        // Update UI
        updateFollowerCounts();
        
        console.log('✅ Follower system initialized');
      } catch (error) {
        console.error('❌ Error initializing follower system:', error);
      }
    }

    // Ensure user document has follower fields
    async function ensureUserFollowerFields(uid) {
      try {
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const updates = {};
          
          // Add missing follower fields
          if (!userData.hasOwnProperty('followers')) {
            updates.followers = [];
          }
          if (!userData.hasOwnProperty('following')) {
            updates.following = [];
          }
          if (!userData.hasOwnProperty('followersCount')) {
            updates.followersCount = 0;
          }
          if (!userData.hasOwnProperty('followingCount')) {
            updates.followingCount = 0;
          }
          
          // Update document if needed
          if (Object.keys(updates).length > 0) {
            await db.collection('users').doc(uid).update(updates);
            console.log('✅ Added missing follower fields to user document', updates);
          }
        } else {
          console.log('❌ User document does not exist for uid:', uid);
        }
      } catch (error) {
        console.error('Error ensuring user follower fields:', error);
      }
    }

    // Clean up duplicate followers in the database
    async function cleanupDuplicateFollowers(uid) {
      try {
        console.log('🧹 Cleaning up duplicate followers for user:', uid);
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const updates = {};
          
          // Deduplicate followers array
          if (userData.followers && Array.isArray(userData.followers)) {
            const uniqueFollowers = [...new Set(userData.followers)].filter(uid => uid && typeof uid === 'string');
            if (uniqueFollowers.length !== userData.followers.length) {
              updates.followers = uniqueFollowers;
              updates.followersCount = uniqueFollowers.length;
              console.log(`🧹 Cleaned up followers: ${userData.followers.length} → ${uniqueFollowers.length}`);
              
              // Log duplicate UIDs that were found
              const duplicates = userData.followers.filter((uid, index) => userData.followers.indexOf(uid) !== index);
              if (duplicates.length > 0) {
                console.log('🔍 Duplicate follower UIDs removed:', duplicates);
              }
            }
          }
          
          // Deduplicate following array
          if (userData.following && Array.isArray(userData.following)) {
            const uniqueFollowing = [...new Set(userData.following)].filter(uid => uid && typeof uid === 'string');
            if (uniqueFollowing.length !== userData.following.length) {
              updates.following = uniqueFollowing;
              updates.followingCount = uniqueFollowing.length;
              console.log(`🧹 Cleaned up following: ${userData.following.length} → ${uniqueFollowing.length}`);
              
              // Log duplicate UIDs that were found
              const duplicates = userData.following.filter((uid, index) => userData.following.indexOf(uid) !== index);
              if (duplicates.length > 0) {
                console.log('🔍 Duplicate following UIDs removed:', duplicates);
              }
            }
          }
          
          // Update document if cleanup was needed
          if (Object.keys(updates).length > 0) {
            await db.collection('users').doc(uid).update(updates);
            console.log('✅ Duplicate followers cleaned up successfully');
          } else {
            console.log('✅ No duplicate followers found');
          }
        }
      } catch (error) {
        console.error('Error cleaning up duplicate followers:', error);
      }
    }

    // Load follower data for a user
    async function loadFollowerData(uid) {
      try {
        console.log('🔍 Loading follower data for uid:', uid);
        const userDoc = await db.collection('users').doc(uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          console.log('📊 User data loaded:', userData);
          
          // Deduplicate arrays to prevent duplicate followers
          const deduplicateArray = (arr) => {
            if (!Array.isArray(arr)) return [];
            return [...new Set(arr)].filter(uid => uid && typeof uid === 'string');
          };
          
          if (uid === currentUser.uid) {
            // Load current user's data with deduplication
            followerSystemState.currentUserFollowers = deduplicateArray(userData.followers);
            followerSystemState.currentUserFollowing = deduplicateArray(userData.following);
            console.log('👤 Current user followers:', followerSystemState.currentUserFollowers);
            console.log('👤 Current user following:', followerSystemState.currentUserFollowing);
          } else {
            // Load viewing user's data with deduplication
            followerSystemState.viewingUserFollowers = deduplicateArray(userData.followers);
            followerSystemState.viewingUserFollowing = deduplicateArray(userData.following);
            console.log('👁️ Viewing user followers:', followerSystemState.viewingUserFollowers);
            console.log('👁️ Viewing user following:', followerSystemState.viewingUserFollowing);
          }
        } else {
          console.log('❌ User document does not exist for uid:', uid);
        }
      } catch (error) {
        console.error('Error loading follower data:', error);
      }
    }

    // Load privacy settings
    async function loadFollowerPrivacySettings() {
      if (!currentUser) return;
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          const privacy = userData.followerPrivacy || {};
          
          // Merge with defaults
          followerSystemState.privacySettings = {
            allowFollowersToSeeGames: privacy.allowFollowersToSeeGames !== false,
            allowFollowersToSeeNotes: privacy.allowFollowersToSeeNotes !== false,
            allowFollowersToSeeActivity: privacy.allowFollowersToSeeActivity !== false,
            allowFollowersToChat: privacy.allowFollowersToChat !== false
          };
          
          // Update UI checkboxes
          Object.keys(followerSystemState.privacySettings).forEach(key => {
            const checkbox = document.getElementById(key);
            if (checkbox) {
              checkbox.checked = followerSystemState.privacySettings[key];
            }
          });
        }
      } catch (error) {
        console.error('Error loading follower privacy settings:', error);
      }
    }

    // Save privacy settings
    async function saveFollowerPrivacySettings() {
      if (!currentUser) return;
      
      try {
        await db.collection('users').doc(currentUser.uid).update({
          followerPrivacy: followerSystemState.privacySettings
        });
        console.log('✅ Privacy settings saved');
      } catch (error) {
        console.error('❌ Error saving privacy settings:', error);
      }
    }

    // Follow a user
    async function followUser(targetUid) {
      if (!currentUser || targetUid === currentUser.uid) return;
      
      // Prevent multiple simultaneous operations
      if (followerSystemState.isOperationInProgress) {
        console.log('⚠️ Operation already in progress, ignoring follow request');
        return;
      }
      
      // Double-check against the database to ensure we're not already following
      try {
        const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
        if (currentUserDoc.exists) {
          const userData = currentUserDoc.data();
          const dbFollowing = userData.following || [];
          if (dbFollowing.includes(targetUid)) {
            console.log('⚠️ Database check: Already following user:', targetUid);
            // Update local state to match database
            followerSystemState.currentUserFollowing = [...new Set(dbFollowing)];
            window.createEnhancedNotification('Already Following', 'You are already following this user', 'info');
            updateAllFollowButtonStates();
            return;
          }
        }
      } catch (error) {
        console.error('Error checking follow status:', error);
      }
      
      // Check if already following to prevent duplicates (local state check)
      if (followerSystemState.currentUserFollowing.includes(targetUid)) {
        console.log('⚠️ Already following user:', targetUid);
        window.createEnhancedNotification('Already Following', 'You are already following this user', 'info');
        return;
      }
      
      // Set operation flag
      followerSystemState.isOperationInProgress = true;
      
      // Prevent multiple rapid clicks by disabling all follow buttons for this user
      const followButtons = document.querySelectorAll(`button[onclick*="followUser('${targetUid}')"]`);
      const specificFollowBtn = document.querySelector(`.follow-btn-${targetUid}`);
      
      // Disable all follow buttons for this user
      followButtons.forEach(btn => {
        btn.disabled = true;
        btn.textContent = 'Following...';
        btn.classList.add('opacity-50', 'cursor-not-allowed');
      });
      
      // Also disable the specific button if found
      if (specificFollowBtn) {
        specificFollowBtn.disabled = true;
        specificFollowBtn.textContent = 'Following...';
        specificFollowBtn.classList.add('opacity-50', 'cursor-not-allowed');
      }
      
      // Immediately remove the user from suggestions to prevent double-following
      const suggestionCard = document.querySelector(`.suggestion-card[data-user-id="${targetUid}"]`);
      if (suggestionCard) {
        suggestionCard.style.display = 'none';
      }
      
      try {
        console.log('📝 Starting to follow user:', targetUid);
        
        // Ensure both users have follower fields
        await ensureUserFollowerFields(currentUser.uid);
        await ensureUserFollowerFields(targetUid);
        
        // Use batch write for atomic operation
        const batch = db.batch();
        
        // Add to current user's following list
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        batch.update(currentUserRef, {
          following: firebase.firestore.FieldValue.arrayUnion(targetUid),
          followingCount: firebase.firestore.FieldValue.increment(1)
        });
        
        // Add to target user's followers list
        const targetUserRef = db.collection('users').doc(targetUid);
        batch.update(targetUserRef, {
          followers: firebase.firestore.FieldValue.arrayUnion(currentUser.uid),
          followersCount: firebase.firestore.FieldValue.increment(1)
        });
        
        // Create activity for the followed user
        const activityRef = db.collection('activities').doc();
        batch.set(activityRef, {
          type: 'follow',
          userId: targetUid,
          fromUserId: currentUser.uid,
          fromUserName: currentUser.displayName || 'Someone',
          fromUserAvatar: currentUser.photoURL || '',
          message: `${currentUser.displayName || 'Someone'} started following you`,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          read: false
        });
        
        await batch.commit();
        console.log('✅ Batch write completed successfully');
        
        // Reload current user's follower data from database to ensure consistency
        await loadFollowerData(currentUser.uid);
        console.log('📊 Reloaded following list from database:', followerSystemState.currentUserFollowing);
        
        // Update UI everywhere
        updateFollowButtons(targetUid, true);
        updateAllFollowButtonStates();
        updateFollowerCounts();
        
        // Refresh search results and friends list if they exist
        refreshSearchResults();
        refreshFriendsList();
        
        // Immediately hide the suggestion card for better UX
        const allSuggestionCards = document.querySelectorAll(`.suggestion-card[data-user-id="${targetUid}"]`);
        allSuggestionCards.forEach(card => {
          card.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
          card.style.opacity = '0';
          card.style.transform = 'scale(0.9)';
          setTimeout(() => card.remove(), 300);
        });
        
        // Force refresh suggested users to get new suggestions
        setTimeout(async () => {
          await forceRefreshSuggestedUsers();
        }, 400);
        
        // Show success notification
        const targetUserDoc = await db.collection('users').doc(targetUid).get();
        const targetUserName = targetUserDoc.exists ? targetUserDoc.data().displayName || 'User' : 'User';
        window.createEnhancedNotification('Following', `You are now following ${sanitizeText(targetUserName)}`, 'follow');
        
        console.log(`✅ Successfully followed user ${targetUid}`);
      } catch (error) {
        console.error('❌ Error following user:', error);
        showNotification('Follow Failed', 'Failed to follow user. Please try again.', 'error');
      } finally {
        // Reset operation flag and re-enable buttons
        followerSystemState.isOperationInProgress = false;
        
        // Re-enable all follow buttons for this user
        followButtons.forEach(btn => {
          btn.disabled = false;
          btn.textContent = 'Follow';
          btn.classList.remove('opacity-50', 'cursor-not-allowed');
        });
        
        // Also re-enable the specific button if found
        if (specificFollowBtn) {
          specificFollowBtn.disabled = false;
          specificFollowBtn.textContent = 'Follow';
          specificFollowBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }
        
        // Show the suggestion card again if the operation failed
        const suggestionCard = document.querySelector(`.suggestion-card[data-user-id="${targetUid}"]`);
        if (suggestionCard && !followerSystemState.currentUserFollowing.includes(targetUid)) {
          suggestionCard.style.display = 'flex';
        }
      }
    }

    // Unfollow a user
    async function unfollowUser(targetUid) {
      if (!currentUser || targetUid === currentUser.uid) return;
      
      // Prevent multiple simultaneous operations
      if (followerSystemState.isOperationInProgress) {
        console.log('⚠️ Operation already in progress, ignoring unfollow request');
        return;
      }
      
      // Check if actually following to prevent issues
      if (!followerSystemState.currentUserFollowing.includes(targetUid)) {
        console.log('⚠️ Not following user:', targetUid);
        window.createEnhancedNotification('Not Following', 'You are not following this user', 'info');
        return;
      }
      
      // Set operation flag
      followerSystemState.isOperationInProgress = true;
      
      // Prevent multiple rapid clicks by disabling all unfollow buttons for this user
      const unfollowButtons = document.querySelectorAll(`button[onclick*="unfollowUser('${targetUid}')"]`);
      unfollowButtons.forEach(btn => {
        btn.disabled = true;
        btn.textContent = 'Unfollowing...';
        btn.classList.add('opacity-50', 'cursor-not-allowed');
      });
      
      try {
        console.log('📝 Starting to unfollow user:', targetUid);
        
        // Ensure both users have follower fields
        await ensureUserFollowerFields(currentUser.uid);
        await ensureUserFollowerFields(targetUid);
        
        // Use batch write for atomic operation
        const batch = db.batch();
        
        // Remove from current user's following list
        const currentUserRef = db.collection('users').doc(currentUser.uid);
        batch.update(currentUserRef, {
          following: firebase.firestore.FieldValue.arrayRemove(targetUid),
          followingCount: firebase.firestore.FieldValue.increment(-1)
        });
        
        // Remove from target user's followers list
        const targetUserRef = db.collection('users').doc(targetUid);
        batch.update(targetUserRef, {
          followers: firebase.firestore.FieldValue.arrayRemove(currentUser.uid),
          followersCount: firebase.firestore.FieldValue.increment(-1)
        });
        
        await batch.commit();
        console.log('✅ Batch write completed successfully');
        
        // Reload current user's follower data from database to ensure consistency
        await loadFollowerData(currentUser.uid);
        console.log('📊 Reloaded following list from database:', followerSystemState.currentUserFollowing);
        
        // Update UI everywhere
        updateFollowButtons(targetUid, false);
        updateAllFollowButtonStates();
        updateFollowerCounts();
        
        // Refresh search results and friends list if they exist
        refreshSearchResults();
        refreshFriendsList();
        
        // Force refresh suggested users to potentially re-add the unfollowed user
        await forceRefreshSuggestedUsers();
        
        // Show success notification
        const targetUserDoc = await db.collection('users').doc(targetUid).get();
        const targetUserName = targetUserDoc.exists ? targetUserDoc.data().displayName || 'User' : 'User';
        window.createEnhancedNotification('Unfollowed', `You have unfollowed ${sanitizeText(targetUserName)}`, 'info');
        
        console.log(`✅ Successfully unfollowed user ${targetUid}`);
      } catch (error) {
        console.error('❌ Error unfollowing user:', error);
        showNotification('Unfollow Failed', 'Failed to unfollow user. Please try again.', 'error');
      } finally {
        // Reset operation flag and re-enable buttons
        followerSystemState.isOperationInProgress = false;
        unfollowButtons.forEach(btn => {
          btn.disabled = false;
          btn.textContent = 'Unfollow';
          btn.classList.remove('opacity-50', 'cursor-not-allowed');
        });
      }
    }

    // Update follow buttons state
    function updateFollowButtons(targetUid, isFollowing) {
      const followBtn = document.getElementById('followUserBtn');
      const unfollowBtn = document.getElementById('unfollowUserBtn');
      
      if (followBtn && unfollowBtn) {
        if (isFollowing) {
          followBtn.classList.add('hidden');
          unfollowBtn.classList.remove('hidden');
        } else {
          followBtn.classList.remove('hidden');
          unfollowBtn.classList.add('hidden');
        }
      }
    }

    // Update all follow button states across the entire page
    function updateAllFollowButtonStates() {
      console.log('🔄 Updating all follow button states...');
      
      // Update buttons in search results
      document.querySelectorAll('[data-user-id]').forEach(element => {
        const uid = element.getAttribute('data-user-id');
        if (uid && uid !== currentUser.uid) {
          const isFollowing = followerSystemState.currentUserFollowing.includes(uid);
          const followBtn = element.querySelector(`button[onclick*="followUser('${uid}')"]`);
          const unfollowBtn = element.querySelector(`button[onclick*="unfollowUser('${uid}')"]`);
          
          if (followBtn && unfollowBtn) {
            if (isFollowing) {
              followBtn.style.display = 'none';
              unfollowBtn.style.display = 'inline-flex';
              followBtn.textContent = 'Following';
              followBtn.className = followBtn.className.replace('bg-rp-iris', 'bg-rp-love/20').replace('text-white', 'text-rp-love');
            } else {
              followBtn.style.display = 'inline-flex';
              unfollowBtn.style.display = 'none';
              followBtn.textContent = 'Follow';
              followBtn.className = followBtn.className.replace('bg-rp-love/20', 'bg-rp-iris').replace('text-rp-love', 'text-white');
            }
          } else if (followBtn) {
            // Single button - update text and style
            if (isFollowing) {
              followBtn.textContent = 'Following';
              followBtn.className = followBtn.className.replace('bg-rp-iris', 'bg-rp-love/20').replace('text-white', 'text-rp-love');
              followBtn.setAttribute('onclick', `unfollowUser('${uid}')`);
            } else {
              followBtn.textContent = 'Follow';
              followBtn.className = followBtn.className.replace('bg-rp-love/20', 'bg-rp-iris').replace('text-rp-love', 'text-white');
              followBtn.setAttribute('onclick', `followUser('${uid}')`);
            }
          }
        }
      });
      
      // Also update the main profile follow buttons
      const mainFollowBtn = document.getElementById('followUserBtn');
      const mainUnfollowBtn = document.getElementById('unfollowUserBtn');
      const viewingUid = getUidFromUrl();
      
      if (mainFollowBtn && mainUnfollowBtn && viewingUid && viewingUid !== currentUser.uid) {
        const isFollowing = followerSystemState.currentUserFollowing.includes(viewingUid);
        if (isFollowing) {
          mainFollowBtn.classList.add('hidden');
          mainUnfollowBtn.classList.remove('hidden');
        } else {
          mainFollowBtn.classList.remove('hidden');
          mainUnfollowBtn.classList.add('hidden');
        }
      }
      
      console.log('✅ All follow button states updated');
    }

    // Update follower counts in UI
    function updateFollowerCounts() {
      const followersCount = document.getElementById('followersCount');
      const followingCount = document.getElementById('followingCount');
      const publicFollowersCount = document.getElementById('publicFollowersCount');
      const publicFollowingCount = document.getElementById('publicFollowingCount');
      
      if (followersCount) {
        followersCount.textContent = followerSystemState.currentUserFollowers.length;
      }
      if (followingCount) {
        followingCount.textContent = followerSystemState.currentUserFollowing.length;
      }
      if (publicFollowersCount) {
        publicFollowersCount.textContent = followerSystemState.viewingUserFollowers.length;
      }
      if (publicFollowingCount) {
        publicFollowingCount.textContent = followerSystemState.viewingUserFollowing.length;
      }
    }

    // Refresh search results to update follow button states
    function refreshSearchResults() {
      const searchInput = document.getElementById('userSearchInput');
      const searchResults = document.getElementById('searchResults');
      
      if (searchInput && searchResults && searchInput.value.trim()) {
        // Re-run the search with the current query to refresh button states
        const query = searchInput.value.trim();
        setTimeout(async () => {
          const results = await searchUsers(query);
          renderUserSearchResults(results);
        }, 100);
      }
    }

    // Refresh friends list to update follow button states
    function refreshFriendsList() {
      if (currentUser && currentUser.userData && currentUser.userData.friends) {
        setTimeout(async () => {
          const friendUids = currentUser.userData.friends || [];
          const friendsData = [];
          
          for (const friendUid of friendUids) {
            try {
              const friendDoc = await db.collection('users').doc(friendUid).get();
              if (friendDoc.exists) {
                friendsData.push({ uid: friendUid, ...friendDoc.data() });
              }
            } catch (error) {
              console.error('Error loading friend data:', error);
            }
          }
          
          await renderFriendsList(friendsData);
        }, 100);
      }
    }

    // Show followers/following modal
    async function showFollowersModal(type = 'followers', uid = null) {
      const modal = document.getElementById('followersModal');
      const title = document.getElementById('followersModalTitle');
      const followersTab = document.getElementById('followersTab');
      const followingTab = document.getElementById('followingTab');
      const followersList = document.getElementById('followersList');
      const followingList = document.getElementById('followingList');
      const followersTabCount = document.getElementById('followersTabCount');
      const followingTabCount = document.getElementById('followingTabCount');
      
      const targetUid = uid || currentUser.uid;
      console.log('🎯 Modal opening for:', { type, uid, targetUid, currentUserUid: currentUser.uid });
      
      // Load data if needed
      if (uid && uid !== currentUser.uid) {
        console.log('📥 Loading data for different user:', uid);
        await cleanupDuplicateFollowers(uid); // Clean up duplicates for viewed user
        await loadFollowerData(uid);
      } else {
        console.log('📥 Ensuring current user data is loaded');
        await loadFollowerData(currentUser.uid);
      }
      
      // Determine which data to use - simplified logic
      let followers, following;
      if (!uid || uid === currentUser.uid) {
        // Show current user's followers/following
        followers = followerSystemState.currentUserFollowers || [];
        following = followerSystemState.currentUserFollowing || [];
        console.log('📊 Using CURRENT USER data:', { followers: followers.length, following: following.length });
      } else {
        // Show another user's followers/following
        followers = followerSystemState.viewingUserFollowers || [];
        following = followerSystemState.viewingUserFollowing || [];
        console.log('📊 Using VIEWING USER data:', { followers: followers.length, following: following.length });
      }
      
      console.log('🔍 Final data for modal:', { type, followers, following });
      
      // Update counts
      followersTabCount.textContent = followers.length;
      followingTabCount.textContent = following.length;
      
      // Set active tab
      if (type === 'followers') {
        console.log('🔄 Setting up followers tab');
        title.textContent = 'Followers';
        followersTab.classList.add('bg-rp-foam/20', 'text-rp-foam', 'border-rp-foam/30');
        followersTab.classList.remove('bg-rp-highlight-med', 'text-rp-text');
        followingTab.classList.remove('bg-rp-foam/20', 'text-rp-foam', 'border-rp-foam/30');
        followingTab.classList.add('bg-rp-highlight-med', 'text-rp-text');
        
        // Show followers list, hide following list
        if (followersList) {
          followersList.classList.remove('hidden');
          console.log('✅ Followers list shown');
        } else {
          console.log('❌ Followers list element not found');
        }
        
        if (followingList) {
          followingList.classList.add('hidden');
          console.log('✅ Following list hidden');
        } else {
          console.log('❌ Following list element not found');
        }
        
        await renderFollowersList(followers, 'followers');
      } else {
        console.log('🔄 Setting up following tab');
        title.textContent = 'Following';
        followingTab.classList.add('bg-rp-foam/20', 'text-rp-foam', 'border-rp-foam/30');
        followingTab.classList.remove('bg-rp-highlight-med', 'text-rp-text');
        followersTab.classList.remove('bg-rp-foam/20', 'text-rp-foam', 'border-rp-foam/30');
        followersTab.classList.add('bg-rp-highlight-med', 'text-rp-text');
        
        // Show following list, hide followers list
        if (followingList) {
          followingList.classList.remove('hidden');
          console.log('✅ Following list shown');
        } else {
          console.log('❌ Following list element not found');
        }
        
        if (followersList) {
          followersList.classList.add('hidden');
          console.log('✅ Followers list hidden');
        } else {
          console.log('❌ Followers list element not found');
        }
        
        await renderFollowersList(following, 'following');
      }
      
      modal.classList.remove('hidden');
    }

    // Render followers/following list
    async function renderFollowersList(userIds, type) {
      console.log('🔄 Rendering followers list:', { userIds, type });
      
      const container = type === 'followers' ? 
        document.getElementById('followersList') : 
        document.getElementById('followingList');
      
      if (!container) {
        console.log('❌ Container not found:', type === 'followers' ? 'followersList' : 'followingList');
        return;
      }
      
      // Show loading state
      container.innerHTML = '<div class="text-center py-4"><div class="inline-block w-6 h-6 border-2 border-rp-foam border-t-transparent rounded-full animate-spin"></div><p class="text-rp-foam mt-2 text-sm">Loading users...</p></div>';
      
      if (!userIds || userIds.length === 0) {
        console.log('📭 No users to display');
        const emptyState = document.createElement('div');
        emptyState.className = 'text-center py-8 text-rp-subtle text-sm';
        emptyState.innerHTML = `
          <i class='bx bx-user${type === 'following' ? '-check' : ''} text-2xl mb-2 block'></i>
          ${type === 'followers' ? 'No followers yet' : 'Not following anyone yet'}
        `;
        container.innerHTML = '';
        container.appendChild(emptyState);
        return;
      }
      
      // Deduplicate UIDs to prevent duplicate rendering
      const uniqueUserIds = [...new Set(userIds)].filter(uid => uid && typeof uid === 'string');
      console.log(`📋 Loading ${uniqueUserIds.length} unique users for ${type} (original: ${userIds.length})`);
      
      // Clear container
      container.innerHTML = '';
      
      // Track users by displayName to prevent showing the same user twice
      const seenDisplayNames = new Map();
      
      // Load user data for each unique ID
      for (const uid of uniqueUserIds) {
        try {
          console.log(`👤 Loading user data for: ${uid}`);
          const userDoc = await db.collection('users').doc(uid).get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            console.log(`✅ User data loaded:`, userData);
            
            // Check if we've already shown a user with this display name
            const displayName = userData.displayName || 'Unknown User';
            if (seenDisplayNames.has(displayName)) {
              console.warn(`⚠️ Duplicate user detected: ${displayName} (${uid}) - already shown as ${seenDisplayNames.get(displayName)}`);
              continue; // Skip this duplicate
            }
            seenDisplayNames.set(displayName, uid);
            
            const userItem = createFollowerUserItem(userData, uid, type);
            container.appendChild(userItem);
          } else {
            console.log(`❌ User document not found for: ${uid}`);
          }
        } catch (error) {
          console.error('Error loading user data:', error);
        }
      }
      
      console.log(`✅ Finished rendering ${type} list`);
      console.log(`📊 Rendered ${container.children.length} users (from ${uniqueUserIds.length} UIDs)`);
    }

    // Create follower user item
    function createFollowerUserItem(userData, uid, listType) {
      console.log('🔨 Creating user item for:', { uid, userData, listType });
      
      const div = document.createElement('div');
      div.className = 'flex items-center justify-between p-3 bg-rp-overlay rounded-lg hover:bg-rp-highlight-med transition-colors';
      div.setAttribute('data-user-id', uid);
      
      const isCurrentUser = uid === currentUser.uid;
      const isFollowing = followerSystemState.currentUserFollowing.includes(uid);
      const isFollower = followerSystemState.currentUserFollowers.includes(uid);
      
      // Enhanced user info with status and game info
      let statusInfo = '';
      let gameInfo = '';
      
      // Show status if follower privacy allows it
      if (userData.status && userData.followerPrivacy?.allowFollowersToSeeGames !== false) {
        const statusColors = {
          online: '🟢',
          idle: '🟡',
          dnd: '🔴',
          offline: '⚫'
        };
        statusInfo = `<div class="text-xs text-rp-subtle">${statusColors[userData.status] || '⚫'} ${userData.status || 'offline'}</div>`;
      }
      
      // Show current game if available and allowed
      if (userData.currentGame && userData.followerPrivacy?.allowFollowersToSeeGames !== false) {
        gameInfo = `<div class="text-xs text-rp-gold">🎮 ${DOMPurify.sanitize(userData.currentGame)}</div>`;
      }
      
      // Better display name handling to prevent "Unknown User"
      let displayName = '';
      if (userData.displayName && userData.displayName.trim()) {
        displayName = userData.displayName.trim();
      } else if (userData.username && userData.username.trim()) {
        displayName = '@' + userData.username.trim();
      } else if (userData.email && userData.email.includes('@')) {
        const emailName = userData.email.split('@')[0];
        displayName = emailName.charAt(0).toUpperCase() + emailName.slice(1);
      } else {
        displayName = 'User ' + uid.substring(0, 6).toUpperCase();
      }
      
      const safeDisplayName = DOMPurify.sanitize(displayName);
      const safePhotoURL = DOMPurify.sanitize(userData.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(displayName) + '&background=6e6a86&color=e0def4');
      
      // Show more unique identifier information
      let userIdentifier = '';
      if (userData.username && userData.username.trim()) {
        userIdentifier = '@' + DOMPurify.sanitize(userData.username);
      } else if (userData.email && userData.email.includes('@')) {
        // Show partial email for identification
        const emailParts = userData.email.split('@');
        userIdentifier = emailParts[0].substring(0, 3) + '***@' + emailParts[1];
      } else {
        // Show partial UID as identifier
        userIdentifier = 'ID: ' + uid.substring(0, 8);
      }
      
      div.innerHTML = `
        <div class="flex items-center gap-3 flex-1 min-w-0">
          <img src="${safePhotoURL}" alt="Avatar" class="w-10 h-10 rounded-full carbon-profile-avatar">
          <div class="flex-1 min-w-0">
            <div class="font-medium text-rp-text truncate">${safeDisplayName}</div>
            <div class="text-xs text-rp-subtle truncate">${userIdentifier}</div>
            ${statusInfo}
            ${gameInfo}
          </div>
        </div>
        <div class="flex items-center gap-2">
          ${!isCurrentUser ? `
            ${isFollowing ? `
              <button onclick="unfollowUser('${uid}')" class="px-3 py-1 bg-rp-love/20 text-rp-love border border-rp-love/30 rounded text-xs hover:bg-rp-love/30 transition-colors">
                Unfollow
              </button>
            ` : `
              <button onclick="followUser('${uid}')" class="px-3 py-1 bg-rp-foam text-rp-base rounded text-xs hover:bg-rp-foam/90 transition-colors">
                Follow
              </button>
            `}
            <button onclick="window.open('?uid=${uid}', '_blank')" class="px-3 py-1 bg-rp-iris text-white rounded text-xs hover:bg-rp-iris/90 transition-colors">
              View
            </button>
          ` : `
            <span class="text-xs text-rp-subtle">You</span>
          `}
        </div>
      `;
      
      console.log('✅ User item created successfully');
      return div;
    }

    // Setup follower event listeners
    function setupFollowerEventListeners() {
      // View followers/following buttons
      const viewFollowersBtn = document.getElementById('viewFollowersBtn');
      const viewFollowingBtn = document.getElementById('viewFollowingBtn');
      
      if (viewFollowersBtn) {
        viewFollowersBtn.onclick = () => showFollowersModal('followers');
      }
      if (viewFollowingBtn) {
        viewFollowingBtn.onclick = () => showFollowersModal('following');
      }
      
      // Modal controls
      const closeFollowersModal = document.getElementById('closeFollowersModal');
      const followersTab = document.getElementById('followersTab');
      const followingTab = document.getElementById('followingTab');
      const followerSearchInput = document.getElementById('followerSearchInput');
      
      if (closeFollowersModal) {
        closeFollowersModal.onclick = () => {
          document.getElementById('followersModal').classList.add('hidden');
        };
      }
      
      if (followersTab) {
        followersTab.onclick = () => showFollowersModal('followers');
      }
      if (followingTab) {
        followingTab.onclick = () => showFollowersModal('following');
      }
      
      // Search functionality
      if (followerSearchInput) {
        followerSearchInput.addEventListener('input', debounce(searchFollowers, 300));
      }
      
      // Privacy settings
      const privacyCheckboxes = [
        'allowFollowersToSeeGames',
        'allowFollowersToSeeNotes', 
        'allowFollowersToSeeActivity',
        'allowFollowersToChat'
      ];
      
      privacyCheckboxes.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
          checkbox.addEventListener('change', (e) => {
            followerSystemState.privacySettings[id] = e.target.checked;
            saveFollowerPrivacySettings();
          });
        }
      });
      
      // Public profile follow buttons
      const followUserBtn = document.getElementById('followUserBtn');
      const unfollowUserBtn = document.getElementById('unfollowUserBtn');
      const viewFollowersListBtn = document.getElementById('viewFollowersListBtn');
      
      if (followUserBtn) {
        followUserBtn.onclick = () => {
          const uid = getUidFromUrl();
          if (uid) followUser(uid);
        };
      }
      if (unfollowUserBtn) {
        unfollowUserBtn.onclick = () => {
          const uid = getUidFromUrl();
          if (uid) unfollowUser(uid);
        };
      }
      if (viewFollowersListBtn) {
        viewFollowersListBtn.onclick = () => {
          const uid = getUidFromUrl();
          showFollowersModal('followers', uid);
        };
      }
    }

    // Search followers/following
    function searchFollowers() {
      const query = document.getElementById('followerSearchInput').value.toLowerCase();
      const activeList = document.querySelector('#followersList:not(.hidden), #followingList:not(.hidden)');
      
      if (!activeList) return;
      
      const items = activeList.querySelectorAll('[data-user-id]');
      items.forEach(item => {
        const userName = item.querySelector('.font-medium').textContent.toLowerCase();
        const username = item.querySelector('.text-xs').textContent.toLowerCase();
        
        if (userName.includes(query) || username.includes(query)) {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
    }

    // Enhanced public profile handling for followers
    async function enhancedShowPublicProfile(uid) {
      // Call the original function first
      await showPublicProfile(uid);
      
      // Load follower data for the viewed user
      await loadFollowerData(uid);
      
      // Update follower counts in public profile
      updateFollowerCounts();
      
      // Check if current user is following this user
      if (currentUser) {
        const isFollowing = followerSystemState.currentUserFollowing.includes(uid);
        updateFollowButtons(uid, isFollowing);
        
        // Update follow status text
        const followStatus = document.getElementById('followStatus');
        if (followStatus) {
          if (isFollowing) {
            followStatus.textContent = 'You are following this user';
          } else if (followerSystemState.viewingUserFollowers.includes(currentUser.uid)) {
            followStatus.textContent = 'This user follows you';
          } else {
            followStatus.textContent = '';
          }
        }
      }
    }

    // Utility function for debouncing
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Enhanced XSS Protection for follower content
    function sanitizeFollowerContent(content, maxLength = 200) {
      if (typeof content !== 'string') return '';
      
      // Basic sanitization
      const sanitized = DOMPurify.sanitize(content.trim());
      
      // Length limitation
      return sanitized.length > maxLength ? 
        sanitized.substring(0, maxLength) + '...' : 
        sanitized;
    }

    // ===== SUGGESTED USERS SYSTEM =====
    
    // Load suggested users to follow
    async function loadSuggestedUsers() {
      const suggestedUsersList = document.getElementById('suggestedUsersList');
      const noSuggestedUsers = document.getElementById('noSuggestedUsers');
      const suggestionsLoading = document.getElementById('suggestionsLoading');
      
      if (!currentUser || !suggestedUsersList) return;
      
      try {
        suggestionsLoading.classList.remove('hidden');
        noSuggestedUsers.classList.add('hidden');
        
        // Ensure we have the latest follower data
        await loadFollowerData(currentUser.uid);
        
        // Get suggestions based on various criteria
        const suggestions = await generateUserSuggestions();
        
        suggestionsLoading.classList.add('hidden');
        
        if (suggestions.length === 0) {
          // Check if we're following a lot of users already
          const followingCount = followerSystemState.currentUserFollowing.length;
          
          // Update the no suggestions message based on context
          if (followingCount > 10) {
            noSuggestedUsers.innerHTML = `
              <i class='bx bx-check-circle text-2xl mb-2 block text-rp-foam'></i>
              <p class="text-rp-text font-medium">You're all caught up!</p>
              <p class="text-rp-subtle text-xs mt-1">You're already following ${followingCount} users</p>
            `;
          } else {
            noSuggestedUsers.innerHTML = `
              <i class='bx bx-user-circle text-2xl mb-2 block'></i>
              <p class="text-rp-text">No suggestions available</p>
              <p class="text-rp-subtle text-xs mt-1">Check back later for new users to follow</p>
            `;
          }
          
          noSuggestedUsers.classList.remove('hidden');
          suggestedUsersList.innerHTML = '';
          return;
        }
        
        noSuggestedUsers.classList.add('hidden');
        renderSuggestedUsers(suggestions);
        
      } catch (error) {
        console.error('Error loading suggested users:', error);
        suggestionsLoading.classList.add('hidden');
        noSuggestedUsers.classList.remove('hidden');
      }
    }
    
    // Generate user suggestions based on various algorithms
    async function generateUserSuggestions() {
      const suggestions = [];
      
      try {
        // Get current user's fresh data from database
        const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
        const currentUserData = currentUserDoc.data() || {};
        const currentUserFriends = currentUserData.friends || [];
        
        // Get the absolute latest following data from database
        const dbFollowing = [...new Set(currentUserData.following || [])];
        
        // Update local state to match database
        followerSystemState.currentUserFollowing = dbFollowing;
        
        console.log('📊 Fresh data from database:');
        console.log('- Friends:', currentUserFriends.length);
        console.log('- Following:', dbFollowing.length);
        
        // Algorithm 1: Friends of friends
        const friendsOfFriends = await getFriendsOfFriends(currentUserFriends);
        suggestions.push(...friendsOfFriends);
        
        // Algorithm 2: Users with similar games
        const similarGameUsers = await getUsersWithSimilarGames(currentUserData);
        suggestions.push(...similarGameUsers);
        
        // Algorithm 3: Popular users (most followers)
        const popularUsers = await getPopularUsers();
        suggestions.push(...popularUsers);
        
        // Algorithm 4: Recently active users
        const activeUsers = await getRecentlyActiveUsers();
        suggestions.push(...activeUsers);
        
        // Remove duplicates, current user, friends, and already followed users
        console.log('🔍 Filtering suggestions...');
        console.log('Total suggestions before filtering:', suggestions.length);
        console.log('Current user friends:', currentUserFriends);
        console.log('Current user following (from DB):', dbFollowing);
        
        // Create a Set to track seen UIDs for better duplicate removal
        const seenUids = new Set();
        
        // Create Sets for faster lookup
        const friendsSet = new Set(currentUserFriends);
        const followingSet = new Set(dbFollowing);
        
        const uniqueSuggestions = suggestions
          .filter((user) => {
            // Must have a valid uid
            if (!user.uid || typeof user.uid !== 'string') return false;
            
            // Can't suggest current user
            if (user.uid === currentUser.uid) return false;
            
            // Can't suggest existing friends (use Set for O(1) lookup)
            if (friendsSet.has(user.uid)) return false;
            
            // Can't suggest users already being followed (use Set for O(1) lookup)
            if (followingSet.has(user.uid)) return false;
            
            // Remove duplicates using Set
            if (seenUids.has(user.uid)) return false;
            seenUids.add(user.uid);
            
            return true;
          })
          .slice(0, 5); // Limit to 5 suggestions
          
        console.log('Suggestions after filtering:', uniqueSuggestions.length);
        console.log('Filtered out:', suggestions.length - uniqueSuggestions.length, 'users');
        
        // Add suggestion reasons
        return uniqueSuggestions.map(user => ({
          ...user,
          reason: getSuggestionReason(user, currentUserData)
        }));
        
      } catch (error) {
        console.error('Error generating suggestions:', error);
        return [];
      }
    }
    
    // Get friends of friends
    async function getFriendsOfFriends(currentUserFriends) {
      const suggestions = [];
      
      try {
        for (const friendUid of currentUserFriends.slice(0, 3)) { // Limit to first 3 friends
          const friendDoc = await db.collection('users').doc(friendUid).get();
          if (friendDoc.exists) {
            const friendData = friendDoc.data();
            const friendsFriends = friendData.friends || [];
            
            for (const friendOfFriendUid of friendsFriends.slice(0, 2)) { // Max 2 per friend
              if (friendOfFriendUid !== currentUser.uid && !currentUserFriends.includes(friendOfFriendUid)) {
                const userDoc = await db.collection('users').doc(friendOfFriendUid).get();
                if (userDoc.exists) {
                  suggestions.push({
                    uid: friendOfFriendUid,
                    ...userDoc.data(),
                    suggestionType: 'mutual_friend',
                    mutualFriend: friendData.displayName
                  });
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('Error getting friends of friends:', error);
      }
      
      return suggestions;
    }
    
    // Get users with similar games
    async function getUsersWithSimilarGames(currentUserData) {
      const suggestions = [];
      
      try {
        const currentUserGames = [
          ...(currentUserData.favoriteGames || []),
          ...(currentUserData.likedGames || []),
          ...(currentUserData.history || []).slice(-10) // Recent 10 games
        ];
        
        if (currentUserGames.length === 0) return suggestions;
        
        // Find users who played similar games
        const usersQuery = await db.collection('users')
          .where('favoriteGames', 'array-contains-any', currentUserGames.slice(0, 5))
          .limit(10)
          .get();
        
        usersQuery.forEach(doc => {
          if (doc.id !== currentUser.uid) {
            suggestions.push({
              uid: doc.id,
              ...doc.data(),
              suggestionType: 'similar_games'
            });
          }
        });
        
      } catch (error) {
        console.error('Error getting users with similar games:', error);
      }
      
      return suggestions;
    }
    
    // Get popular users (most followers)
    async function getPopularUsers() {
      const suggestions = [];
      
      try {
        const popularQuery = await db.collection('users')
          .where('followersCount', '>=', 1)
          .orderBy('followersCount', 'desc')
          .limit(5)
          .get();
        
        popularQuery.forEach(doc => {
          if (doc.id !== currentUser.uid) {
            suggestions.push({
              uid: doc.id,
              ...doc.data(),
              suggestionType: 'popular'
            });
          }
        });
        
      } catch (error) {
        console.error('Error getting popular users:', error);
      }
      
      return suggestions;
    }
    
    // Get recently active users
    async function getRecentlyActiveUsers() {
      const suggestions = [];
      
      try {
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        
        const activeQuery = await db.collection('users')
          .where('lastSeen', '>=', firebase.firestore.Timestamp.fromDate(oneDayAgo))
          .orderBy('lastSeen', 'desc')
          .limit(10)
          .get();
        
        activeQuery.forEach(doc => {
          if (doc.id !== currentUser.uid) {
            suggestions.push({
              uid: doc.id,
              ...doc.data(),
              suggestionType: 'recently_active'
            });
          }
        });
        
      } catch (error) {
        console.error('Error getting recently active users:', error);
      }
      
      return suggestions;
    }
    
    // Get suggestion reason text
    function getSuggestionReason(user, currentUserData) {
      switch (user.suggestionType) {
        case 'mutual_friend':
          return `Friends with ${user.mutualFriend}`;
        case 'similar_games':
          return 'Plays similar games';
        case 'popular':
          return `${user.followersCount || 0} followers`;
        case 'recently_active':
          return 'Recently active';
        default:
          return 'Suggested for you';
      }
    }
    
    // Force refresh suggested users with latest follower data
    async function forceRefreshSuggestedUsers() {
      console.log('🔄 Force refreshing suggested users...');
      
      // Ensure we have the latest follower data
      await loadFollowerData(currentUser.uid);
      
      // Clear current suggestions
      const suggestedUsersList = document.getElementById('suggestedUsersList');
      if (suggestedUsersList) {
        suggestedUsersList.innerHTML = '';
      }
      
      // Reload suggestions with fresh data
      await loadSuggestedUsers();
      
      // Validate and clean up suggestions
      validateAndCleanupSuggestions();
      
      console.log('✅ Suggested users refreshed with latest follower data');
    }

    // Validate and clean up suggestions to ensure no duplicates or invalid data
    function validateAndCleanupSuggestions() {
      const suggestedUsersList = document.getElementById('suggestedUsersList');
      if (!suggestedUsersList) return;
      
      const suggestionCards = suggestedUsersList.querySelectorAll('.suggestion-card');
      const seenUids = new Set();
      const currentFollowing = followerSystemState.currentUserFollowing || [];
      
      console.log('🧹 Validating suggestions...');
      console.log('Current following:', currentFollowing);
      
      suggestionCards.forEach(card => {
        const uid = card.getAttribute('data-user-id');
        
        // Remove if no valid UID
        if (!uid) {
          console.log('❌ Removing card with no UID');
          card.remove();
          return;
        }
        
        // Remove if already following
        if (currentFollowing.includes(uid)) {
          console.log(`❌ Removing card for already followed user: ${uid}`);
          card.remove();
          return;
        }
        
        // Remove if duplicate
        if (seenUids.has(uid)) {
          console.log(`❌ Removing duplicate card for user: ${uid}`);
          card.remove();
          return;
        }
        
        seenUids.add(uid);
        
        // Validate display name
        const nameElement = card.querySelector('h4');
        if (nameElement && (nameElement.textContent === 'Unknown User' || !nameElement.textContent.trim())) {
          console.log(`⚠️ User ${uid} has no display name`);
        }
      });
      
      console.log(`✅ Validation complete. ${suggestionCards.length} valid suggestions remaining.`);
    }

    // Render suggested users list
    function renderSuggestedUsers(suggestions) {
      const suggestedUsersList = document.getElementById('suggestedUsersList');
      if (!suggestedUsersList) return;
      
      // Ensure we have the latest following data
      const currentFollowing = followerSystemState.currentUserFollowing || [];
      
      // Filter out any users that are already being followed (final check)
      const filteredSuggestions = suggestions.filter(user => {
        return user.uid && !currentFollowing.includes(user.uid);
      });
      
      // If all suggestions are filtered out, show no suggestions message
      if (filteredSuggestions.length === 0) {
        const noSuggestedUsers = document.getElementById('noSuggestedUsers');
        if (noSuggestedUsers) {
          const followingCount = currentFollowing.length;
          if (followingCount > 10) {
            noSuggestedUsers.innerHTML = `
              <i class='bx bx-check-circle text-2xl mb-2 block text-rp-foam'></i>
              <p class="text-rp-text font-medium">You're all caught up!</p>
              <p class="text-rp-subtle text-xs mt-1">You're already following ${followingCount} users</p>
            `;
          } else {
            noSuggestedUsers.innerHTML = `
              <i class='bx bx-user-circle text-2xl mb-2 block'></i>
              <p class="text-rp-text">No suggestions available</p>
              <p class="text-rp-subtle text-xs mt-1">Check back later for new users to follow</p>
            `;
          }
          noSuggestedUsers.classList.remove('hidden');
        }
        suggestedUsersList.innerHTML = '';
        return;
      }
      
      suggestedUsersList.innerHTML = filteredSuggestions.map(user => {
        // Better display name handling - prevent "Unknown User"
        let displayName = '';
        let isUnknownUser = false;
        
        if (user.displayName && user.displayName.trim()) {
          displayName = user.displayName.trim();
        } else if (user.username && user.username.trim()) {
          displayName = '@' + user.username.trim();
        } else if (user.email && user.email.includes('@')) {
          const emailName = user.email.split('@')[0];
          displayName = emailName.charAt(0).toUpperCase() + emailName.slice(1);
        } else {
          // Generate a friendly name from UID
          displayName = 'User ' + user.uid.substring(0, 6).toUpperCase();
          isUnknownUser = true;
        }
        
        const safeDisplayName = sanitizeText(displayName);
        const safeUsername = sanitizeText(user.username || '');
        const safePhotoURL = user.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(displayName) + '&background=6e6a86&color=e0def4';
        const safeUid = sanitizeText(user.uid || '');
        const safeReason = sanitizeText(user.reason || '');
        
        // Better username/identifier display logic
        let usernameDisplay = '';
        if (!isUnknownUser) {
          if (safeUsername && safeUsername.trim()) {
            usernameDisplay = '@' + safeUsername;
          } else if (user.email && user.email.includes('@')) {
            // Show domain for context
            const emailParts = user.email.split('@');
            usernameDisplay = emailParts[0].substring(0, 3) + '***@' + emailParts[1];
          } else {
            usernameDisplay = 'ID: ' + safeUid.substring(0, 8);
          }
        } else {
          // For unknown users, show more of the UID
          usernameDisplay = 'New user • ID: ' + safeUid.substring(0, 10);
        }
        
        // Check if already following this user (use latest data)
        const isFollowing = currentFollowing.includes(safeUid);
        
        // If already following, don't show this user in suggestions
        if (isFollowing) {
          return '';
        }
        
        return `
          <div class="flex items-center gap-4 p-4 bg-rp-overlay rounded-lg hover:bg-rp-highlight-med transition-colors suggestion-card" data-user-id="${safeUid}">
            <img src="${safePhotoURL}" 
                 alt="${safeDisplayName}" 
                 class="w-12 h-12 rounded-full ring-2 ring-rp-overlay group-hover:ring-rp-iris/50 transition-all">
            <div class="flex-1 min-w-0">
              <h4 class="font-semibold text-rp-text truncate text-consistent text-sm">${safeDisplayName}</h4>
              <p class="text-xs text-rp-subtle text-consistent mb-1">${usernameDisplay}</p>
              <p class="text-xs text-rp-iris text-consistent font-medium">${safeReason}</p>
            </div>
            <div class="flex flex-col gap-2 min-w-0">
              <button onclick="window.followUser('${safeUid}')" 
                      class="px-4 py-2 bg-rp-iris hover:bg-rp-iris/90 text-white rounded-lg text-xs font-medium transition-colors btn-enhanced flex items-center justify-center gap-2 whitespace-nowrap follow-btn-${safeUid}">
                <i class='bx bx-user-plus'></i>
                Follow
              </button>
              <button onclick="window.viewUserProfile('${safeUid}')" 
                      class="px-4 py-2 bg-rp-gold/20 text-rp-gold hover:bg-rp-gold/30 rounded-lg text-xs font-medium transition-colors btn-enhanced flex items-center justify-center gap-2 whitespace-nowrap">
                <i class='bx bx-show'></i>
                View
              </button>
            </div>
          </div>
        `;
      }).join('');
      
      // Remove any empty divs that resulted from filtered out users
      const emptyCards = suggestedUsersList.querySelectorAll('.suggestion-card:empty');
      emptyCards.forEach(card => card.remove());
    }

    // ===== ENHANCED GAMING NOTIFICATIONS =====
    
    // Track when friends start/stop playing games
    async function setupGameActivityNotifications() {
      if (!currentUser) return;
      
      try {
        // Get current user's friends
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data() || {};
        const friendUids = userData.friends || [];
        
        // Set up listeners for friends' game activity
        friendUids.forEach(friendUid => {
          db.collection('users').doc(friendUid).onSnapshot(doc => {
            if (doc.exists) {
              const friendData = doc.data();
              const previousData = window.friendsGameStatus?.[friendUid] || {};
              
              // Check if friend started playing a game
              if (friendData.status === 'ingame' && 
                  friendData.currentGame && 
                  previousData.status !== 'ingame') {
                
                const game = gamesData.find(g => String(g.id) === String(friendData.currentGame));
                if (game) {
                  window.createEnhancedNotification(
                    `🎮 ${friendData.displayName || 'A friend'}`,
                    `started playing ${game.title}`,
                    'game'
                  );
                }
              }
              
              // Store current status for next comparison
              if (!window.friendsGameStatus) window.friendsGameStatus = {};
              window.friendsGameStatus[friendUid] = {
                status: friendData.status,
                currentGame: friendData.currentGame
              };
            }
          });
        });
        
      } catch (error) {
        console.error('Error setting up game activity notifications:', error);
      }
    }
    
    // Show game activity notification
    function showGameActivityNotification(friendName, action, gameName, type = 'info') {
      // Create enhanced notification for game activity
      const notification = document.createElement('div');
      notification.className = 'fixed top-4 right-4 bg-rp-surface border border-rp-overlay rounded-lg p-4 shadow-lg z-50 transform translate-x-full transition-transform duration-300 max-w-sm';
      
      const iconClass = type === 'game-start' ? 'bx-game text-rp-gold' : 'bx-info-circle text-rp-foam';
      
      notification.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-8 h-8 rounded-full bg-rp-overlay flex items-center justify-center">
            <i class='bx ${iconClass}'></i>
          </div>
          <div class="flex-1">
            <p class="text-rp-text font-medium text-sm">🎮 ${sanitizeText(friendName)}</p>
            <p class="text-rp-subtle text-xs">${action} ${sanitizeText(gameName)}</p>
          </div>
          <button onclick="this.parentElement.parentElement.remove()" class="text-rp-subtle hover:text-rp-love transition-colors">
            <i class='bx bx-x'></i>
          </button>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.classList.remove('translate-x-full');
      }, 100);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.classList.add('translate-x-full');
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 300);
        }
      }, 5000);
    }

    // Initialize follower system when user is authenticated
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        currentUser = user;
        await initializeFollowerSystem();
      }
    });

    // Debug instructions for testing follower system
    console.log(`
    🔧 FOLLOWER SYSTEM DEBUG INSTRUCTIONS:
    
    1. Open browser console (F12)
    2. Make sure you're signed in with Google
    3. Test following:
       - Go to another user's public profile
       - Click "Follow" button
       - Check console for debug messages
    
    4. Test followers modal:
       - Click "View Followers" or "View Following"
       - Verify modal opens with correct data
    
    5. Test privacy settings:
       - Toggle privacy checkboxes
       - Verify settings are saved to Firebase
    
    6. To check Firebase data:
       - Run: console.log('Follower state:', followerSystemState)
       - Check users collection for followers/following arrays
    
    💡 Security features included:
    - XSS protection with DOMPurify
    - Input sanitization and length limits
    - Privacy controls for follower visibility
    - Safe HTML rendering
    `);

    // Debug instructions for testing friend requests
    console.log(`
    🔧 FRIEND SYSTEM DEBUG INSTRUCTIONS:
    
    1. Open browser console (F12)
    2. Make sure you're signed in with Google
    3. Run: window.testFriendSystem()
    4. To test friend requests:
       - Click "Find Friends" button
       - Search for another user
       - Click "Add Friend" button
       - Check console for debug messages
    
    5. To check Firebase data:
       - Run: console.log('Current user:', currentUser)
       - Check friendRequests collection in Firebase console
    
    6. Common issues:
       - Make sure Firebase has proper permissions
       - Check that both users exist in the users collection
       - Verify the friendRequests collection is created
    
    💡 If friend requests aren't working, check:
    - Browser console for error messages
    - Firebase console for data
    - Network tab for failed requests
    `);
  </script>
</body>
</html>
