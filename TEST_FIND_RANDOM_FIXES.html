<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find Random Player & Session Cleanup Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #191724;
            color: #e0def4;
        }
        .test-section {
            background: #1f1d2e;
            border: 1px solid #403d52;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .test-case {
            background: #26233a;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        .pass { color: #9ccfd8; }
        .fail { color: #eb6f92; }
        .warning { color: #f6c177; }
        button {
            background: #31748f;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #9ccfd8;
            color: #191724;
        }
        button:disabled {
            background: #6e6a86;
            cursor: not-allowed;
        }
        .log {
            background: #232136;
            color: #908caa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .status.pending { background: #f6c177; color: #191724; }
        .status.running { background: #31748f; color: white; }
        .status.passed { background: #9ccfd8; color: #191724; }
        .status.failed { background: #eb6f92; color: white; }
    </style>
</head>
<body>
    <h1>üß™ Find Random Player & Session Cleanup Test Suite</h1>
    <p>Comprehensive testing for the bug fixes implemented in the find random player functionality and session cleanup system.</p>

    <div class="test-section">
        <h2>üéØ Test Configuration</h2>
        <div>
            <label for="testUser">Test User ID: </label>
            <input type="text" id="testUser" value="test-user-123" style="background: #232136; color: #e0def4; border: 1px solid #403d52; padding: 5px; border-radius: 4px;">
        </div>
        <div style="margin-top: 10px;">
            <button onclick="initializeTestEnvironment()">Initialize Test Environment</button>
            <button onclick="runAllTests()">Run All Tests</button>
            <button onclick="clearTestResults()">Clear Results</button>
        </div>
    </div>

    <div class="test-section">
        <h2>üîç Test 1: Find Random Player Validation</h2>
        <div class="test-case">
            <h3>1.1 Debouncing Protection <span id="test-1-1-status" class="status pending">PENDING</span></h3>
            <p>Tests that rapid clicking of find random player is properly debounced.</p>
            <button onclick="testRapidClicking()">Test Rapid Clicking</button>
            <div id="test-1-1-log" class="log"></div>
        </div>
        
        <div class="test-case">
            <h3>1.2 Stale Room Detection <span id="test-1-2-status" class="status pending">PENDING</span></h3>
            <p>Tests that only fresh, valid rooms are found and joined.</p>
            <button onclick="testStaleRoomDetection()">Test Stale Room Detection</button>
            <div id="test-1-2-log" class="log"></div>
        </div>
        
        <div class="test-case">
            <h3>1.3 Room Validation <span id="test-1-3-status" class="status pending">PENDING</span></h3>
            <p>Tests double-validation of rooms before joining.</p>
            <button onclick="testRoomValidation()">Test Room Validation</button>
            <div id="test-1-3-log" class="log"></div>
        </div>
    </div>

    <div class="test-section">
        <h2>üßπ Test 2: Session Cleanup</h2>
        <div class="test-case">
            <h3>2.1 Disconnect Handler Management <span id="test-2-1-status" class="status pending">PENDING</span></h3>
            <p>Tests that disconnect handlers are properly managed without conflicts.</p>
            <button onclick="testDisconnectHandlers()">Test Disconnect Handlers</button>
            <div id="test-2-1-log" class="log"></div>
        </div>
        
        <div class="test-case">
            <h3>2.2 Memory Leak Prevention <span id="test-2-2-status" class="status pending">PENDING</span></h3>
            <p>Tests that listeners and resources are properly cleaned up.</p>
            <button onclick="testMemoryLeaks()">Test Memory Leak Prevention</button>
            <div id="test-2-2-log" class="log"></div>
        </div>
        
        <div class="test-case">
            <h3>2.3 Race Condition Prevention <span id="test-2-3-status" class="status pending">PENDING</span></h3>
            <p>Tests that multiple leave operations don't conflict.</p>
            <button onclick="testRaceConditions()">Test Race Conditions</button>
            <div id="test-2-3-log" class="log"></div>
        </div>
    </div>

    <div class="test-section">
        <h2>‚ö° Test 3: Error Recovery</h2>
        <div class="test-case">
            <h3>3.1 Network Error Handling <span id="test-3-1-status" class="status pending">PENDING</span></h3>
            <p>Tests recovery from network failures during room finding.</p>
            <button onclick="testNetworkErrors()">Test Network Error Recovery</button>
            <div id="test-3-1-log" class="log"></div>
        </div>
        
        <div class="test-case">
            <h3>3.2 Orphaned Room Cleanup <span id="test-3-2-status" class="status pending">PENDING</span></h3>
            <p>Tests that orphaned rooms are properly cleaned up.</p>
            <button onclick="testOrphanedRoomCleanup()">Test Orphaned Room Cleanup</button>
            <div id="test-3-2-log" class="log"></div>
        </div>
    </div>

    <div class="test-section">
        <h2>üìä Test Results Summary</h2>
        <div id="test-summary">
            <p>No tests run yet.</p>
        </div>
    </div>

    <script>
        // Mock implementations for testing
        let testResults = {};
        let mockCurrentUser = { uid: 'test-user-123', displayName: 'Test User' };
        let mockCurrentRoom = null;
        let mockGameListener = null;
        let mockActiveDisconnectHandlers = new Set();
        let mockFindRandomInProgress = false;
        let mockLastFindRandomAttempt = 0;

        // Mock Firebase Realtime Database
        const mockRealtimeDb = {
            ref: (path) => ({
                orderByChild: (child) => ({
                    equalTo: (value) => ({
                        limitToFirst: (limit) => ({
                            once: (event) => Promise.resolve({
                                exists: () => Math.random() > 0.5,
                                val: () => ({
                                    'room1': { 
                                        status: 'waiting', 
                                        hostId: 'other-user', 
                                        guestId: null,
                                        lastActivity: Date.now() - (2 * 60 * 1000),
                                        gameType: 'pong'
                                    },
                                    'room2': { 
                                        status: 'waiting', 
                                        hostId: 'another-user', 
                                        guestId: null,
                                        lastActivity: Date.now() - (10 * 60 * 1000), // Stale
                                        gameType: 'reaction'
                                    }
                                })
                            })
                        }),
                        once: (event) => Promise.resolve({
                            exists: () => true,
                            val: () => ({ status: 'waiting', guestId: null, hostId: 'other-user' })
                        })
                    })
                }),
                once: (event) => Promise.resolve({
                    exists: () => true,
                    val: () => ({ status: 'waiting', guestId: null })
                }),
                update: (data) => Promise.resolve(),
                remove: () => Promise.resolve(),
                set: (data) => Promise.resolve(),
                onDisconnect: () => ({
                    update: (data) => Promise.resolve(),
                    cancel: () => Promise.resolve()
                }),
                on: (event, callback) => {
                    setTimeout(() => callback({ exists: () => true, val: () => ({}) }), 100);
                    return () => {};
                },
                off: () => {}
            })
        };

        function log(testId, message, type = 'info') {
            const logElement = document.getElementById(`test-${testId}-log`);
            if (logElement) {
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
                logElement.textContent += `${timestamp} ${prefix} ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }
        }

        function setTestStatus(testId, status) {
            const statusElement = document.getElementById(`test-${testId}-status`);
            if (statusElement) {
                statusElement.textContent = status.toUpperCase();
                statusElement.className = `status ${status}`;
            }
            testResults[testId] = status;
            updateTestSummary();
        }

        function updateTestSummary() {
            const summary = document.getElementById('test-summary');
            const total = Object.keys(testResults).length;
            const passed = Object.values(testResults).filter(r => r === 'passed').length;
            const failed = Object.values(testResults).filter(r => r === 'failed').length;
            const running = Object.values(testResults).filter(r => r === 'running').length;
            
            summary.innerHTML = `
                <p><strong>Tests Run:</strong> ${total}</p>
                <p><span class="pass">‚úÖ Passed:</span> ${passed}</p>
                <p><span class="fail">‚ùå Failed:</span> ${failed}</p>
                <p><span class="warning">üîÑ Running:</span> ${running}</p>
                <p><strong>Success Rate:</strong> ${total > 0 ? Math.round((passed / total) * 100) : 0}%</p>
            `;
        }

        // Test implementations
        async function testRapidClicking() {
            const testId = '1-1';
            setTestStatus(testId, 'running');
            log(testId, 'Starting rapid clicking test...');
            
            try {
                // Simulate the findRandomOpponent function with debouncing
                let callCount = 0;
                const mockFindRandom = async () => {
                    const now = Date.now();
                    if (mockFindRandomInProgress) {
                        log(testId, `Call ${++callCount}: Blocked (already in progress)`, 'info');
                        return false;
                    }
                    
                    if (now - mockLastFindRandomAttempt < 2000) {
                        log(testId, `Call ${++callCount}: Blocked (too soon)`, 'info');
                        return false;
                    }
                    
                    mockFindRandomInProgress = true;
                    mockLastFindRandomAttempt = now;
                    log(testId, `Call ${++callCount}: Accepted`, 'success');
                    
                    setTimeout(() => {
                        mockFindRandomInProgress = false;
                    }, 1000);
                    
                    return true;
                };
                
                // Rapid fire 5 calls
                const results = await Promise.all([
                    mockFindRandom(),
                    mockFindRandom(),
                    mockFindRandom(),
                    mockFindRandom(),
                    mockFindRandom()
                ]);
                
                const acceptedCalls = results.filter(r => r).length;
                
                if (acceptedCalls === 1) {
                    log(testId, `‚úÖ Debouncing works: Only 1 of 5 rapid calls accepted`, 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, `‚ùå Debouncing failed: ${acceptedCalls} calls accepted`, 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testStaleRoomDetection() {
            const testId = '1-2';
            setTestStatus(testId, 'running');
            log(testId, 'Starting stale room detection test...');
            
            try {
                // Mock room finding with staleness check
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                const mockRooms = {
                    'fresh-room': { 
                        status: 'waiting', 
                        hostId: 'other-user', 
                        guestId: null,
                        lastActivity: Date.now() - (2 * 60 * 1000) // Fresh
                    },
                    'stale-room': { 
                        status: 'waiting', 
                        hostId: 'another-user', 
                        guestId: null,
                        lastActivity: Date.now() - (10 * 60 * 1000) // Stale
                    }
                };
                
                const validRooms = Object.entries(mockRooms).filter(([id, room]) => 
                    room.lastActivity > fiveMinutesAgo
                );
                
                log(testId, `Found ${Object.keys(mockRooms).length} total rooms`);
                log(testId, `Filtered to ${validRooms.length} fresh rooms`);
                
                if (validRooms.length === 1 && validRooms[0][0] === 'fresh-room') {
                    log(testId, '‚úÖ Stale room detection working correctly', 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, '‚ùå Stale room detection failed', 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testRoomValidation() {
            const testId = '1-3';
            setTestStatus(testId, 'running');
            log(testId, 'Starting room validation test...');
            
            try {
                // Simulate double validation
                const roomId = 'test-room';
                
                // First check
                log(testId, 'Performing initial room search...');
                const initialRoom = { status: 'waiting', guestId: null, hostId: 'other-user' };
                
                // Second validation
                log(testId, 'Performing validation check...');
                const validationRoom = await mockRealtimeDb.ref(`game-rooms/${roomId}`).once('value');
                
                if (validationRoom.exists()) {
                    const roomData = validationRoom.val();
                    if (roomData.status === 'waiting' && !roomData.guestId) {
                        log(testId, '‚úÖ Room validation passed', 'success');
                        setTestStatus(testId, 'passed');
                    } else {
                        log(testId, '‚ùå Room validation failed - room state changed', 'error');
                        setTestStatus(testId, 'failed');
                    }
                } else {
                    log(testId, '‚ùå Room validation failed - room disappeared', 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testDisconnectHandlers() {
            const testId = '2-1';
            setTestStatus(testId, 'running');
            log(testId, 'Starting disconnect handler test...');
            
            try {
                // Simulate setting up disconnect handlers
                const roomId = 'test-room';
                
                // Clean up existing handlers
                log(testId, `Cleaning up ${mockActiveDisconnectHandlers.size} existing handlers`);
                mockActiveDisconnectHandlers.clear();
                
                // Set up new handlers
                const handler1 = { ref: mockRealtimeDb.ref(`game-rooms/${roomId}`), roomId, type: 'regular' };
                mockActiveDisconnectHandlers.add(handler1);
                log(testId, 'Set up disconnect handler');
                
                // Verify handler tracking
                if (mockActiveDisconnectHandlers.size === 1) {
                    log(testId, '‚úÖ Disconnect handlers properly tracked', 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, '‚ùå Disconnect handler tracking failed', 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testMemoryLeaks() {
            const testId = '2-2';
            setTestStatus(testId, 'running');
            log(testId, 'Starting memory leak test...');
            
            try {
                // Simulate listener setup and cleanup
                let listenerCount = 0;
                
                const mockSetupListeners = () => {
                    listenerCount += 3; // Room, physics, players
                    log(testId, `Set up listeners (total: ${listenerCount})`);
                };
                
                const mockCleanupListeners = () => {
                    listenerCount = 0;
                    log(testId, `Cleaned up all listeners (total: ${listenerCount})`);
                };
                
                // Setup listeners
                mockSetupListeners();
                
                // Setup again (should cleanup first)
                mockCleanupListeners();
                mockSetupListeners();
                
                // Final cleanup
                mockCleanupListeners();
                
                if (listenerCount === 0) {
                    log(testId, '‚úÖ Memory leak prevention working', 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, `‚ùå Memory leak detected: ${listenerCount} listeners remain`, 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testRaceConditions() {
            const testId = '2-3';
            setTestStatus(testId, 'running');
            log(testId, 'Starting race condition test...');
            
            try {
                let leavingInProgress = false;
                let leaveCallCount = 0;
                
                const mockLeaveRoom = async () => {
                    leaveCallCount++;
                    log(testId, `Leave call #${leaveCallCount}`);
                    
                    if (leavingInProgress) {
                        log(testId, `Leave call #${leaveCallCount}: Blocked (already leaving)`);
                        return false;
                    }
                    
                    leavingInProgress = true;
                    log(testId, `Leave call #${leaveCallCount}: Processing`);
                    
                    // Simulate async work
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    leavingInProgress = false;
                    log(testId, `Leave call #${leaveCallCount}: Complete`);
                    return true;
                };
                
                // Simultaneous leave calls
                const results = await Promise.all([
                    mockLeaveRoom(),
                    mockLeaveRoom(),
                    mockLeaveRoom()
                ]);
                
                const successfulLeaves = results.filter(r => r).length;
                
                if (successfulLeaves === 1) {
                    log(testId, '‚úÖ Race condition prevention working', 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, `‚ùå Race condition detected: ${successfulLeaves} simultaneous leaves`, 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testNetworkErrors() {
            const testId = '3-1';
            setTestStatus(testId, 'running');
            log(testId, 'Starting network error test...');
            
            try {
                // Simulate network error during room finding
                const mockFindWithError = async () => {
                    try {
                        throw new Error('Network timeout');
                    } catch (error) {
                        log(testId, `Network error caught: ${error.message}`);
                        log(testId, 'Attempting recovery...');
                        
                        // Recovery logic
                        mockCurrentRoom = null;
                        return { recovered: true };
                    }
                };
                
                const result = await mockFindWithError();
                
                if (result && result.recovered) {
                    log(testId, '‚úÖ Network error recovery working', 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, '‚ùå Network error recovery failed', 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        async function testOrphanedRoomCleanup() {
            const testId = '3-2';
            setTestStatus(testId, 'running');
            log(testId, 'Starting orphaned room cleanup test...');
            
            try {
                // Simulate orphaned room detection and cleanup
                const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
                const mockOrphanedRooms = {
                    'orphan1': { status: 'completed', lastActivity: tenMinutesAgo - 1000 },
                    'orphan2': { status: 'waiting', lastActivity: tenMinutesAgo - 2000 },
                    'active1': { status: 'playing', lastActivity: Date.now() - 1000 }
                };
                
                log(testId, `Found ${Object.keys(mockOrphanedRooms).length} rooms`);
                
                // Simulate cleanup
                const toCleanup = Object.entries(mockOrphanedRooms).filter(([id, room]) => 
                    room.lastActivity < tenMinutesAgo
                );
                
                log(testId, `Cleaning up ${toCleanup.length} orphaned rooms`);
                
                if (toCleanup.length === 2) {
                    log(testId, '‚úÖ Orphaned room cleanup working correctly', 'success');
                    setTestStatus(testId, 'passed');
                } else {
                    log(testId, `‚ùå Orphaned room cleanup failed: expected 2, got ${toCleanup.length}`, 'error');
                    setTestStatus(testId, 'failed');
                }
                
            } catch (error) {
                log(testId, `‚ùå Test error: ${error.message}`, 'error');
                setTestStatus(testId, 'failed');
            }
        }

        function initializeTestEnvironment() {
            console.log('üöÄ Initializing test environment...');
            testResults = {};
            updateTestSummary();
            
            // Reset mock state
            mockCurrentRoom = null;
            mockGameListener = null;
            mockActiveDisconnectHandlers.clear();
            mockFindRandomInProgress = false;
            mockLastFindRandomAttempt = 0;
            
            console.log('‚úÖ Test environment ready');
        }

        async function runAllTests() {
            console.log('üèÉ Running all tests...');
            
            await testRapidClicking();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testStaleRoomDetection();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testRoomValidation();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testDisconnectHandlers();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testMemoryLeaks();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testRaceConditions();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testNetworkErrors();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testOrphanedRoomCleanup();
            
            console.log('üèÅ All tests complete');
        }

        function clearTestResults() {
            testResults = {};
            updateTestSummary();
            
            // Clear all logs
            document.querySelectorAll('.log').forEach(log => log.textContent = '');
            
            // Reset all statuses
            document.querySelectorAll('.status').forEach(status => {
                status.textContent = 'PENDING';
                status.className = 'status pending';
            });
        }

        // Initialize on page load
        window.addEventListener('load', initializeTestEnvironment);
    </script>
</body>
</html>