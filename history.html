<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>History - Carbon</title>
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    
    <script defer async>
      function setConfig() {
        tailwind.config = {
          theme: {
            extend: {
              fontFamily: {
                display: ["Switzer", "Helvetica", "sans-serif"],
                inter: ["Inter", "sans-serif"],
              },
              colors: {
                base: "#191724",
                surface: "#1f1d2e",
                overlay: "#26233a",
                muted: "#6e6a86",
                subtle: "#908caa",
                text: "#e0def4",
                love: "#eb6f92",
                gold: "#f6c177",
                rose: "#ebbcba",
                pine: "#31748f",
                foam: "#9ccfd8",
                iris: "#c4a7e7",
                "highlight-low": "#21202e",
                "highlight-med": "#403d52",
                "highlight-high": "#524f67",
              },
            },
          },
        };
      }
    </script>

    <link rel="preconnect" href="https://unpkg.com" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://cdn.tailwindcss.com" />
    <script
      defer
      async
      src="https://cdn.tailwindcss.com"
      onload="setConfig()"
    ></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet" />

    <style>
      .history-item {
        background: #1f1d2e;
        border: 1px solid #26233a;
        border-radius: 0.5rem;
        padding: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .history-item:hover {
        background: #26233a;
        border-color: #9ccfd8;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(156, 207, 216, 0.1);
      }
      .search-container {
        position: sticky;
        top: 0;
        background: rgba(25, 23, 36, 0.95);
        backdrop-filter: blur(10px);
        z-index: 10;
        border-bottom: 1px solid #26233a;
      }
    </style>
  </head>
  <body class="font-inter bg-gradient-to-br from-base via-surface to-overlay min-h-screen text-text">
    <div class="min-h-screen">
      <!-- Header -->
      <header class="p-6 text-center">
        <h1 class="text-4xl font-bold text-text mb-2 flex items-center justify-center gap-3">
          <i class="bx bx-history text-iris"></i>
          History
        </h1>
        <p class="text-muted text-sm">Your browsing history</p>
      </header>

      <!-- Search and Controls -->
      <div class="search-container px-6 py-4">
        <div class="max-w-4xl mx-auto">
          <div class="flex items-center gap-4 mb-4">
            <div class="flex-1 relative">
              <i class="bx bx-search absolute left-3 top-1/2 transform -translate-y-1/2 text-muted"></i>
              <input
                id="history-search"
                type="text"
                placeholder="Search history..."
                class="w-full pl-10 pr-4 py-2 bg-surface border border-overlay rounded-lg text-text focus:outline-none focus:ring-2 focus:ring-foam focus:border-foam placeholder-muted"
              />
            </div>
            <button
              id="clear-all-history"
              class="px-4 py-2 bg-love hover:bg-love/80 text-white rounded-lg transition-colors flex items-center gap-2"
            >
              <i class="bx bx-trash"></i>
              Clear All
            </button>
          </div>
          
          <!-- Filter Tabs -->
          <div class="flex gap-2">
            <button class="filter-tab active" data-filter="all">
              <i class="bx bx-globe"></i>
              All History
            </button>
            <button class="filter-tab" data-filter="today">
              <i class="bx bx-calendar-day"></i>
              Today
            </button>
            <button class="filter-tab" data-filter="week">
              <i class="bx bx-calendar-week"></i>
              This Week
            </button>
            <button class="filter-tab" data-filter="month">
              <i class="bx bx-calendar"></i>
              This Month
            </button>
          </div>
        </div>
      </div>

      <!-- History Content -->
      <main class="max-w-4xl mx-auto px-6 pb-6">
        <div id="history-list" class="space-y-3">
          <!-- History items will be populated here -->
        </div>
        
        <div id="no-history" class="text-center py-12 hidden">
          <i class="bx bx-history text-6xl text-muted mb-4"></i>
          <h3 class="text-xl font-semibold text-text mb-2">No History Found</h3>
          <p class="text-muted">Your browsing history will appear here as you navigate.</p>
        </div>
      </main>
    </div>

    <style>
      .filter-tab {
        padding: 0.5rem 1rem;
        background: transparent;
        border: 1px solid #26233a;
        border-radius: 0.5rem;
        color: #908caa;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
      }
      .filter-tab:hover {
        background: #26233a;
        color: #e0def4;
      }
      .filter-tab.active {
        background: #9ccfd8;
        color: #191724;
        border-color: #9ccfd8;
      }
    </style>

    <script type="module">
      import { makeURL, getProxied } from '/lethal.mjs';

      // DOM Elements
      const historyList = document.getElementById('history-list');
      const noHistory = document.getElementById('no-history');
      const historySearch = document.getElementById('history-search');
      const clearAllBtn = document.getElementById('clear-all-history');
      const filterTabs = document.querySelectorAll('.filter-tab');

      // State
      let allHistory = [];
      let filteredHistory = [];
      let currentFilter = 'all';

      // Load history from localStorage
      function loadHistory() {
        const history = JSON.parse(localStorage.getItem('carbon-history') || '[]');
        allHistory = history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        filterHistory();
        renderHistory();
      }

      // Save history to localStorage
      function saveHistory() {
        localStorage.setItem('carbon-history', JSON.stringify(allHistory));
      }

      // Add item to history (called from parent frame)
      function addToHistory(url, title = '') {
        // Don't add carbon:// URLs to history
        if (url.startsWith('carbon://')) return;
        
        const item = {
          id: Date.now() + Math.random(),
          url: url,
          title: title || url,
          timestamp: new Date().toISOString(),
          visits: 1
        };

        // Check if URL already exists
        const existingIndex = allHistory.findIndex(h => h.url === url);
        if (existingIndex !== -1) {
          allHistory[existingIndex].timestamp = item.timestamp;
          allHistory[existingIndex].visits++;
          allHistory[existingIndex].title = title || allHistory[existingIndex].title;
        } else {
          allHistory.unshift(item);
        }

        // Limit history to 1000 items
        if (allHistory.length > 1000) {
          allHistory = allHistory.slice(0, 1000);
        }

        saveHistory();
        filterHistory();
        renderHistory();
      }

      // Filter history based on current filter
      function filterHistory() {
        const searchTerm = historySearch.value.toLowerCase();
        const now = new Date();
        
        let filtered = allHistory;

        // Apply time filter
        if (currentFilter === 'today') {
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          filtered = allHistory.filter(item => new Date(item.timestamp) >= today);
        } else if (currentFilter === 'week') {
          const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          filtered = allHistory.filter(item => new Date(item.timestamp) >= weekAgo);
        } else if (currentFilter === 'month') {
          const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
          filtered = allHistory.filter(item => new Date(item.timestamp) >= monthAgo);
        }

        // Apply search filter
        if (searchTerm) {
          filtered = filtered.filter(item => 
            item.url.toLowerCase().includes(searchTerm) ||
            item.title.toLowerCase().includes(searchTerm)
          );
        }

        filteredHistory = filtered;
      }

      // Render history items
      function renderHistory() {
        if (filteredHistory.length === 0) {
          historyList.classList.add('hidden');
          noHistory.classList.remove('hidden');
          return;
        }

        historyList.classList.remove('hidden');
        noHistory.classList.add('hidden');

        // Group by date
        const groupedHistory = {};
        filteredHistory.forEach(item => {
          const date = new Date(item.timestamp).toDateString();
          if (!groupedHistory[date]) {
            groupedHistory[date] = [];
          }
          groupedHistory[date].push(item);
        });

        historyList.innerHTML = Object.entries(groupedHistory).map(([date, items]) => {
          const isToday = date === new Date().toDateString();
          const isYesterday = date === new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
          
          let displayDate = date;
          if (isToday) displayDate = 'Today';
          else if (isYesterday) displayDate = 'Yesterday';

          return `
            <div class="mb-6">
              <h3 class="text-lg font-semibold text-text mb-3 flex items-center gap-2">
                <i class="bx bx-calendar text-foam"></i>
                ${displayDate}
              </h3>
              <div class="space-y-2">
                ${items.map(item => `
                  <div class="history-item" data-url="${item.url}">
                    <div class="flex items-start justify-between">
                      <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 mb-1">
                          <i class="bx bx-world text-foam flex-shrink-0"></i>
                          <h4 class="font-medium text-text truncate">${item.title}</h4>
                          ${item.visits > 1 ? `<span class="text-xs bg-highlight-med px-2 py-0.5 rounded text-muted">${item.visits} visits</span>` : ''}
                        </div>
                        <p class="text-sm text-muted truncate">${item.url}</p>
                        <p class="text-xs text-subtle mt-1">${formatTime(item.timestamp)}</p>
                      </div>
                      <div class="flex items-center gap-1 ml-2">
                        <button class="delete-item w-8 h-8 rounded hover:bg-love/20 flex items-center justify-center text-muted hover:text-love transition-colors" data-id="${item.id}">
                          <i class="bx bx-trash text-sm"></i>
                        </button>
                      </div>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        }).join('');

        // Add event listeners
        document.querySelectorAll('.history-item').forEach(item => {
          item.addEventListener('click', async (e) => {
            if (e.target.closest('.delete-item')) return;
            
            const url = item.dataset.url;
            
            // Check if we're in an iframe (within the proxy browser)
            if (window.parent && window.parent !== window) {
              // Send message to parent frame to navigate
              window.parent.postMessage({
                type: 'carbon-navigate',
                url: url
              }, '*');
            } else {
              // Navigate normally if not in iframe
              const proxiedUrl = await getProxied(makeURL(url));
              window.location.href = proxiedUrl;
            }
          });
        });

        document.querySelectorAll('.delete-item').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const id = parseFloat(btn.dataset.id);
            deleteHistoryItem(id);
          });
        });
      }

      // Format timestamp
      function formatTime(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // Less than 1 minute
          return 'Just now';
        } else if (diff < 3600000) { // Less than 1 hour
          const minutes = Math.floor(diff / 60000);
          return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        } else if (diff < 86400000) { // Less than 1 day
          return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        } else {
          return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
      }

      // Delete single history item
      function deleteHistoryItem(id) {
        allHistory = allHistory.filter(item => item.id !== id);
        saveHistory();
        filterHistory();
        renderHistory();
      }

      // Clear all history
      function clearAllHistory() {
        if (confirm('Are you sure you want to clear all history? This action cannot be undone.')) {
          allHistory = [];
          saveHistory();
          filterHistory();
          renderHistory();
        }
      }

      // Event listeners
      historySearch.addEventListener('input', () => {
        filterHistory();
        renderHistory();
      });

      clearAllBtn.addEventListener('click', clearAllHistory);

      filterTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          filterTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          currentFilter = tab.dataset.filter;
          filterHistory();
          renderHistory();
        });
      });

      // Listen for history updates from parent frame
      window.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'carbon-add-history') {
          addToHistory(event.data.url, event.data.title);
        }
      });

      // Expose addToHistory for external use
      window.addToHistory = addToHistory;

      // Initialize
      loadHistory();

      // Firebase initialization and theme syncing
      const firebaseConfig = {
        apiKey: "AIzaSyC4ilHYP1T-kdXbWPoHJHhD2aj0pNWmMec",
        authDomain: "carbon-services.firebaseapp.com",
        projectId: "carbon-services",
        storageBucket: "carbon-services.firebasestorage.app",
        messagingSenderId: "288385472070",
        appId: "1:288385472070:web:c4be3ff186e248fc645c47",
        measurementId: "G-Y2K1RQYE74"
      };
      
      firebase.initializeApp(firebaseConfig);
      const auth = firebase.auth();
      const db = firebase.firestore();

      // Theme syncing with Firebase
      let currentUser = null;

      auth.onAuthStateChanged(async (user) => {
        currentUser = user;
        if (user) {
          try {
            await loadUserThemeFromFirebase(user.uid);
            await syncHistoryWithFirebase(user.uid);
          } catch (error) {
            console.log('Error loading user data from Firebase:', error);
          }
        }
      });

      async function loadUserThemeFromFirebase(userId) {
        try {
          const userPrefsDoc = await db.collection('user-preferences').doc(userId).get();
          if (userPrefsDoc.exists) {
            const prefs = userPrefsDoc.data();
            if (prefs.theme) {
              const theme = prefs.theme;
              localStorage.setItem('carbon-theme', theme);
              localStorage.setItem('carbon-theme-global', theme);
              
              // Apply theme to current page
              document.documentElement.setAttribute('data-theme', theme);
            }
            if (prefs.background) {
              localStorage.setItem('carbon-background', prefs.background);
            }
            if (prefs.customBackground) {
              localStorage.setItem('carbon-custom-bg', prefs.customBackground);
            }
          }
        } catch (error) {
          console.error('Error loading user theme from Firebase:', error);
        }
      }

      async function syncHistoryWithFirebase(userId) {
        try {
          // Load history from Firebase
          const historyDoc = await db.collection('user-history').doc(userId).get();
          if (historyDoc.exists) {
            const firebaseHistory = historyDoc.data().history || [];
            
            // Merge with local history (remove duplicates, keep most recent)
            const mergedHistory = [...allHistory];
            firebaseHistory.forEach(fbItem => {
              const existingIndex = mergedHistory.findIndex(item => item.url === fbItem.url);
              if (existingIndex === -1) {
                mergedHistory.push(fbItem);
              } else {
                // Keep the one with the most recent timestamp
                if (new Date(fbItem.timestamp) > new Date(mergedHistory[existingIndex].timestamp)) {
                  mergedHistory[existingIndex] = fbItem;
                }
              }
            });
            
            // Sort by timestamp and update
            allHistory = mergedHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            saveHistory();
            filterHistory();
            renderHistory();
          }
          
          // Save current history to Firebase
          await saveHistoryToFirebase(userId);
        } catch (error) {
          console.error('Error syncing history with Firebase:', error);
        }
      }

      async function saveHistoryToFirebase(userId) {
        if (!userId || allHistory.length === 0) return;
        
        try {
          // Only save the most recent 100 items to Firebase to avoid quota issues
          const historyToSave = allHistory.slice(0, 100);
          await db.collection('user-history').doc(userId).set({
            history: historyToSave,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
          });
        } catch (error) {
          console.error('Error saving history to Firebase:', error);
        }
      }

      // Override addToHistory to sync with Firebase
      const originalAddToHistory = window.addToHistory;
      window.addToHistory = function(url, title = '') {
        originalAddToHistory(url, title);
        
        // Save to Firebase if user is logged in
        if (currentUser) {
          saveHistoryToFirebase(currentUser.uid);
        }
      };

      // Listen for theme changes from parent frame
      window.addEventListener("message", function(event) {
        if (event.data && event.data.type === 'carbon-add-history') {
          addToHistory(event.data.url, event.data.title);
        } else if (event.data && event.data.type === 'carbon-theme-change') {
          const theme = event.data.theme;
          localStorage.setItem('carbon-theme', theme);
          localStorage.setItem('carbon-theme-global', theme);
          document.documentElement.setAttribute('data-theme', theme);
        }
      });
    </script>
  </body>
</html>