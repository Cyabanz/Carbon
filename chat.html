<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CARBON - Chat Rooms</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.0/dist/purify.min.js"></script>
  
  <!-- Emoji Support Package - Use working CDN -->
  <script src="https://cdn.jsdelivr.net/npm/emoji-js@6.0.1/lib/emoji.min.js"></script>
  
  <!-- Firebase SDKs (same version as profile.html) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
  
  <style>
    :root {
      --theme-base: #191724;
      --theme-surface: #1f1d2e;
      --theme-overlay: #26233a;
      --theme-muted: #6e6a86;
      --theme-subtle: #908caa;
      --theme-text: #e0def4;
      --theme-love: #eb6f92;
      --theme-gold: #f6c177;
      --theme-rose: #ebbcba;
      --theme-pine: #31748f;
      --theme-foam: #9ccfd8;
      --theme-iris: #c4a7e7;
      --theme-highlight-low: #21202e;
      --theme-highlight-med: #403d52;
      --theme-highlight-high: #524f67;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, var(--theme-base), var(--theme-surface));
      color: var(--theme-text);
      font-family: 'Inter', sans-serif;
      min-height: 100vh;
    }

    .bg-rp-base { background-color: var(--theme-base); }
    .bg-rp-surface { background-color: var(--theme-surface); }
    .bg-rp-overlay { background-color: var(--theme-overlay); }
    .text-rp-text { color: var(--theme-text); }
    .text-rp-muted { color: var(--theme-muted); }
    .text-rp-subtle { color: var(--theme-subtle); }
    .text-rp-foam { color: var(--theme-foam); }
    .text-rp-iris { color: var(--theme-iris); }
    .text-rp-love { color: var(--theme-love); }
    .text-rp-gold { color: var(--theme-gold); }
    .border-rp-overlay { border-color: var(--theme-overlay); }
    .border-rp-highlight-med { border-color: var(--theme-highlight-med); }

    /* Chat Rooms Layout */
    .chat-container {
      display: grid;
      grid-template-columns: 300px 1fr;
      height: calc(100vh - 80px);
      gap: 1rem;
      padding: 1rem;
    }

    .rooms-sidebar {
      background: var(--theme-surface);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
    }

    .chat-main {
      background: var(--theme-surface);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      padding: 1rem;
      border-bottom: 1px solid var(--theme-highlight-med);
      display: flex;
      justify-content: between;
      align-items: center;
    }

    .chat-messages {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      max-height: calc(100vh - 200px);
    }

    .chat-input-area {
      padding: 1rem;
      border-top: 1px solid var(--theme-highlight-med);
    }

    /* Room Item Styles */
    .room-item {
      padding: 0.75rem;
      border-radius: 8px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .room-item:hover {
      background: var(--theme-overlay);
      border-color: var(--theme-highlight-med);
    }

    .room-item.active {
      background: var(--theme-foam);
      color: var(--theme-base);
      border-color: var(--theme-foam);
    }

    .room-item.default {
      border-color: var(--theme-gold);
      background: rgba(246, 193, 119, 0.1);
    }

    .room-item.temporary {
      border-color: var(--theme-iris);
      background: rgba(196, 167, 231, 0.1);
    }

    /* Message Styles */
    .message {
      margin-bottom: 1rem;
      padding: 0.75rem;
      border-radius: 8px;
      background: var(--theme-overlay);
      animation: messageSlideIn 0.3s ease;
    }

    .message.own {
      background: var(--theme-foam);
      color: var(--theme-base);
      margin-left: 20%;
    }

    .message.system {
      background: var(--theme-gold);
      color: var(--theme-base);
      text-align: center;
      font-style: italic;
    }

    .message.ai {
      background: linear-gradient(135deg, rgba(196, 167, 231, 0.1), rgba(156, 207, 216, 0.1));
      border-left: 3px solid var(--theme-iris);
      position: relative;
    }

    .message.ai::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid var(--theme-iris);
      border-top: 8px solid var(--theme-iris);
      border-bottom: 8px solid transparent;
    }

    /* Reply functionality styles */
    .message {
      position: relative;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .message:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .message:hover .reply-button {
      opacity: 1;
    }

    .reply-button {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      opacity: 0;
      background: var(--theme-foam);
      color: var(--theme-base);
      border: none;
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 10;
    }

    .reply-button:hover {
      background: var(--theme-iris);
      transform: scale(1.05);
    }

    .reply-preview {
      background: var(--theme-highlight-med);
      border-left: 3px solid var(--theme-foam);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .reply-original {
      background: rgba(156, 207, 216, 0.1);
      border-left: 3px solid var(--theme-foam);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .reply-chain {
      border-left: 2px solid var(--theme-muted);
      margin-left: 1rem;
      padding-left: 0.5rem;
    }

    .reply-input-container {
      background: var(--theme-highlight-med);
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-left: 3px solid var(--theme-foam);
    }

    .reply-cancel {
      background: var(--theme-love);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      margin-left: 0.5rem;
    }

    /* Reaction styles */
    .message-reactions {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .reaction {
      background: var(--theme-highlight-med);
      border: 1px solid var(--theme-overlay);
      border-radius: 12px;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .reaction:hover {
      background: var(--theme-highlight-high);
      transform: scale(1.05);
    }

    .reaction.reacted {
      background: var(--theme-foam);
      color: var(--theme-base);
      border-color: var(--theme-foam);
    }

    .reaction-count {
      font-size: 0.7rem;
      font-weight: 600;
    }

    .add-reaction {
      background: var(--theme-highlight-med);
      border: 1px dashed var(--theme-overlay);
      border-radius: 12px;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      opacity: 0;
    }

    .message:hover .add-reaction {
      opacity: 1;
    }

    .add-reaction:hover {
      background: var(--theme-highlight-high);
      border-color: var(--theme-foam);
    }

    .reaction-picker {
      position: absolute;
      bottom: 100%;
      left: 0;
      background: var(--theme-surface);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 1rem;
      width: 350px;
      max-height: 400px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .reaction-picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--theme-highlight-med);
    }

    .reaction-picker-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--theme-text);
    }

    .reaction-search {
      background: var(--theme-overlay);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 6px;
      padding: 0.5rem;
      color: var(--theme-text);
      font-size: 0.8rem;
      width: 100%;
      margin-bottom: 0.75rem;
    }

    .reaction-search:focus {
      outline: none;
      border-color: var(--theme-foam);
    }

    .reaction-tabs {
      display: flex;
      gap: 0.25rem;
      margin-bottom: 0.75rem;
      overflow-x: auto;
    }

    .reaction-tab {
      padding: 0.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s ease;
      background: var(--theme-overlay);
      border: 1px solid transparent;
      min-width: 40px;
      text-align: center;
    }

    .reaction-tab:hover {
      background: var(--theme-highlight-med);
    }

    .reaction-tab.active {
      background: var(--theme-foam);
      color: var(--theme-base);
      border-color: var(--theme-foam);
    }

    .reaction-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0.25rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .reaction-emoji {
      padding: 0.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s ease;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reaction-emoji:hover {
      background: var(--theme-highlight-med);
      transform: scale(1.2);
    }

    .emoji-category-title {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--theme-muted);
      margin: 0.75rem 0 0.5rem 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* AFK styles */
    .afk-indicator {
      display: inline-block;
      background: var(--theme-gold);
      color: var(--theme-base);
      padding: 0.1rem 0.3rem;
      border-radius: 8px;
      font-size: 0.6rem;
      font-weight: 600;
      margin-left: 0.25rem;
    }

    .user-list {
      background: var(--theme-overlay);
      border-radius: 8px;
      padding: 0.5rem;
      margin-top: 0.5rem;
      max-height: 120px;
      overflow-y: auto;
    }

    .user-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .user-item.afk {
      opacity: 0.6;
    }

    .user-status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--theme-foam);
    }

    .user-status.afk {
      background: var(--theme-gold);
    }

    /* XP and Leveling System */
    .level-badge {
      background: linear-gradient(135deg, var(--theme-gold), #e6a700);
      color: var(--theme-base);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 8px;
      box-shadow: 0 2px 6px rgba(231, 180, 0, 0.3);
    }

    .level-badge.prestige {
      background: linear-gradient(135deg, var(--theme-iris), var(--theme-love));
      box-shadow: 0 2px 6px rgba(196, 167, 231, 0.4);
    }

    .xp-bar-container {
      background: var(--theme-overlay);
      border-radius: 10px;
      height: 8px;
      overflow: hidden;
      margin: 4px 0;
      position: relative;
    }

    .xp-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--theme-foam), var(--theme-iris));
      border-radius: 10px;
      transition: width 0.3s ease;
      position: relative;
    }

    .xp-bar.leveling-up {
      animation: xpGlow 0.5s ease-in-out;
    }

    @keyframes xpGlow {
      0%, 100% { box-shadow: 0 0 5px var(--theme-foam); }
      50% { box-shadow: 0 0 15px var(--theme-foam), 0 0 25px var(--theme-iris); }
    }

    .xp-text {
      font-size: 0.7rem;
      color: var(--theme-muted);
      text-align: center;
      margin-top: 2px;
    }

    .level-up-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, var(--theme-foam), var(--theme-iris));
      color: var(--theme-base);
      padding: 2rem;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      z-index: 2000;
      display: none;
      text-align: center;
      min-width: 300px;
    }

    .level-up-notification.show {
      display: block;
      animation: levelUpPop 1s ease-out;
    }

    @keyframes levelUpPop {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    .level-up-title {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 8px;
    }

    .level-up-details {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .xp-reward-popup {
      position: absolute;
      background: var(--theme-foam);
      color: var(--theme-base);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 600;
      z-index: 1000;
      pointer-events: none;
      animation: xpRewardFloat 1.5s ease-out forwards;
    }

    @keyframes xpRewardFloat {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }

    /* Level-based styling for usernames */
    .user-link.level-novice { color: #8e8e93; }
    .user-link.level-bronze { color: #cd7f32; }
    .user-link.level-silver { color: #c0c0c0; }
    .user-link.level-gold { color: var(--theme-gold); }
    .user-link.level-platinum { color: #e5e4e2; }
    .user-link.level-diamond { color: #b9f2ff; }
    .user-link.level-master { color: var(--theme-iris); }
    .user-link.level-grandmaster { color: var(--theme-love); }

    .xp-widget {
      background: linear-gradient(135deg, var(--theme-overlay), var(--theme-surface));
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 12px 16px;
      margin-right: 12px;
      min-width: 200px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .xp-widget-content {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .xp-widget-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .xp-widget-level {
      font-weight: 700;
      color: var(--theme-foam);
      font-size: 0.85rem;
    }

    .xp-widget-title {
      font-size: 0.75rem;
      color: var(--theme-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Room Color Customization */
    .color-picker-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .color-picker-modal.show {
      display: flex;
    }

    .color-picker-content {
      background: var(--theme-surface);
      border-radius: 16px;
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    }

    .color-picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--theme-highlight-med);
    }

    .color-picker-title {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--theme-text);
    }

    .color-section {
      margin-bottom: 2rem;
    }

    .color-section-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--theme-text);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .color-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 0.75rem;
    }

    .color-option {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      cursor: pointer;
      position: relative;
      border: 3px solid transparent;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .color-option:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    .color-option.selected {
      border-color: var(--theme-foam);
      box-shadow: 0 0 0 2px var(--theme-foam);
    }

    .color-option.locked {
      opacity: 0.5;
      cursor: not-allowed;
      position: relative;
    }

    .color-option.locked::after {
      content: 'ðŸ”’';
      position: absolute;
      font-size: 1.2rem;
      color: white;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
    }

    .color-option.locked:hover {
      transform: none;
      box-shadow: none;
    }

    .color-option-label {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: var(--theme-muted);
      text-align: center;
      white-space: nowrap;
    }

    .custom-color-section {
      background: linear-gradient(135deg, rgba(196, 167, 231, 0.1), rgba(156, 207, 216, 0.1));
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .custom-color-picker {
      width: 100%;
      height: 60px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      margin-bottom: 1rem;
    }

    .unlock-requirement {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--theme-muted);
      margin-bottom: 1rem;
    }

    .unlock-requirement.unlocked {
      color: var(--theme-foam);
    }

    .color-preview {
      width: 100%;
      height: 80px;
      border-radius: 12px;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .color-picker-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--theme-highlight-med);
    }

    .room-color-btn {
      background: var(--theme-foam);
      color: var(--theme-base);
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .room-color-btn:hover {
      background: var(--theme-iris);
      transform: translateY(-1px);
    }

    .room-color-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .room-color-btn:disabled:hover {
      transform: none;
    }

    /* Full-page room theme application */
    body.custom-theme {
      background: linear-gradient(135deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.03) 0%, 
        var(--theme-base) 50%, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.02) 100%);
      min-height: 100vh;
    }

    .container.custom-theme {
      background: linear-gradient(180deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.02) 0%, 
        transparent 100%);
      border-radius: 16px;
      backdrop-filter: blur(10px);
    }

    .sidebar.custom-theme {
      background: linear-gradient(180deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.08) 0%, 
        var(--theme-surface) 100%);
      border-right: 1px solid rgba(var(--room-color-rgb, 156, 207, 216), 0.2);
    }

    .chat-main.custom-theme {
      background: linear-gradient(135deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.03) 0%, 
        transparent 100%);
    }

    .chat-header.custom-theme {
      background: linear-gradient(135deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.15) 0%, 
        var(--theme-surface) 100%);
      border-bottom: 1px solid rgba(var(--room-color-rgb, 156, 207, 216), 0.3);
      backdrop-filter: blur(10px);
    }

    .message.custom-theme {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.02);
      border-left: 3px solid var(--room-color, var(--theme-foam));
      backdrop-filter: blur(5px);
    }

    .message.custom-theme:hover {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.05);
    }

    .room-item.custom-theme {
      border-left: 4px solid var(--room-color, var(--theme-foam));
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.05);
    }

    .room-item.custom-theme.active {
      background: linear-gradient(90deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.2), 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.05));
      box-shadow: 0 0 10px rgba(var(--room-color-rgb, 156, 207, 216), 0.3);
    }

    .room-item.custom-theme:hover {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.1);
    }

    .chat-input-area.custom-theme {
      background: linear-gradient(135deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.08) 0%, 
        var(--theme-surface) 100%);
      border-top: 1px solid rgba(var(--room-color-rgb, 156, 207, 216), 0.2);
    }

    .btn-primary.custom-theme {
      background: linear-gradient(135deg, var(--room-color), rgba(var(--room-color-rgb, 156, 207, 216), 0.8));
      border-color: var(--room-color);
    }

    .btn-primary.custom-theme:hover {
      background: var(--room-color);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(var(--room-color-rgb, 156, 207, 216), 0.4);
    }

    .btn-secondary.custom-theme {
      border-color: rgba(var(--room-color-rgb, 156, 207, 216), 0.3);
      color: var(--room-color);
    }

    .btn-secondary.custom-theme:hover {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.1);
      border-color: var(--room-color);
    }

    .xp-widget.custom-theme {
      background: linear-gradient(135deg, 
        rgba(var(--room-color-rgb, 156, 207, 216), 0.1), 
        var(--theme-surface));
      border-color: rgba(var(--room-color-rgb, 156, 207, 216), 0.3);
    }

    .xp-bar.custom-theme {
      background: linear-gradient(90deg, var(--room-color), rgba(var(--room-color-rgb, 156, 207, 216), 0.6));
    }

    .user-list.custom-theme {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.05);
      border: 1px solid rgba(var(--room-color-rgb, 156, 207, 216), 0.2);
    }

    /* Scroll bar theming */
    .custom-theme ::-webkit-scrollbar-thumb {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.3);
    }

    .custom-theme ::-webkit-scrollbar-thumb:hover {
      background: rgba(var(--room-color-rgb, 156, 207, 216), 0.5);
    }

    /* Emoji picker styles */
    .emoji-picker {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: var(--theme-surface);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 1rem;
      width: 300px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0.5rem;
    }

    .emoji-item {
      padding: 0.5rem;
      text-align: center;
      cursor: pointer;
      border-radius: 6px;
      font-size: 1.2rem;
      transition: all 0.2s ease;
    }

    .emoji-item:hover {
      background: var(--theme-highlight-med);
      transform: scale(1.2);
    }

    .emoji-button {
      background: var(--theme-highlight-med);
      border: none;
      color: var(--theme-text);
      padding: 0.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s ease;
    }

    .emoji-button:hover {
      background: var(--theme-foam);
      color: var(--theme-base);
    }

    /* Profile modal styles */
    .profile-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(4px);
    }

    .profile-modal-content {
      background: var(--theme-surface);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 2rem;
      max-width: 400px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .profile-avatar-large {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 3px solid var(--theme-foam);
    }

    .clickable-avatar {
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .clickable-avatar:hover {
      transform: scale(1.1);
      border-color: var(--theme-iris);
    }

    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .message-content {
      word-wrap: break-word;
      line-height: 1.4;
    }

    /* Button Styles */
    .btn-primary {
      background: linear-gradient(135deg, var(--theme-foam), var(--theme-iris));
      color: var(--theme-base);
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(156, 207, 216, 0.3);
    }

    .btn-secondary {
      background: var(--theme-overlay);
      color: var(--theme-text);
      border: 1px solid var(--theme-highlight-med);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-secondary:hover {
      background: var(--theme-highlight-med);
    }

    .btn-danger {
      background: var(--theme-love);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
    }

    /* Room Timer */
    .room-timer {
      font-size: 0.7rem;
      color: var(--theme-muted);
      margin-top: 0.25rem;
    }

    .room-timer.expiring {
      color: var(--theme-love);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: var(--theme-surface);
      border: 1px solid var(--theme-highlight-med);
      border-radius: 12px;
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    /* User Count Badge */
    .user-count {
      background: var(--theme-iris);
      color: var(--theme-base);
      padding: 0.2rem 0.5rem;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .chat-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      
      .rooms-sidebar {
        max-height: 200px;
      }
      
      .message.own {
        margin-left: 10%;
      }
    }

    /* Online indicator */
    .online-indicator {
      width: 8px;
      height: 8px;
      background: var(--theme-foam);
      border-radius: 50%;
      display: inline-block;
      margin-right: 0.5rem;
      animation: pulse 2s infinite;
    }

    /* Input validation */
    .input-error {
      border-color: var(--theme-love) !important;
      box-shadow: 0 0 0 3px rgba(235, 111, 146, 0.1);
    }

    .error-message {
      color: var(--theme-love);
      font-size: 0.8rem;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="flex items-center justify-between px-6 py-4 bg-rp-surface/80 border-b border-rp-overlay backdrop-blur-sm">
    <div class="flex items-center gap-6">
      <a href="index.html" class="text-xl font-bold text-rp-foam tracking-tight">CARBON</a>
      <div class="hidden md:flex items-center gap-4">
        <a href="index.html" class="text-rp-subtle hover:text-rp-text transition-colors">Home</a>
        <a href="profile.html" class="text-rp-subtle hover:text-rp-text transition-colors">Profile</a>
        <a href="forum.html" class="text-rp-subtle hover:text-rp-text transition-colors">Forum</a>
        <a href="chat.html" class="text-rp-foam font-medium">Chat</a>
      </div>
    </div>
    
    <div id="userSection" class="flex items-center gap-3">
      <button id="signInBtn" onclick="googleSignIn()" class="btn-primary">
        <i class='bx bxl-google mr-2'></i>
        Sign In
      </button>
    </div>
  </nav>

  <!-- Main Chat Container -->
  <div class="chat-container">
    <!-- Rooms Sidebar -->
    <div class="rooms-sidebar">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-lg font-bold text-rp-foam">Chat Rooms</h3>
        <button id="createRoomBtn" onclick="showCreateRoomModal()" class="btn-secondary hidden">
          <i class='bx bx-plus'></i>
        </button>
      </div>
      
      <div id="roomsList">
        <!-- Rooms will be loaded dynamically -->
      </div>
      
      <!-- Room Management -->
      <div id="roomManagement" class="mt-6 pt-4 border-t border-rp-highlight-med hidden">
        <h4 class="text-sm font-semibold text-rp-muted mb-2">Room Management</h4>
        <button onclick="cleanupExpiredRooms()" class="btn-secondary w-full text-sm mb-2">
          <i class='bx bx-trash mr-2'></i>
          Cleanup Expired Rooms
        </button>
        <button onclick="cleanupInactiveRooms()" class="btn-secondary w-full text-sm mb-2">
          <i class='bx bx-clock mr-2'></i>
          Cleanup Inactive Rooms
        </button>
        <button onclick="cleanupOldMessages(currentRoomId)" class="btn-secondary w-full text-sm">
          <i class='bx bx-message-x mr-2'></i>
          Cleanup Old Messages
        </button>
      </div>
    </div>

    <!-- Chat Main Area -->
    <div class="chat-main">
      <!-- Chat Header -->
      <div class="chat-header">
        <div>
          <h2 id="chatTitle" class="text-xl font-bold text-rp-foam">Select a room to start chatting</h2>
          <div id="chatSubtitle" class="text-sm text-rp-muted hidden">
            <span id="roomType"></span>
            <span id="roomTimer" class="room-timer"></span>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <!-- XP Widget -->
          <div id="xpWidget" class="xp-widget hidden">
            <div class="xp-widget-content">
              <div class="xp-widget-header">
                <div class="xp-widget-level" id="userLevel">Lv.1</div>
                <div class="xp-widget-title" id="userLevelTitle">Novice</div>
              </div>
              <div class="xp-bar-container">
                <div class="xp-bar" id="userXPBar" style="width: 0%"></div>
              </div>
              <div class="xp-text" id="userXPText">0 / 100 XP</div>
            </div>
          </div>
          
          <span id="userCount" class="user-count hidden">0 users</span>
          <button id="toggleUserListBtn" class="btn-secondary hidden" onclick="toggleUserList()">
            <i class='bx bx-group'></i>
            Users
          </button>
          <button id="customizeColorBtn" onclick="openColorPicker()" class="btn-secondary hidden">
            <i class='bx bx-palette'></i>
            Colors
          </button>
          <button id="leaveRoomBtn" onclick="leaveCurrentRoom()" class="btn-secondary hidden">
            <i class='bx bx-exit'></i>
            Leave
          </button>
        </div>
      </div>
      
      <!-- User List -->
      <div id="userListContainer" class="user-list hidden">
        <div class="text-xs font-semibold text-rp-muted mb-2">Active Users:</div>
        <div id="activeUsersList">
          <!-- Users will be populated here -->
        </div>
      </div>

      <!-- Chat Messages -->
      <div id="chatMessages" class="chat-messages">
        <div class="text-center text-rp-muted py-8">
          <i class='bx bx-chat text-4xl mb-4 block'></i>
          <p>Welcome to CARBON Chat!</p>
          <p class="text-sm mt-2">Select a room from the sidebar to start chatting.</p>
        </div>
      </div>

      <!-- Chat Input -->
      <div class="chat-input-area">
        <form id="messageForm" onsubmit="sendMessage(event)" class="hidden">
          <!-- Reply Preview -->
          <div id="replyPreview" class="reply-input-container hidden">
            <div class="flex items-center justify-between">
              <div class="flex-1">
                <div class="text-xs text-rp-muted mb-1">Replying to:</div>
                <div id="replyPreviewContent" class="text-sm"></div>
              </div>
              <button type="button" onclick="cancelReply()" class="reply-cancel">
                <i class='bx bx-x'></i>
              </button>
            </div>
          </div>
          
          <div class="flex gap-2 relative">
            <input 
              type="text" 
              id="messageInput" 
              placeholder="Type your message..." 
              class="flex-1 px-4 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text placeholder-rp-muted focus:outline-none focus:border-rp-foam"
              maxlength="500"
              required
            >
            <button type="button" id="emojiButton" class="emoji-button">
              ðŸ˜€
            </button>
            <button type="submit" class="btn-primary">
              <i class='bx bx-send'></i>
            </button>
            
            <!-- Emoji Picker -->
            <div id="emojiPicker" class="emoji-picker hidden">
              <div class="emoji-grid" id="emojiGrid">
                <!-- Emojis will be populated by JavaScript -->
              </div>
            </div>
          </div>
          <div class="text-xs text-rp-muted mt-2">
            Messages are automatically filtered for appropriate content
          </div>
        </form>
        <div id="guestMessage" class="text-center py-4">
          <p class="text-rp-muted">Please sign in to participate in chat rooms</p>
          <button onclick="googleSignIn()" class="btn-primary mt-2">
            <i class='bx bxl-google mr-2'></i>
            Sign In to Chat
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Create Room Modal -->
  <div id="createRoomModal" class="modal">
    <div class="modal-content">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-bold text-rp-foam">Create Chat Room</h3>
        <button onclick="hideCreateRoomModal()" class="text-rp-muted hover:text-rp-text">
          <i class='bx bx-x text-2xl'></i>
        </button>
      </div>
      
      <form id="createRoomForm" onsubmit="createRoom(event)">
        <div class="mb-4">
          <label for="roomName" class="block text-sm font-medium text-rp-text mb-2">Room Name</label>
          <input 
            type="text" 
            id="roomName" 
            placeholder="Enter room name..." 
            class="w-full px-4 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text placeholder-rp-muted focus:outline-none focus:border-rp-foam"
            maxlength="50"
            required
            oninput="clearRoomNameError()"
          >
          <div id="roomNameError" class="error-message hidden">Room name contains inappropriate content</div>
        </div>
        
        <div class="mb-4">
          <label for="roomDescription" class="block text-sm font-medium text-rp-text mb-2">Description (Optional)</label>
          <textarea 
            id="roomDescription" 
            placeholder="Describe your room..." 
            class="w-full px-4 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text placeholder-rp-muted focus:outline-none focus:border-rp-foam"
            rows="3"
            maxlength="200"
          ></textarea>
        </div>
        
        <div class="mb-6">
          <div class="flex items-center justify-between">
            <span class="text-sm font-medium text-rp-text">Room Duration</span>
            <span class="text-xs text-rp-muted">Temporary rooms auto-delete after expiry</span>
          </div>
          <select 
            id="roomDuration" 
            class="w-full mt-2 px-4 py-2 bg-rp-overlay border border-rp-highlight-med rounded-lg text-rp-text focus:outline-none focus:border-rp-foam"
          >
            <option value="3600000">1 Hour</option>
            <option value="7200000">2 Hours</option>
            <option value="10800000">3 Hours</option>
            <option value="21600000">6 Hours</option>
          </select>
        </div>
        
        <div class="flex gap-2">
          <button type="button" onclick="hideCreateRoomModal()" class="btn-secondary flex-1">Cancel</button>
          <button type="submit" class="btn-primary flex-1">Create Room</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Profile Modal -->
  <div id="profileModal" class="profile-modal hidden">
    <div class="profile-modal-content">
      <div class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-bold text-rp-foam">User Profile</h3>
        <button onclick="closeProfileModal()" class="text-rp-muted hover:text-rp-text">
          <i class='bx bx-x text-2xl'></i>
        </button>
      </div>
      
      <div class="text-center mb-4">
        <img id="profileModalAvatar" src="" alt="User Avatar" class="profile-avatar-large mx-auto mb-3">
        <h4 id="profileModalName" class="text-lg font-semibold text-rp-text"></h4>
        <div id="profileModalStatus" class="text-sm text-rp-muted"></div>
      </div>
      
      <div class="space-y-3">
        <div>
          <div class="text-sm font-semibold text-rp-foam mb-1">Bio:</div>
          <div id="profileModalBio" class="text-sm text-rp-text bg-rp-overlay p-3 rounded-lg">No bio available</div>
        </div>
        
        <div>
          <div class="text-sm font-semibold text-rp-foam mb-1">Joined:</div>
          <div id="profileModalJoined" class="text-sm text-rp-text"></div>
        </div>
        
        <div class="flex gap-2 mt-4">
          <button onclick="closeProfileModal()" class="btn-secondary flex-1">Close</button>
          <button id="viewFullProfileBtn" class="btn-primary flex-1">View Full Profile</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Level Up Notification -->
  <div id="levelUpNotification" class="level-up-notification">
    <div class="level-up-title">ðŸŽ‰ Level Up! ðŸŽ‰</div>
    <div class="level-up-details">
      <div>You've reached <strong>Level <span id="newLevelNumber">2</span></strong></div>
      <div><span id="levelTitleText">Bronze</span></div>
      <div style="margin-top: 8px;">Bonus: <strong>+<span id="xpRewardAmount">50</span> XP</strong></div>
    </div>
  </div>

  <!-- Color Picker Modal -->
  <div id="colorPickerModal" class="color-picker-modal">
    <div class="color-picker-content">
      <div class="color-picker-header">
        <div class="color-picker-title">ðŸŽ¨ Customize Room Color</div>
        <button onclick="closeColorPicker()" style="background: none; border: none; color: var(--theme-muted); cursor: pointer; font-size: 1.5rem;">âœ•</button>
      </div>

      <!-- Default Colors -->
      <div class="color-section">
        <div class="color-section-title">
          <i class='bx bx-palette'></i>
          Default Colors
        </div>
        <div class="color-grid" id="defaultColors">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <!-- XP Unlocked Colors -->
      <div class="color-section">
        <div class="color-section-title">
          <i class='bx bx-trophy'></i>
          XP Unlocked Colors
        </div>
        <div class="color-grid" id="xpColors">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <!-- Custom Color Section -->
      <div class="color-section">
        <div class="color-section-title">
          <i class='bx bx-customize'></i>
          Custom Color
        </div>
        <div class="custom-color-section">
          <div class="unlock-requirement" id="customColorRequirement">
            <i class='bx bx-lock'></i>
            <span>Unlock at Level 10 (Platinum)</span>
          </div>
          <input type="color" id="customColorPicker" class="custom-color-picker" value="#9ccfd8" disabled>
          <div class="color-preview" id="colorPreview">
            Custom Color Preview
          </div>
        </div>
      </div>

      <div class="color-picker-actions">
        <button class="room-color-btn" onclick="closeColorPicker()" style="background: var(--theme-muted);">
          <i class='bx bx-x'></i>
          Cancel
        </button>
        <button class="room-color-btn" onclick="applyRoomColor()" id="applyColorBtn">
          <i class='bx bx-check'></i>
          Apply Color
        </button>
      </div>
    </div>
  </div>



  <script>
    // Firebase Configuration (same as profile.html)
    const firebaseConfig = {
      apiKey: "AIzaSyC4ilHYP1T-kdXbWPoHJHhD2aj0pNWmMec",
      authDomain: "carbon-services.firebaseapp.com",
      projectId: "carbon-services",
      storageBucket: "carbon-services.firebasestorage.app",
      messagingSenderId: "288385472070",
      appId: "1:288385472070:web:c4be3ff186e248fc645c47",
      measurementId: "G-Y2K1RQYE74"
    };

    // Initialize Firebase
    let app, auth, db;
    let firebaseInitialized = false;
    let isOnline = navigator.onLine;

    async function initializeFirebase() {
      if (firebaseInitialized) return true;
      
      try {
        if (typeof firebase === 'undefined') {
          console.log('Firebase SDK not yet loaded');
          return false;
        }

        try {
          app = firebase.app();
        } catch (error) {
          app = firebase.initializeApp(firebaseConfig);
        }

        auth = app.auth();
        db = app.firestore();
        
        // Enable offline persistence with improved error handling
        try {
          await db.enablePersistence({ synchronizeTabs: true });
          console.log("Firestore persistence enabled successfully");
        } catch (err) {
          if (err.code == 'failed-precondition') {
            console.warn("Multiple tabs open, persistence can only be enabled in one tab at a time.");
          } else if (err.code == 'unimplemented') {
            console.warn("The current browser does not support all of the features required to enable persistence");
          } else {
            console.error("Firestore persistence error:", err);
          }
        }

        // Add connection monitoring
        db.enableNetwork().catch(err => {
          console.error("Failed to enable Firestore network:", err);
        });
        
        auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        firebaseInitialized = true;
        console.log('Firebase initialized for chat');
        return true;
      } catch (error) {
        console.error('Firebase initialization error:', error);
        // Continue with offline mode
        return false;
      }
    }

    // Network status monitoring
    function setupNetworkMonitoring() {
      window.addEventListener('online', () => {
        console.log('Network connection restored');
        isOnline = true;
        updateConnectionStatus();
        retryFirebaseOperations();
      });

      window.addEventListener('offline', () => {
        console.log('Network connection lost');
        isOnline = false;
        updateConnectionStatus();
      });
    }

    function updateConnectionStatus() {
      const statusIndicator = document.getElementById('connectionStatus');
      if (!statusIndicator) {
        // Create connection status indicator
        const indicator = document.createElement('div');
        indicator.id = 'connectionStatus';
        indicator.style.cssText = `
          position: fixed;
          top: 10px;
          right: 10px;
          padding: 8px 12px;
          border-radius: 6px;
          font-size: 12px;
          font-weight: 600;
          z-index: 1001;
          transition: all 0.3s ease;
        `;
        document.body.appendChild(indicator);
      }
      
      const indicator = document.getElementById('connectionStatus');
      if (isOnline) {
        indicator.textContent = 'ðŸŸ¢ Online';
        indicator.style.background = 'var(--theme-foam)';
        indicator.style.color = 'var(--theme-base)';
      } else {
        indicator.textContent = 'ðŸ”´ Offline';
        indicator.style.background = 'var(--theme-love)';
        indicator.style.color = 'white';
      }
    }

    function retryFirebaseOperations() {
      if (firebaseInitialized && isOnline) {
        // Retry loading rooms
        setTimeout(() => {
          loadRooms();
        }, 1000);
      }
    }

    // AI Chat functionality
    class AIChatbot {
      constructor() {
        this.isActive = false;
        this.apiEndpoint = 'https://text.pollinations.ai/';
        this.lastAiMessageTime = 0;
        this.conversationHistory = [];
      }

      async generateResponse(userMessage) {
        try {
          // Add context about the conversation
          const context = this.getConversationContext();
          const prompt = `${context}\n\nUser: ${userMessage}\nAI Assistant:`;
          
          // Try pollinations.ai text endpoint
          const response = await fetch(`${this.apiEndpoint}${encodeURIComponent(prompt)}`, {
            method: 'GET',
            headers: {
              'Accept': 'text/plain',
            }
          });

          if (!response.ok) {
            throw new Error(`AI API error: ${response.status}`);
          }

          const aiResponse = await response.text();
          return this.cleanResponse(aiResponse);
        } catch (error) {
          console.error('AI API error:', error);
          return this.getFallbackResponse(userMessage);
        }
      }

      getConversationContext() {
        return `You are a friendly AI assistant in a chat room. Keep responses concise and engaging. 
Be helpful and conversational. Respond naturally to user messages.`;
      }

      cleanResponse(response) {
        // Clean up the AI response
        let cleaned = response.trim();
        
        // Remove any prompt echoing
        if (cleaned.startsWith('AI Assistant:')) {
          cleaned = cleaned.substring(13).trim();
        }
        
        // Limit length
        if (cleaned.length > 300) {
          cleaned = cleaned.substring(0, 297) + '...';
        }
        
        return cleaned || "I'm here to chat! How can I help you today?";
      }

      getFallbackResponse(userMessage) {
        const fallbacks = [
          "I'm here to chat! How can I help you today?",
          "That's interesting! Tell me more about that.",
          "I'm an AI assistant here to keep you company while the chat room is quiet.",
          "Thanks for sharing! What else would you like to talk about?",
          "I'm still learning, but I'm here to chat with you!",
          "That sounds cool! I'd love to hear more about your thoughts on that.",
        ];
        
        return fallbacks[Math.floor(Math.random() * fallbacks.length)];
      }

      updateConversationHistory(userMessage, aiResponse) {
        this.conversationHistory.push({ user: userMessage, ai: aiResponse });
        // Keep only last 5 exchanges
        if (this.conversationHistory.length > 5) {
          this.conversationHistory.shift();
        }
      }

      shouldActivate(userCount) {
        return userCount <= 1; // Activate when user is alone or room is empty
      }

      activate() {
        this.isActive = true;
        console.log('AI chatbot activated');
      }

      deactivate() {
        this.isActive = false;
        this.conversationHistory = [];
        console.log('AI chatbot deactivated');
      }
    }

    const aiChatbot = new AIChatbot();

    // Initialize emoji converter
    function initializeEmoji() {
      // Check for the emoji library with different possible names
      if (typeof EmojiConvertor !== 'undefined') {
        emojiConverter = new EmojiConvertor();
      } else if (typeof window.EmojiConvertor !== 'undefined') {
        emojiConverter = new window.EmojiConvertor();
      } else if (typeof emoji !== 'undefined') {
        emojiConverter = emoji;
              } else {
          // Add retry limit and fallback
          if (typeof window.emojiInitRetries === 'undefined') {
            window.emojiInitRetries = 0;
          }
          window.emojiInitRetries++;
          
          if (window.emojiInitRetries < 50) { // Max 5 seconds
            console.warn('Emoji library not loaded yet, retrying...', window.emojiInitRetries);
            setTimeout(initializeEmoji, 100);
            return;
          } else {
            console.warn('Emoji library failed to load, using fallback');
            emojiConverter = {
              replace_colons: function(text) { return text; },
              replace_mode: 'unified',
              allow_native: true
            };
            setupEmojiPicker();
            return;
          }
        }
      
      if (emojiConverter) {
        if (typeof emojiConverter.replace_mode !== 'undefined') {
          emojiConverter.replace_mode = 'unified';
        }
        if (typeof emojiConverter.allow_native !== 'undefined') {
          emojiConverter.allow_native = true;
        }
        console.log('Emoji converter initialized successfully');
        setupEmojiPicker();
      }
    }

    function setupEmojiPicker() {
      const emojiButton = document.getElementById('emojiButton');
      const emojiPicker = document.getElementById('emojiPicker');
      const emojiGrid = document.getElementById('emojiGrid');

      // Populate emoji grid
      emojiGrid.innerHTML = '';
      quickEmojis.forEach(emoji => {
        const emojiItem = document.createElement('div');
        emojiItem.className = 'emoji-item';
        emojiItem.textContent = emoji;
        emojiItem.addEventListener('click', () => {
          insertEmoji(emoji);
          emojiPicker.classList.add('hidden');
        });
        emojiGrid.appendChild(emojiItem);
      });

      // Toggle emoji picker
      emojiButton.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.classList.toggle('hidden');
      });

      // Close picker when clicking outside
      document.addEventListener('click', (e) => {
        if (!emojiPicker.contains(e.target) && !emojiButton.contains(e.target)) {
          emojiPicker.classList.add('hidden');
        }
      });
    }

    function insertEmoji(emoji) {
      const messageInput = document.getElementById('messageInput');
      const cursorPos = messageInput.selectionStart;
      const textBefore = messageInput.value.substring(0, cursorPos);
      const textAfter = messageInput.value.substring(messageInput.selectionEnd);
      
      messageInput.value = textBefore + emoji + textAfter;
      messageInput.focus();
      messageInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
    }

    async function waitForFirebaseAndInitialize() {
      if (typeof firebase !== 'undefined') {
        await initializeFirebase();
      } else {
        setTimeout(waitForFirebaseAndInitialize, 100);
      }
    }

    waitForFirebaseAndInitialize();
    initializeEmoji();

    // Global variables
    let currentUser = null;
    let currentRoomId = null;
    let messagesListener = null;
    let roomsListener = null;
    let userPresenceListener = null;
    let cleanupInterval = null;
    let replyingTo = null; // Store the message being replied to
    let messageCleanupInterval = null; // For message cleanup
    let emojiConverter = null; // Emoji converter instance
    let lastActivity = Date.now(); // Track user activity for AFK detection
    let afkCheckInterval = null; // AFK check interval
    let userActivityMap = new Map(); // Track activity for all users
    let activeUsers = new Map(); // Store active users data

    // XP System
    const XP_REWARDS = {
      MESSAGE: 5,
      REACTION_RECEIVED: 2,
      REACTION_GIVEN: 1,
      LEVEL_UP_BONUS: 50
    };

    const LEVEL_THRESHOLDS = [
      { level: 1, xp: 0, title: 'Novice', tier: 'novice' },
      { level: 2, xp: 100, title: 'Beginner', tier: 'novice' },
      { level: 3, xp: 250, title: 'Learner', tier: 'novice' },
      { level: 4, xp: 500, title: 'Bronze', tier: 'bronze' },
      { level: 5, xp: 850, title: 'Bronze II', tier: 'bronze' },
      { level: 6, xp: 1300, title: 'Silver', tier: 'silver' },
      { level: 7, xp: 1850, title: 'Silver II', tier: 'silver' },
      { level: 8, xp: 2500, title: 'Gold', tier: 'gold' },
      { level: 9, xp: 3250, title: 'Gold II', tier: 'gold' },
      { level: 10, xp: 4100, title: 'Platinum', tier: 'platinum' },
      { level: 11, xp: 5050, title: 'Platinum II', tier: 'platinum' },
      { level: 12, xp: 6100, title: 'Diamond', tier: 'diamond' },
      { level: 13, xp: 7250, title: 'Diamond II', tier: 'diamond' },
      { level: 14, xp: 8500, title: 'Master', tier: 'master' },
      { level: 15, xp: 9850, title: 'Grandmaster', tier: 'grandmaster' },
      { level: 16, xp: 11300, title: 'Legendary', tier: 'grandmaster' },
      { level: 17, xp: 12850, title: 'Mythical', tier: 'grandmaster' },
      { level: 18, xp: 14500, title: 'Ascended', tier: 'grandmaster' },
      { level: 19, xp: 16250, title: 'Divine', tier: 'grandmaster' },
      { level: 20, xp: 18100, title: 'Transcendent', tier: 'grandmaster' }
    ];

    // Extended emoji database for Discord-style suggestions
    window.allEmojis = [
      // Smileys & Emotion
      { emoji: 'ðŸ˜€', name: 'grinning', keywords: ['happy', 'smile', 'grin'], category: 'smileys' },
      { emoji: 'ðŸ˜ƒ', name: 'smiley', keywords: ['happy', 'smile', 'joy'], category: 'smileys' },
      { emoji: 'ðŸ˜„', name: 'smile', keywords: ['happy', 'smile', 'laugh'], category: 'smileys' },
      { emoji: 'ðŸ˜', name: 'grin', keywords: ['happy', 'smile', 'grin'], category: 'smileys' },
      { emoji: 'ðŸ˜†', name: 'laughing', keywords: ['happy', 'laugh', 'funny'], category: 'smileys' },
      { emoji: 'ðŸ˜…', name: 'sweat_smile', keywords: ['happy', 'laugh', 'nervous'], category: 'smileys' },
      { emoji: 'ðŸ¤£', name: 'rofl', keywords: ['laugh', 'funny', 'hilarious'], category: 'smileys' },
      { emoji: 'ðŸ˜‚', name: 'joy', keywords: ['laugh', 'funny', 'tears'], category: 'smileys' },
      { emoji: 'ðŸ™‚', name: 'slightly_smiling', keywords: ['smile', 'happy'], category: 'smileys' },
      { emoji: 'ðŸ™ƒ', name: 'upside_down', keywords: ['silly', 'playful'], category: 'smileys' },
      { emoji: 'ðŸ˜‰', name: 'wink', keywords: ['flirt', 'playful'], category: 'smileys' },
      { emoji: 'ðŸ˜Š', name: 'blush', keywords: ['happy', 'shy', 'sweet'], category: 'smileys' },
      { emoji: 'ðŸ˜‡', name: 'innocent', keywords: ['angel', 'good', 'halo'], category: 'smileys' },
      { emoji: 'ðŸ¥°', name: 'smiling_face_with_hearts', keywords: ['love', 'happy', 'hearts'], category: 'hearts' },
      { emoji: 'ðŸ˜', name: 'heart_eyes', keywords: ['love', 'crush', 'heart'], category: 'hearts' },
      { emoji: 'ðŸ¤©', name: 'star_struck', keywords: ['excited', 'wow', 'star'], category: 'smileys' },
      { emoji: 'ðŸ˜˜', name: 'kissing_heart', keywords: ['kiss', 'love', 'heart'], category: 'hearts' },
      { emoji: 'ðŸ˜—', name: 'kissing', keywords: ['kiss', 'love'], category: 'hearts' },
      { emoji: 'ðŸ˜š', name: 'kissing_closed_eyes', keywords: ['kiss', 'love'], category: 'hearts' },
      { emoji: 'ðŸ˜™', name: 'kissing_smiling_eyes', keywords: ['kiss', 'love'], category: 'hearts' },
      { emoji: 'ðŸ¥²', name: 'smiling_face_with_tear', keywords: ['happy', 'cry', 'tear'], category: 'smileys' },
      { emoji: 'ðŸ˜‹', name: 'yum', keywords: ['delicious', 'food', 'hungry'], category: 'smileys' },
      { emoji: 'ðŸ˜›', name: 'stuck_out_tongue', keywords: ['playful', 'silly'], category: 'smileys' },
      { emoji: 'ðŸ˜œ', name: 'stuck_out_tongue_winking_eye', keywords: ['playful', 'silly', 'wink'], category: 'smileys' },
      { emoji: 'ðŸ¤ª', name: 'zany_face', keywords: ['crazy', 'silly', 'wild'], category: 'smileys' },
      { emoji: 'ðŸ˜', name: 'stuck_out_tongue_closed_eyes', keywords: ['playful', 'silly'], category: 'smileys' },
      { emoji: 'ðŸ¤‘', name: 'money_mouth', keywords: ['money', 'rich', 'greedy'], category: 'smileys' },
      
      // Negative emotions
      { emoji: 'ðŸ˜', name: 'neutral', keywords: ['neutral', 'meh', 'ok'], category: 'smileys' },
      { emoji: 'ðŸ˜‘', name: 'expressionless', keywords: ['blank', 'meh', 'whatever'], category: 'smileys' },
      { emoji: 'ðŸ˜¶', name: 'no_mouth', keywords: ['silent', 'quiet', 'speechless'], category: 'smileys' },
      { emoji: 'ðŸ˜', name: 'smirk', keywords: ['smug', 'confident'], category: 'smileys' },
      { emoji: 'ðŸ˜’', name: 'unamused', keywords: ['annoyed', 'meh', 'bored'], category: 'smileys' },
      { emoji: 'ðŸ™„', name: 'eye_roll', keywords: ['annoyed', 'whatever', 'sarcastic'], category: 'smileys' },
      { emoji: 'ðŸ˜¬', name: 'grimacing', keywords: ['awkward', 'nervous', 'cringe'], category: 'smileys' },
      { emoji: 'ðŸ¤¥', name: 'lying', keywords: ['lie', 'pinocchio'], category: 'smileys' },
      { emoji: 'ðŸ˜Œ', name: 'relieved', keywords: ['calm', 'peaceful', 'relieved'], category: 'smileys' },
      { emoji: 'ðŸ˜”', name: 'pensive', keywords: ['sad', 'thoughtful', 'down'], category: 'smileys' },
      { emoji: 'ðŸ˜ª', name: 'sleepy', keywords: ['tired', 'sleep', 'sleepy'], category: 'smileys' },
      { emoji: 'ðŸ¤¤', name: 'drooling', keywords: ['hungry', 'desire', 'want'], category: 'smileys' },
      { emoji: 'ðŸ˜´', name: 'sleeping', keywords: ['sleep', 'tired', 'zzz'], category: 'smileys' },
      { emoji: 'ðŸ˜·', name: 'mask', keywords: ['sick', 'ill', 'covid'], category: 'smileys' },
      { emoji: 'ðŸ¤’', name: 'thermometer_face', keywords: ['sick', 'fever', 'ill'], category: 'smileys' },
      { emoji: 'ðŸ¤•', name: 'head_bandage', keywords: ['hurt', 'injured', 'sick'], category: 'smileys' },
      { emoji: 'ðŸ¤¢', name: 'nauseated', keywords: ['sick', 'gross', 'disgusted'], category: 'smileys' },
      { emoji: 'ðŸ¤®', name: 'vomiting', keywords: ['sick', 'gross', 'disgusted'], category: 'smileys' },
      { emoji: 'ðŸ¤§', name: 'sneezing', keywords: ['sick', 'sneeze', 'cold'], category: 'smileys' },
      { emoji: 'ðŸ¥µ', name: 'hot', keywords: ['hot', 'heat', 'sweating'], category: 'smileys' },
      { emoji: 'ðŸ¥¶', name: 'cold', keywords: ['cold', 'freezing', 'blue'], category: 'smileys' },
      { emoji: 'ðŸ˜µ', name: 'dizzy', keywords: ['dizzy', 'confused', 'spiral'], category: 'smileys' },
      { emoji: 'ðŸ¤¯', name: 'exploding_head', keywords: ['mind_blown', 'shocked', 'wow'], category: 'smileys' },
      { emoji: 'ðŸ˜³', name: 'flushed', keywords: ['embarrassed', 'shy', 'red'], category: 'smileys' },
      { emoji: 'ðŸ¥º', name: 'pleading', keywords: ['cute', 'puppy_eyes', 'please'], category: 'smileys' },
      { emoji: 'ðŸ˜¦', name: 'frowning', keywords: ['sad', 'disappointed'], category: 'smileys' },
      { emoji: 'ðŸ˜§', name: 'anguished', keywords: ['worried', 'anxious', 'sad'], category: 'smileys' },
      { emoji: 'ðŸ˜¨', name: 'fearful', keywords: ['scared', 'afraid', 'fear'], category: 'smileys' },
      { emoji: 'ðŸ˜°', name: 'cold_sweat', keywords: ['nervous', 'anxious', 'worried'], category: 'smileys' },
      { emoji: 'ðŸ˜¥', name: 'disappointed_relieved', keywords: ['sad', 'disappointed', 'relieved'], category: 'smileys' },
      { emoji: 'ðŸ˜¢', name: 'cry', keywords: ['sad', 'cry', 'tear'], category: 'smileys' },
      { emoji: 'ðŸ˜­', name: 'sob', keywords: ['cry', 'sad', 'tears'], category: 'smileys' },
      { emoji: 'ðŸ˜±', name: 'scream', keywords: ['scared', 'shocked', 'afraid'], category: 'smileys' },
      { emoji: 'ðŸ˜–', name: 'confounded', keywords: ['frustrated', 'confused', 'annoyed'], category: 'smileys' },
      { emoji: 'ðŸ˜£', name: 'persevere', keywords: ['frustrated', 'struggling', 'effort'], category: 'smileys' },
      { emoji: 'ðŸ˜ž', name: 'disappointed', keywords: ['sad', 'disappointed', 'down'], category: 'smileys' },
      { emoji: 'ðŸ˜“', name: 'sweat', keywords: ['tired', 'working', 'effort'], category: 'smileys' },
      { emoji: 'ðŸ˜©', name: 'weary', keywords: ['tired', 'exhausted', 'frustrated'], category: 'smileys' },
      { emoji: 'ðŸ˜«', name: 'tired_face', keywords: ['tired', 'exhausted', 'worn_out'], category: 'smileys' },
      { emoji: 'ðŸ˜¤', name: 'triumph', keywords: ['proud', 'steaming', 'huffing'], category: 'smileys' },
      { emoji: 'ðŸ˜¡', name: 'rage', keywords: ['angry', 'mad', 'furious'], category: 'smileys' },
      { emoji: 'ðŸ˜ ', name: 'angry', keywords: ['angry', 'mad', 'upset'], category: 'smileys' },
      { emoji: 'ðŸ¤¬', name: 'swearing', keywords: ['angry', 'cursing', 'mad'], category: 'smileys' },
      
      // Gestures & People
      { emoji: 'ðŸ‘', name: 'thumbs_up', keywords: ['good', 'like', 'yes', 'approve'], category: 'gestures' },
      { emoji: 'ðŸ‘Ž', name: 'thumbs_down', keywords: ['bad', 'dislike', 'no', 'disapprove'], category: 'gestures' },
      { emoji: 'ðŸ‘Œ', name: 'ok_hand', keywords: ['ok', 'good', 'perfect'], category: 'gestures' },
      { emoji: 'âœŒï¸', name: 'peace', keywords: ['peace', 'victory', 'two'], category: 'gestures' },
      { emoji: 'ðŸ¤ž', name: 'crossed_fingers', keywords: ['luck', 'hope', 'wish'], category: 'gestures' },
      { emoji: 'ðŸ¤Ÿ', name: 'love_you', keywords: ['love', 'rock', 'metal'], category: 'gestures' },
      { emoji: 'ðŸ¤˜', name: 'rock', keywords: ['rock', 'metal', 'horns'], category: 'gestures' },
      { emoji: 'ðŸ¤™', name: 'call_me', keywords: ['call', 'phone', 'shaka'], category: 'gestures' },
      { emoji: 'ðŸ‘ˆ', name: 'point_left', keywords: ['point', 'left', 'direction'], category: 'gestures' },
      { emoji: 'ðŸ‘‰', name: 'point_right', keywords: ['point', 'right', 'direction'], category: 'gestures' },
      { emoji: 'ðŸ‘†', name: 'point_up', keywords: ['point', 'up', 'direction'], category: 'gestures' },
      { emoji: 'ðŸ‘‡', name: 'point_down', keywords: ['point', 'down', 'direction'], category: 'gestures' },
      { emoji: 'â˜ï¸', name: 'index_pointing_up', keywords: ['point', 'up', 'one'], category: 'gestures' },
      { emoji: 'âœ‹', name: 'raised_hand', keywords: ['stop', 'hand', 'high_five'], category: 'gestures' },
      { emoji: 'ðŸ¤š', name: 'raised_back_of_hand', keywords: ['stop', 'hand'], category: 'gestures' },
      { emoji: 'ðŸ–ï¸', name: 'hand_with_fingers_splayed', keywords: ['hand', 'five', 'stop'], category: 'gestures' },
      { emoji: 'ðŸ––', name: 'vulcan_salute', keywords: ['spock', 'star_trek', 'vulcan'], category: 'gestures' },
      { emoji: 'ðŸ‘‹', name: 'wave', keywords: ['hello', 'goodbye', 'wave'], category: 'gestures' },
      { emoji: 'ðŸ¤', name: 'pinching_hand', keywords: ['small', 'tiny', 'little'], category: 'gestures' },
      { emoji: 'ðŸ’ª', name: 'flexed_biceps', keywords: ['strong', 'muscle', 'power'], category: 'gestures' },
      { emoji: 'ðŸ™', name: 'pray', keywords: ['thank', 'please', 'hope'], category: 'gestures' },
      
      // Hearts
      { emoji: 'â¤ï¸', name: 'heart', keywords: ['love', 'heart', 'red'], category: 'hearts' },
      { emoji: 'ðŸ§¡', name: 'orange_heart', keywords: ['love', 'heart', 'orange'], category: 'hearts' },
      { emoji: 'ðŸ’›', name: 'yellow_heart', keywords: ['love', 'heart', 'yellow'], category: 'hearts' },
      { emoji: 'ðŸ’š', name: 'green_heart', keywords: ['love', 'heart', 'green'], category: 'hearts' },
      { emoji: 'ðŸ’™', name: 'blue_heart', keywords: ['love', 'heart', 'blue'], category: 'hearts' },
      { emoji: 'ðŸ’œ', name: 'purple_heart', keywords: ['love', 'heart', 'purple'], category: 'hearts' },
      { emoji: 'ðŸ–¤', name: 'black_heart', keywords: ['love', 'heart', 'black'], category: 'hearts' },
      { emoji: 'ðŸ¤', name: 'white_heart', keywords: ['love', 'heart', 'white'], category: 'hearts' },
      { emoji: 'ðŸ¤Ž', name: 'brown_heart', keywords: ['love', 'heart', 'brown'], category: 'hearts' },
      { emoji: 'ðŸ’”', name: 'broken_heart', keywords: ['heartbreak', 'sad', 'break'], category: 'hearts' },
      { emoji: 'â£ï¸', name: 'exclamation_heart', keywords: ['love', 'exclamation'], category: 'hearts' },
      { emoji: 'ðŸ’•', name: 'two_hearts', keywords: ['love', 'hearts', 'two'], category: 'hearts' },
      { emoji: 'ðŸ’ž', name: 'revolving_hearts', keywords: ['love', 'hearts', 'spinning'], category: 'hearts' },
      { emoji: 'ðŸ’“', name: 'beating_heart', keywords: ['love', 'heartbeat', 'pulse'], category: 'hearts' },
      { emoji: 'ðŸ’—', name: 'growing_heart', keywords: ['love', 'growing', 'pink'], category: 'hearts' },
      { emoji: 'ðŸ’–', name: 'sparkling_heart', keywords: ['love', 'sparkle', 'shine'], category: 'hearts' },
      { emoji: 'ðŸ’˜', name: 'cupid', keywords: ['love', 'arrow', 'cupid'], category: 'hearts' },
      { emoji: 'ðŸ’', name: 'gift_heart', keywords: ['love', 'gift', 'present'], category: 'hearts' },
      
      // Objects & Symbols
      { emoji: 'ðŸ”¥', name: 'fire', keywords: ['hot', 'burn', 'flame'], category: 'objects' },
      { emoji: 'ðŸ’¯', name: 'hundred', keywords: ['perfect', 'score', '100'], category: 'objects' },
      { emoji: 'ðŸ’¢', name: 'anger', keywords: ['angry', 'mad', 'symbol'], category: 'objects' },
      { emoji: 'ðŸ’¥', name: 'boom', keywords: ['explosion', 'bang', 'pow'], category: 'objects' },
      { emoji: 'ðŸ’«', name: 'dizzy', keywords: ['star', 'sparkle', 'dizzy'], category: 'objects' },
      { emoji: 'ðŸ’¦', name: 'sweat_drops', keywords: ['water', 'sweat', 'splash'], category: 'objects' },
      { emoji: 'ðŸ’¨', name: 'dash', keywords: ['fast', 'wind', 'speed'], category: 'objects' },
      { emoji: 'â­', name: 'star', keywords: ['star', 'favorite', 'yellow'], category: 'objects' },
      { emoji: 'ðŸŒŸ', name: 'glowing_star', keywords: ['star', 'sparkle', 'glow'], category: 'objects' },
      { emoji: 'âœ¨', name: 'sparkles', keywords: ['sparkle', 'shine', 'magic'], category: 'objects' },
      { emoji: 'âš¡', name: 'lightning', keywords: ['electric', 'fast', 'power'], category: 'objects' },
      { emoji: 'ðŸŽ‰', name: 'party', keywords: ['celebration', 'party', 'confetti'], category: 'objects' },
      { emoji: 'ðŸŽŠ', name: 'confetti', keywords: ['celebration', 'party', 'confetti'], category: 'objects' }
    ];

    // Reaction emojis organized by category
    const reactionCategories = {
      frequent: ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ˜¡', 'ðŸ”¥', 'ðŸŽ‰'],
      smileys: ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¤©', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜'],
      hearts: ['â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ’”', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’'],
      gestures: ['ðŸ‘', 'ðŸ‘Ž', 'ðŸ‘Œ', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ‘‡', 'âœ‹', 'ðŸ‘‹', 'ðŸ’ª', 'ðŸ™'],
      objects: ['ðŸ”¥', 'ðŸ’¯', 'ðŸ’¥', 'ðŸ’«', 'â­', 'ðŸŒŸ', 'âœ¨', 'âš¡', 'ðŸŽ‰', 'ðŸŽŠ', 'ðŸ’¢', 'ðŸ’¦', 'ðŸ’¨']
    };

    // Room Color System
    const DEFAULT_COLORS = [
      { name: 'Default Blue', color: '#9ccfd8', unlocked: true },
      { name: 'Rose Red', color: '#eb6f92', unlocked: true },
      { name: 'Iris Purple', color: '#c4a7e7', unlocked: true },
      { name: 'Foam Green', color: '#9ccfd8', unlocked: true },
      { name: 'Love Pink', color: '#f6c177', unlocked: true },
      { name: 'Gold Yellow', color: '#f6c177', unlocked: true }
    ];

    const XP_UNLOCKED_COLORS = [
      { name: 'Ocean Deep', color: '#1e3a8a', requiredLevel: 2, requiredXP: 100 },
      { name: 'Forest Grove', color: '#166534', requiredLevel: 3, requiredXP: 250 },
      { name: 'Sunset Orange', color: '#ea580c', requiredLevel: 4, requiredXP: 500 },
      { name: 'Royal Purple', color: '#7c3aed', requiredLevel: 5, requiredXP: 850 },
      { name: 'Crimson Fire', color: '#dc2626', requiredLevel: 6, requiredXP: 1300 },
      { name: 'Emerald Shine', color: '#059669', requiredLevel: 7, requiredXP: 1850 },
      { name: 'Cosmic Indigo', color: '#4338ca', requiredLevel: 8, requiredXP: 2500 },
      { name: 'Magenta Blast', color: '#c2410c', requiredLevel: 9, requiredXP: 3250 },
      { name: 'Neon Green', color: '#16a34a', requiredLevel: 10, requiredXP: 4100 },
      { name: 'Electric Blue', color: '#0ea5e9', requiredLevel: 11, requiredXP: 5050 },
      { name: 'Volcano Red', color: '#b91c1c', requiredLevel: 12, requiredXP: 6100 },
      { name: 'Mystic Violet', color: '#8b5cf6', requiredLevel: 13, requiredXP: 7250 },
      { name: 'Galaxy Black', color: '#1f2937', requiredLevel: 14, requiredXP: 8500 },
      { name: 'Phoenix Gold', color: '#d97706', requiredLevel: 15, requiredXP: 9850 },
      { name: 'Divine White', color: '#f8fafc', requiredLevel: 16, requiredXP: 11300 },
      { name: 'Shadow Void', color: '#0f172a', requiredLevel: 17, requiredXP: 12850 },
      { name: 'Rainbow Prism', color: 'linear-gradient(45deg, #ff0000, #ff7700, #ffdd00, #00ff00, #0077ff, #3300ff, #7700ff)', requiredLevel: 18, requiredXP: 14500 },
      { name: 'Aurora Borealis', color: 'linear-gradient(135deg, #00ffff, #0077ff, #7700ff, #ff00ff)', requiredLevel: 19, requiredXP: 16250 },
      { name: 'Transcendent Glow', color: 'linear-gradient(45deg, #ffd700, #ffb347, #ff69b4, #9370db, #00ced1)', requiredLevel: 20, requiredXP: 18100 }
    ];

    // Color picker state
    let selectedColor = null;
    let currentUserXP = 0;
    let currentUserLevel = 1;

    // Emoji data
    const quickEmojis = [
      'ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©',
      'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜š', 'ðŸ˜™', 'ðŸ¥²', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤',
      'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜’', 'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´', 'ðŸ˜·', 'ðŸ¤’',
      'ðŸ¤•', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ˜µ', 'ðŸ¤¯', 'ðŸ¤ ', 'ðŸ¥³', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ§', 'ðŸ˜•', 'ðŸ˜Ÿ', 'ðŸ™',
      'ðŸ˜®', 'ðŸ˜¯', 'ðŸ˜²', 'ðŸ˜³', 'ðŸ¥º', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥', 'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜±', 'ðŸ˜–', 'ðŸ˜£', 'ðŸ˜ž',
      'ðŸ˜“', 'ðŸ˜©', 'ðŸ˜«', 'ðŸ¥±', 'ðŸ˜¤', 'ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸ‘Œ', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™',
      'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ‘‡', 'â˜ï¸', 'âœ‹', 'ðŸ¤š', 'ðŸ–ï¸', 'ðŸ––', 'ðŸ‘‹', 'ðŸ¤', 'ðŸ’ª', 'ðŸ¦¾', 'ðŸ–•', 'âœï¸', 'ðŸ™',
      'â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’”', 'â£ï¸', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–',
      'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'â™¥ï¸', 'ðŸ’¯', 'ðŸ’¢', 'ðŸ’¥', 'ðŸ’«', 'ðŸ’¦', 'ðŸ’¨', 'ðŸ•³ï¸', 'ðŸ’¬', 'ðŸ‘ï¸â€ðŸ—¨ï¸', 'ðŸ—¨ï¸', 'ðŸ—¯ï¸', 'ðŸ’­',
      'ðŸ”¥', 'â­', 'ðŸŒŸ', 'âœ¨', 'âš¡', 'â˜„ï¸', 'ðŸ’¥', 'ðŸ”´', 'ðŸŸ ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸ”µ', 'ðŸŸ£', 'âš«', 'âšª', 'ðŸŸ¤'
    ];

    // Content Filter Class
    class ChatContentFilter {
      constructor() {
        this.badWords = [
          'spam', 'scam', 'hack', 'cheat', 'bot', 'fake', 'phishing',
          // Add more filtered words as needed
        ];
        this.suspiciousPatterns = [
          /(.)\1{4,}/g, // Repeated characters
          /[A-Z]{10,}/g, // Excessive caps
          /(https?:\/\/[^\s]+)/g, // URLs (for security)
        ];
      }

      filter(text) {
        if (!text || typeof text !== 'string') return '';
        
        // Remove potentially harmful content
        let filtered = text.trim();
        
        // Security: Remove script tags and other dangerous content
        filtered = filtered.replace(/<script[\s\S]*?<\/script>/gi, '[SCRIPT REMOVED]');
        filtered = filtered.replace(/javascript:/gi, '[JS REMOVED]');
        filtered = filtered.replace(/on\w+\s*=/gi, '[EVENT REMOVED]');
        
        // Check for bad words
        for (const word of this.badWords) {
          const regex = new RegExp(`\\b${word}\\b`, 'gi');
          filtered = filtered.replace(regex, '*'.repeat(word.length));
        }
        
        // Apply pattern filters
        filtered = filtered.replace(/(.)\1{4,}/g, (match) => match[0].repeat(3));
        filtered = filtered.replace(/[A-Z]{10,}/g, (match) => match.toLowerCase());
        filtered = filtered.replace(/(https?:\/\/[^\s]+)/g, '[LINK REMOVED]');
        
        // Process emojis if converter is available
        if (emojiConverter) {
          filtered = emojiConverter.replace_colons(filtered);
        }
        
        return filtered.substring(0, 500); // Limit length
      }

      isAppropriate(text) {
        if (!text) return false;
        
        const originalText = text.trim();
        const filtered = this.filter(originalText);
        
        // Text is appropriate if:
        // 1. It's not empty after filtering
        // 2. It doesn't contain bad words (filtered text should be similar to original)
        // 3. No excessive repeated characters or other suspicious patterns
        
        // Check if bad words were replaced (contains asterisks)
        if (filtered.includes('*')) {
          return false;
        }
        
        // Check if the text was significantly modified by pattern filters
        const normalizedOriginal = originalText.replace(/(.)\1{4,}/g, (match) => match[0].repeat(3));
        const normalizedFiltered = filtered.replace(/\[LINK REMOVED\]/g, ''); // Remove link placeholders for comparison
        
        // Text is appropriate if it wasn't heavily modified
        return filtered.length > 0 && Math.abs(normalizedOriginal.length - normalizedFiltered.length) < originalText.length * 0.3;
      }
    }

    const contentFilter = new ChatContentFilter();

    // Sanitization functions
    function sanitizeText(text) {
      if (!text) return '';
      return DOMPurify.sanitize(text, { 
        ALLOWED_TAGS: [], 
        ALLOWED_ATTR: [] 
      }).trim();
    }

    function sanitizeHTML(html) {
      return DOMPurify.sanitize(html, {
        ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],
        ALLOWED_ATTR: []
      });
    }

    // Authentication - Make sure it's in global scope
    window.googleSignIn = async function() {
      if (!firebaseInitialized) {
        alert('Chat system is still loading. Please try again in a moment.');
        return;
      }

      try {
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.addScope('email');
        provider.addScope('profile');
        
        try {
          const result = await auth.signInWithPopup(provider);
          console.log('Signed in successfully:', result.user.email);
        } catch (popupError) {
          if (popupError.code === 'auth/popup-blocked' || 
              popupError.code === 'auth/popup-closed-by-user' ||
              popupError.message.includes('Cross-Origin-Opener-Policy')) {
            console.log('Popup blocked, using redirect method');
            await auth.signInWithRedirect(provider);
          } else {
            throw popupError;
          }
        }
      } catch (error) {
        console.error('Sign in error:', error);
        alert('Sign in failed. Please try again.');
      }
    }

    async function signOut() {
      try {
        await leaveCurrentRoom();
        await auth.signOut();
        console.log('Signed out successfully');
      } catch (error) {
        console.error('Sign out error:', error);
      }
    }

    // Room Management
    async function loadRooms() {
      if (!firebaseInitialized) {
        console.log('Firebase not initialized, cannot load rooms');
        showOfflineMessage();
        return;
      }

      try {
        // Create default room if it doesn't exist
        await ensureDefaultRoom();

        // Listen to rooms collection
        roomsListener = db.collection('chatRooms')
          .orderBy('createdAt', 'desc')
          .onSnapshot(snapshot => {
            const roomsList = document.getElementById('roomsList');
            roomsList.innerHTML = '';

            if (snapshot.empty) {
              showEmptyRoomsMessage();
              return;
            }

            snapshot.forEach(doc => {
              const room = { id: doc.id, ...doc.data() };
              displayRoom(room);
            });

            // Auto-cleanup expired rooms
            cleanupExpiredRooms();
          }, error => {
            console.error('Error in rooms snapshot listener:', error);
            if (error.code === 'unavailable' || error.message.includes('offline')) {
              showOfflineMessage();
            }
          });
      } catch (error) {
        console.error('Error loading rooms:', error);
        if (error.code === 'unavailable' || error.message.includes('offline')) {
          showOfflineMessage();
        }
      }
    }

    function showOfflineMessage() {
      const roomsList = document.getElementById('roomsList');
      roomsList.innerHTML = `
        <div class="text-center py-8 text-rp-muted">
          <i class='bx bx-wifi-off text-4xl mb-4 block'></i>
          <p>You're currently offline</p>
          <p class="text-sm mt-2">Rooms will load when connection is restored</p>
        </div>
      `;
    }

    function showEmptyRoomsMessage() {
      const roomsList = document.getElementById('roomsList');
      roomsList.innerHTML = `
        <div class="text-center py-8 text-rp-muted">
          <i class='bx bx-chat text-4xl mb-4 block'></i>
          <p>No chat rooms available</p>
          <p class="text-sm mt-2">Create a new room to get started</p>
        </div>
      `;
    }

    async function ensureDefaultRoom() {
      if (!firebaseInitialized) {
        console.log('Firebase not initialized, skipping default room creation');
        return;
      }

      try {
        const defaultRoomRef = db.collection('chatRooms').doc('default');
        const defaultRoom = await defaultRoomRef.get();

        if (!defaultRoom.exists) {
          await defaultRoomRef.set({
            name: 'General Chat',
            description: 'Welcome to the default chat room! Chat with everyone here.',
            type: 'default',
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            createdBy: 'system',
            userCount: 0,
            lastActivity: firebase.firestore.FieldValue.serverTimestamp()
          });
          console.log('Default room created');
        }
      } catch (error) {
        if (error.code === 'unavailable' || error.message.includes('offline')) {
          console.log('Cannot ensure default room while offline, will retry when online');
        } else {
          console.error('Error ensuring default room:', error);
        }
      }
    }

    function displayRoom(room) {
      const roomsList = document.getElementById('roomsList');
      const isExpired = room.type === 'temporary' && room.expiresAt && room.expiresAt.toDate() < new Date();
      
      if (isExpired) return; // Don't display expired rooms

      const roomDiv = document.createElement('div');
      roomDiv.className = `room-item ${room.type} ${currentRoomId === room.id ? 'active' : ''}`;
      roomDiv.setAttribute('data-room-id', room.id);
      roomDiv.addEventListener('click', () => joinRoom(room.id));

      let timeInfo = '';
      if (room.type === 'temporary' && room.expiresAt) {
        const timeLeft = room.expiresAt.toDate() - new Date();
        const hoursLeft = Math.floor(timeLeft / 3600000);
        const minutesLeft = Math.floor((timeLeft % 3600000) / 60000);
        
        if (timeLeft > 0) {
          timeInfo = `<div class="room-timer ${timeLeft < 600000 ? 'expiring' : ''}">
            <i class='bx bx-time'></i> ${hoursLeft}h ${minutesLeft}m left
          </div>`;
        }
      }

      roomDiv.innerHTML = `
        <div class="flex items-center justify-between">
          <div class="flex-1">
            <div class="font-semibold">${sanitizeText(room.name)}</div>
            ${room.description ? `<div class="text-sm opacity-75">${sanitizeText(room.description)}</div>` : ''}
            ${timeInfo}
          </div>
          <div class="flex items-center gap-2">
            ${room.type === 'default' ? '<i class="bx bx-crown text-rp-gold"></i>' : ''}
            ${room.type === 'temporary' ? '<i class="bx bx-clock text-rp-iris"></i>' : ''}
            <span class="user-count">${room.userCount || 0}</span>
          </div>
        </div>
      `;

      roomsList.appendChild(roomDiv);
    }

    async function joinRoom(roomId) {
      if (!currentUser) {
        alert('Please sign in to join rooms');
        return;
      }

      try {
        // Leave current room first
        await leaveCurrentRoom();

        // Join new room
        currentRoomId = roomId;
        
        // Update room user count
        await db.collection('chatRooms').doc(roomId).update({
          userCount: firebase.firestore.FieldValue.increment(1),
          lastActivity: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Update UI
        updateChatUI(roomId);
        loadMessages(roomId);
        updateRoomHighlight();

        // Add user to room presence
        await db.collection('chatRooms').doc(roomId).collection('presence').doc(currentUser.uid).set({
          userId: currentUser.uid,
          userName: currentUser.displayName || 'Anonymous',
          userPhoto: currentUser.photoURL || '',
          joinedAt: firebase.firestore.FieldValue.serverTimestamp(),
          lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
          lastActivity: firebase.firestore.FieldValue.serverTimestamp(),
          isAFK: false,
          afkSince: null
        });

        // Check if AI should be activated for this room
        const roomDoc = await db.collection('chatRooms').doc(roomId).get();
        const roomData = roomDoc.data();
        
        if (roomData && aiChatbot.shouldActivate(roomData.userCount || 0)) {
          setTimeout(() => {
            if (aiChatbot.shouldActivate(roomData.userCount || 0)) {
              aiChatbot.activate();
            }
          }, 2000); // Wait 2 seconds to see if others join
        } else {
          aiChatbot.deactivate();
        }

        // Setup AFK detection for this room
        setupAFKDetection();

        console.log('Joined room:', roomId);
      } catch (error) {
        console.error('Error joining room:', error);
        alert('Failed to join room. Please try again.');
      }
    }

    async function leaveCurrentRoom() {
      if (!currentRoomId || !currentUser) return;

      try {
        // Remove from presence
        await db.collection('chatRooms').doc(currentRoomId).collection('presence').doc(currentUser.uid).delete();

        // Decrement user count
        await db.collection('chatRooms').doc(currentRoomId).update({
          userCount: firebase.firestore.FieldValue.increment(-1)
        });

        // Clean up listeners
        if (messagesListener) {
          messagesListener();
          messagesListener = null;
        }

        if (userPresenceListener) {
          userPresenceListener();
          userPresenceListener = null;
        }

        // Cleanup AFK detection
        if (afkCheckInterval) {
          clearInterval(afkCheckInterval);
          afkCheckInterval = null;
        }

        // Remove activity listeners
        ['keypress', 'click', 'mousemove', 'scroll'].forEach(event => {
          document.removeEventListener(event, updateActivity);
        });

        activeUsers.clear();
        currentRoomId = null;
        updateChatUI();
        updateRoomHighlight();
      } catch (error) {
        console.error('Error leaving room:', error);
      }
    }

    function updateChatUI(roomId = null) {
      const chatTitle = document.getElementById('chatTitle');
      const chatSubtitle = document.getElementById('chatSubtitle');
      const messageForm = document.getElementById('messageForm');
      const leaveBtn = document.getElementById('leaveRoomBtn');
      const userCount = document.getElementById('userCount');
      const toggleUserListBtn = document.getElementById('toggleUserListBtn');
      const userListContainer = document.getElementById('userListContainer');

      if (roomId) {
        db.collection('chatRooms').doc(roomId).get().then(doc => {
          if (doc.exists) {
            const room = doc.data();
            chatTitle.textContent = room.name;
            chatSubtitle.classList.remove('hidden');
            document.getElementById('roomType').textContent = 
              room.type === 'default' ? 'Default Room' : 'Temporary Room';
            
            if (room.type === 'temporary' && room.expiresAt) {
              updateRoomTimer(room.expiresAt.toDate());
            }
          }
        });

        messageForm.classList.remove('hidden');
        leaveBtn.classList.remove('hidden');
        userCount.classList.remove('hidden');
        toggleUserListBtn.classList.remove('hidden');
        document.getElementById('customizeColorBtn').classList.remove('hidden');
        document.getElementById('xpWidget').classList.remove('hidden');
        document.getElementById('guestMessage').style.display = 'none';
        document.getElementById('chatMessages').innerHTML = '';
        
        // Initialize/update XP widget
        updateXPWidget();
        
        // Load room theme
        loadRoomTheme(roomId);
      } else {
        chatTitle.textContent = 'Select a room to start chatting';
        chatSubtitle.classList.add('hidden');
        messageForm.classList.add('hidden');
        leaveBtn.classList.add('hidden');
        userCount.classList.add('hidden');
        toggleUserListBtn.classList.add('hidden');
        userListContainer.classList.add('hidden');
        document.getElementById('customizeColorBtn').classList.add('hidden');
        document.getElementById('xpWidget').classList.add('hidden');
        
        // Remove room theme when leaving
        removeRoomTheme();
        
        if (!currentUser) {
          document.getElementById('guestMessage').style.display = 'block';
        }
      }
    }

    function updateRoomTimer(expiresAt) {
      const timer = document.getElementById('roomTimer');
      
      function updateTimer() {
        const timeLeft = expiresAt - new Date();
        if (timeLeft <= 0) {
          timer.textContent = 'Expired';
          timer.className = 'room-timer expiring';
          return;
        }

        const hours = Math.floor(timeLeft / 3600000);
        const minutes = Math.floor((timeLeft % 3600000) / 60000);
        timer.textContent = ` â€¢ Expires in ${hours}h ${minutes}m`;
        timer.className = timeLeft < 600000 ? 'room-timer expiring' : 'room-timer';
      }

      updateTimer();
      setInterval(updateTimer, 60000); // Update every minute
    }

    function updateRoomHighlight() {
      document.querySelectorAll('.room-item').forEach(item => {
        item.classList.remove('active');
      });

      if (currentRoomId) {
        const activeRoom = document.querySelector(`[data-room-id="${currentRoomId}"]`);
        if (activeRoom) {
          activeRoom.classList.add('active');
        }
      }
    }

    // Message Management
    async function sendMessage(event) {
      event.preventDefault();
      
      if (!currentUser || !currentRoomId) return;

      const messageInput = document.getElementById('messageInput');
      const content = messageInput.value.trim();

      if (!content) return;

      // Sanitize and filter content
      const sanitizedContent = sanitizeText(content);
      const filteredContent = contentFilter.filter(sanitizedContent);

      if (!filteredContent || filteredContent.length === 0) {
        alert('Message contains inappropriate content');
        return;
      }

      try {
        // Prepare message data
        const messageData = {
          content: filteredContent,
          authorId: currentUser.uid,
          authorName: currentUser.displayName || 'Anonymous',
          authorPhoto: currentUser.photoURL || '',
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          type: 'user'
        };

        // Add reply information if replying to a message
        if (replyingTo) {
          messageData.replyTo = {
            messageId: replyingTo.id,
            authorName: replyingTo.authorName,
            content: replyingTo.content.length > 100 ? replyingTo.content.substring(0, 100) + '...' : replyingTo.content,
            timestamp: replyingTo.timestamp
          };
        }

        // Send user message
        await db.collection('chatRooms').doc(currentRoomId).collection('messages').add(messageData);

        // Update room activity
        await db.collection('chatRooms').doc(currentRoomId).update({
          lastActivity: firebase.firestore.FieldValue.serverTimestamp()
        });

        messageInput.value = '';
        cancelReply(); // Clear any active reply
        updateActivity(); // Reset AFK status

        // Award XP for sending message
        const messageElement = document.getElementById('messageInput');
        awardXP(currentUser.uid, XP_REWARDS.MESSAGE, 'Message sent', messageElement);

        // Check if AI should respond (when room is empty or user is alone)
        const roomDoc = await db.collection('chatRooms').doc(currentRoomId).get();
        const roomData = roomDoc.data();
        
        if (roomData && aiChatbot.shouldActivate(roomData.userCount || 0)) {
          if (!aiChatbot.isActive) {
            aiChatbot.activate();
            // Send welcome message from AI
            setTimeout(async () => {
              await sendAIWelcomeMessage();
            }, 1000);
          } else {
            // Generate AI response
            setTimeout(async () => {
              await generateAIResponse(filteredContent);
            }, 1500 + Math.random() * 2000); // Random delay 1.5-3.5 seconds
          }
        } else if (aiChatbot.isActive && (roomData.userCount || 0) > 1) {
          aiChatbot.deactivate();
        }

      } catch (error) {
        console.error('Error sending message:', error);
        if (error.code === 'unavailable' || error.message.includes('offline')) {
          alert('Cannot send message while offline. Please check your connection.');
        } else {
          alert('Failed to send message. Please try again.');
        }
      }
    }

    async function sendAIWelcomeMessage() {
      if (!currentRoomId || !aiChatbot.isActive) return;

      const welcomeMessages = [
        "Hello! I'm your AI assistant. Since it's quiet in here, I'm here to chat with you! ðŸ˜Š",
        "Hi there! Looks like you're the only one here right now. I'm an AI and I'd love to chat!",
        "Welcome! I'm an AI assistant keeping you company while the room is empty. What's on your mind?",
        "Hey! I'm your friendly AI companion. Feel free to ask me anything or just chat!",
      ];

      const welcomeMessage = welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];

      try {
        await db.collection('chatRooms').doc(currentRoomId).collection('messages').add({
          content: welcomeMessage,
          authorId: 'ai-assistant',
          authorName: 'AI Assistant',
          authorPhoto: '',
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          type: 'ai'
        });
      } catch (error) {
        console.error('Error sending AI welcome message:', error);
      }
    }

    async function generateAIResponse(userMessage) {
      if (!currentRoomId || !aiChatbot.isActive) return;

      try {
        const aiResponse = await aiChatbot.generateResponse(userMessage);
        aiChatbot.updateConversationHistory(userMessage, aiResponse);

        await db.collection('chatRooms').doc(currentRoomId).collection('messages').add({
          content: aiResponse,
          authorId: 'ai-assistant',
          authorName: 'AI Assistant',
          authorPhoto: '',
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          type: 'ai'
        });
      } catch (error) {
        console.error('Error generating AI response:', error);
      }
    }

    function loadMessages(roomId) {
      if (messagesListener) {
        messagesListener();
      }

      messagesListener = db.collection('chatRooms').doc(roomId).collection('messages')
        .orderBy('timestamp', 'asc')
        .limit(100) // Increased limit for better conversation context
        .onSnapshot(snapshot => {
          const messagesContainer = document.getElementById('chatMessages');
          messagesContainer.innerHTML = '';

          // Clear any active reply when switching rooms
          cancelReply();

          snapshot.forEach(doc => {
            const message = { id: doc.id, ...doc.data() };
            displayMessage(message);
          });

          // Scroll to bottom
          messagesContainer.scrollTop = messagesContainer.scrollHeight;

          // Clean up old messages if there are too many
          if (snapshot.size > 80) {
            cleanupOldMessages(roomId);
          }
        });
    }

    function displayMessage(message) {
      const messagesContainer = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      
      const isOwn = currentUser && message.authorId === currentUser.uid;
      const isSystem = message.type === 'system';
      const isAI = message.type === 'ai' || message.authorId === 'ai-assistant';
      
      messageDiv.className = `message ${isOwn ? 'own' : ''} ${isSystem ? 'system' : ''} ${isAI ? 'ai' : ''}`;
      messageDiv.setAttribute('data-message-id', message.id);

      if (isSystem) {
        messageDiv.innerHTML = `
          <div class="message-content">
            <i class='bx bx-info-circle mr-2'></i>
            ${sanitizeHTML(message.content)}
          </div>
        `;
      } else if (isAI) {
        const timestamp = message.timestamp ? message.timestamp.toDate().toLocaleTimeString() : 'Sending...';
        let replyHtml = '';
        if (message.replyTo) {
          replyHtml = `
            <div class="reply-original">
              <div class="text-xs text-rp-muted">${sanitizeText(message.replyTo.authorName)}</div>
              <div class="text-sm">${sanitizeHTML(message.replyTo.content)}</div>
            </div>
          `;
        }
        
        messageDiv.innerHTML = `
          ${replyHtml}
          <div class="message-header">
            <div class="flex items-center gap-2">
              <div class="w-6 h-6 rounded-full bg-gradient-to-r from-purple-400 to-pink-400 flex items-center justify-center">
                <i class='bx bx-bot text-white text-xs'></i>
              </div>
              <span class="font-semibold text-rp-iris">${sanitizeText(message.authorName)}</span>
              <span class="text-xs bg-rp-iris text-rp-base px-2 py-0.5 rounded-full">AI</span>
            </div>
            <span class="timestamp">${timestamp}</span>
          </div>
          <div class="message-content">${sanitizeHTML(message.content)}</div>
          ${generateReactionsHTML(message)}
          <button class="reply-button" data-message-id="${message.id}" data-author-name="${sanitizeText(message.authorName)}" data-content="${sanitizeText(message.content)}">
            <i class='bx bx-reply'></i> Reply
          </button>
        `;
      } else {
        const timestamp = message.timestamp ? message.timestamp.toDate().toLocaleTimeString() : 'Sending...';
        let replyHtml = '';
        if (message.replyTo) {
          replyHtml = `
            <div class="reply-original">
              <div class="text-xs text-rp-muted">${sanitizeText(message.replyTo.authorName)}</div>
              <div class="text-sm">${sanitizeHTML(message.replyTo.content)}</div>
            </div>
          `;
        }
        
        messageDiv.innerHTML = `
          ${replyHtml}
          <div class="message-header">
            <div class="flex items-center gap-2">
              ${message.authorPhoto ? `<img src="${message.authorPhoto}" alt="Avatar" class="w-6 h-6 rounded-full clickable-avatar" data-user-id="${message.authorId}" data-user-name="${sanitizeText(message.authorName)}" data-user-photo="${message.authorPhoto}">` : '<div class="w-6 h-6 rounded-full bg-rp-foam"></div>'}
              <span class="font-semibold clickable-avatar" data-user-id="${message.authorId}" data-user-name="${sanitizeText(message.authorName)}" data-user-photo="${message.authorPhoto || ''}">${sanitizeText(message.authorName)}${getUserAFKIndicator(message.authorId)}</span>
            </div>
            <span class="timestamp">${timestamp}</span>
          </div>
          <div class="message-content">${sanitizeHTML(message.content)}</div>
          ${generateReactionsHTML(message)}
          ${currentUser ? `<button class="reply-button" data-message-id="${message.id}" data-author-name="${sanitizeText(message.authorName)}" data-content="${sanitizeText(message.content)}">
            <i class='bx bx-reply'></i> Reply
          </button>` : ''}
        `;
      }

      // Apply current theme to new message if one is active
      if (document.body.classList.contains('custom-theme')) {
        messageDiv.classList.add('custom-theme');
      }
      
      messagesContainer.appendChild(messageDiv);
    }

    // Reactions functionality
    function generateReactionsHTML(message) {
      if (!message.reactions || !currentUser) return '';

      let reactionsHTML = '<div class="message-reactions">';
      
      // Display existing reactions
      Object.entries(message.reactions).forEach(([emoji, data]) => {
        const count = data.users ? Object.keys(data.users).length : 0;
        const hasReacted = data.users && data.users[currentUser.uid];
        
        reactionsHTML += `
          <div class="reaction ${hasReacted ? 'reacted' : ''}" 
               data-message-id="${message.id}" 
               data-emoji="${emoji}">
            <span>${emoji}</span>
            <span class="reaction-count">${count}</span>
          </div>
        `;
      });

      // Add reaction button
      reactionsHTML += `
        <div class="add-reaction" data-message-id="${message.id}">
          <i class='bx bx-plus'></i>
        </div>
      `;

      reactionsHTML += '</div>';
      return reactionsHTML;
    }

    async function toggleReaction(messageId, emoji) {
      if (!currentUser || !currentRoomId) return;

      try {
        const messageRef = db.collection('chatRooms').doc(currentRoomId).collection('messages').doc(messageId);
        const messageDoc = await messageRef.get();
        
        if (!messageDoc.exists) return;

        const messageData = messageDoc.data();
        const reactions = messageData.reactions || {};
        
        if (!reactions[emoji]) {
          reactions[emoji] = { users: {} };
        }

        const userReacted = reactions[emoji].users && reactions[emoji].users[currentUser.uid];
        
        if (userReacted) {
          // Remove reaction
          delete reactions[emoji].users[currentUser.uid];
          if (Object.keys(reactions[emoji].users).length === 0) {
            delete reactions[emoji];
          }
        } else {
          // Add reaction
          reactions[emoji].users[currentUser.uid] = {
            name: currentUser.displayName || 'Anonymous',
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          };

          // Award XP for giving reaction
          awardXP(currentUser.uid, XP_REWARDS.REACTION_GIVEN, 'Reaction given');
          
          // Award XP to message author for receiving reaction
          if (messageData.authorId && messageData.authorId !== currentUser.uid) {
            awardXP(messageData.authorId, XP_REWARDS.REACTION_RECEIVED, 'Reaction received');
          }
        }

        await messageRef.update({ reactions });
      } catch (error) {
        console.error('Error toggling reaction:', error);
      }
    }

    function showReactionPicker(messageId, event) {
      event.stopPropagation();
      
      // Remove any existing picker
      const existingPicker = document.querySelector('.reaction-picker');
      if (existingPicker) {
        existingPicker.remove();
      }

      const picker = document.createElement('div');
      picker.className = 'reaction-picker';
      picker.innerHTML = `
        <div class="reaction-picker-header">
          <div class="reaction-picker-title">Add Reaction</div>
          <button onclick="this.closest('.reaction-picker').remove()" style="background: none; border: none; color: var(--theme-muted); cursor: pointer;">âœ•</button>
        </div>
        <input type="text" class="reaction-search" placeholder="Search emojis..." id="emojiSearch-${messageId}">
        <div class="reaction-tabs">
          <div class="reaction-tab active" data-category="frequent">ðŸ˜Š</div>
          <div class="reaction-tab" data-category="smileys">ðŸ˜€</div>
          <div class="reaction-tab" data-category="hearts">â¤ï¸</div>
          <div class="reaction-tab" data-category="gestures">ðŸ‘</div>
          <div class="reaction-tab" data-category="objects">ðŸ”¥</div>
        </div>
        <div class="reaction-grid" id="reactionGrid-${messageId}">
          <!-- Emojis will be populated here -->
        </div>
      `;

      // Populate initial emojis (frequent)
      updateReactionGrid(messageId, 'frequent');

      // Add event listeners
      const tabs = picker.querySelectorAll('.reaction-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          updateReactionGrid(messageId, tab.getAttribute('data-category'));
        });
      });

      // Search functionality
      const searchInput = picker.querySelector(`#emojiSearch-${messageId}`);
      let searchTimeout;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.toLowerCase();
        
        searchTimeout = setTimeout(() => {
          if (query.length > 0) {
            searchEmojis(messageId, query);
          } else {
            updateReactionGrid(messageId, 'frequent');
          }
        }, 200);
      });

      // Add click handler for emojis
      picker.addEventListener('click', (e) => {
        if (e.target.classList.contains('reaction-emoji')) {
          const emoji = e.target.textContent;
          if (emoji && messageId) {
            toggleReaction(messageId, emoji);
            picker.remove();
          }
        }
      });

      // Position and show picker
      event.target.style.position = 'relative';
      event.target.appendChild(picker);

      // Close picker when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function closePicker(e) {
          if (!picker.contains(e.target) && !event.target.contains(e.target)) {
            picker.remove();
            document.removeEventListener('click', closePicker);
          }
        });
      }, 100);
    }

    function updateReactionGrid(messageId, category) {
      const grid = document.getElementById(`reactionGrid-${messageId}`);
      if (!grid) return;

      const emojis = reactionCategories[category] || reactionCategories.frequent;
      grid.innerHTML = '';

      emojis.forEach(emoji => {
        const emojiDiv = document.createElement('div');
        emojiDiv.className = 'reaction-emoji';
        emojiDiv.textContent = emoji;
        emojiDiv.title = getEmojiName(emoji);
        grid.appendChild(emojiDiv);
      });
    }

    function searchEmojis(messageId, query) {
      const grid = document.getElementById(`reactionGrid-${messageId}`);
      if (!grid) return;

      const results = window.allEmojis.filter(emojiData => {
        const searchTerm = query.toLowerCase();
        return emojiData.name.toLowerCase().includes(searchTerm) ||
               emojiData.keywords.some(keyword => keyword.toLowerCase().includes(searchTerm));
      }).slice(0, 32); // Limit results

      grid.innerHTML = '';

      if (results.length === 0) {
        grid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: var(--theme-muted); padding: 1rem;">No emojis found</div>';
        return;
      }

      results.forEach(emojiData => {
        const emojiDiv = document.createElement('div');
        emojiDiv.className = 'reaction-emoji';
        emojiDiv.textContent = emojiData.emoji;
        emojiDiv.title = emojiData.name;
        grid.appendChild(emojiDiv);
      });
    }

    function getEmojiName(emoji) {
      const emojiData = window.allEmojis.find(e => e.emoji === emoji);
      return emojiData ? emojiData.name : emoji;
    }

    // AFK Detection functionality
    function setupAFKDetection() {
      if (!currentUser || !currentRoomId) return;

      // Track user activity
      lastActivity = Date.now();
      
      // Update activity on any user interaction
      ['keypress', 'click', 'mousemove', 'scroll'].forEach(event => {
        document.addEventListener(event, updateActivity);
      });

      // Start AFK checking interval
      afkCheckInterval = setInterval(checkAFKStatus, 30000); // Check every 30 seconds
      
      // Listen for user presence updates
      setupUserPresenceListener();
    }

    function updateActivity() {
      lastActivity = Date.now();
      
      // Update user's last activity in Firebase
      if (currentUser && currentRoomId) {
        db.collection('chatRooms').doc(currentRoomId).collection('presence').doc(currentUser.uid).update({
          lastActivity: firebase.firestore.FieldValue.serverTimestamp()
        }).catch(error => {
          console.error('Error updating activity:', error);
        });
      }
    }

    function checkAFKStatus() {
      if (!currentUser || !currentRoomId) return;

      const now = Date.now();
      const timeSinceActivity = now - lastActivity;
      const isAFK = timeSinceActivity > 5 * 60 * 1000; // 5 minutes

      // Update AFK status in Firebase
      db.collection('chatRooms').doc(currentRoomId).collection('presence').doc(currentUser.uid).update({
        isAFK: isAFK,
        afkSince: isAFK ? firebase.firestore.FieldValue.serverTimestamp() : null
      }).catch(error => {
        console.error('Error updating AFK status:', error);
      });
    }

    function setupUserPresenceListener() {
      if (!currentRoomId || userPresenceListener) return;

      userPresenceListener = db.collection('chatRooms').doc(currentRoomId).collection('presence')
        .onSnapshot(snapshot => {
          activeUsers.clear();
          
          snapshot.forEach(doc => {
            const userData = doc.data();
            activeUsers.set(doc.id, userData);
          });

          updateUsersList();
          updateUserCount();
        });
    }

    function updateUsersList() {
      const usersList = document.getElementById('activeUsersList');
      if (!usersList) return;

      usersList.innerHTML = '';

      activeUsers.forEach((userData, userId) => {
        const userItem = document.createElement('div');
        userItem.className = `user-item ${userData.isAFK ? 'afk' : ''}`;
        
        const afkIndicator = userData.isAFK ? '<span class="afk-indicator">AFK</span>' : '';
        
        userItem.innerHTML = `
          <div class="user-status ${userData.isAFK ? 'afk' : ''}"></div>
          <img src="${userData.userPhoto || 'https://via.placeholder.com/20'}" alt="Avatar" class="w-4 h-4 rounded-full">
          <span class="flex-1">${sanitizeText(userData.userName || 'Unknown')}</span>
          ${afkIndicator}
        `;
        
        usersList.appendChild(userItem);
      });
    }

    function updateUserCount() {
      const userCountEl = document.getElementById('userCount');
      if (userCountEl) {
        const activeCount = Array.from(activeUsers.values()).filter(user => !user.isAFK).length;
        const totalCount = activeUsers.size;
        userCountEl.textContent = `${activeCount}/${totalCount} users`;
      }
    }

    function toggleUserList() {
      const userListContainer = document.getElementById('userListContainer');
      userListContainer.classList.toggle('hidden');
    }

    function getUserAFKIndicator(userId) {
      if (!activeUsers.has(userId)) return '';
      const userData = activeUsers.get(userId);
      return userData.isAFK ? '<span class="afk-indicator">AFK</span>' : '';
    }

    // XP System Functions
    function calculateLevel(xp) {
      for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {
        if (xp >= LEVEL_THRESHOLDS[i].xp) {
          return LEVEL_THRESHOLDS[i];
        }
      }
      return LEVEL_THRESHOLDS[0];
    }

    function getNextLevel(currentLevel) {
      const nextLevelIndex = LEVEL_THRESHOLDS.findIndex(l => l.level === currentLevel + 1);
      return nextLevelIndex !== -1 ? LEVEL_THRESHOLDS[nextLevelIndex] : null;
    }

    async function awardXP(userId, amount, reason, element = null) {
      if (!userId || amount <= 0) return;

      try {
        const userRef = db.collection('users').doc(userId);
        const userDoc = await userRef.get();
        
        if (!userDoc.exists) {
          // Initialize user with starting XP
          await userRef.set({
            xp: amount,
            level: 1,
            levelTitle: 'Novice',
            levelTier: 'novice',
            lastXPGain: firebase.firestore.FieldValue.serverTimestamp()
          });
          
          if (element) {
            showXPReward(element, amount, reason);
          }
          return;
        }
        
        const userData = userDoc.data();
        const currentXP = userData.xp || 0;
        const currentLevel = calculateLevel(currentXP);
        const newXP = currentXP + amount;
        const newLevel = calculateLevel(newXP);
        
        // Update user XP using set with merge to handle non-existent documents
        await userRef.set({
          xp: newXP,
          level: newLevel.level,
          levelTitle: newLevel.title,
          levelTier: newLevel.tier,
          lastXPGain: firebase.firestore.FieldValue.serverTimestamp(),
          // Preserve other user data
          displayName: userData.displayName || currentUser.displayName || 'Anonymous',
          email: userData.email || currentUser.email || '',
          photoURL: userData.photoURL || currentUser.photoURL || '',
          joinDate: userData.joinDate || firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        // Show XP reward popup
        if (element && userId === currentUser.uid) {
          showXPReward(element, amount, reason);
        }

        // Check for level up
        if (newLevel.level > currentLevel.level && userId === currentUser.uid) {
          // Award level up bonus
          const bonusXP = newXP + XP_REWARDS.LEVEL_UP_BONUS;
          await userRef.set({
            xp: bonusXP,
            level: newLevel.level,
            levelTitle: newLevel.title,
            levelTier: newLevel.tier,
            lastXPGain: firebase.firestore.FieldValue.serverTimestamp(),
            displayName: userData.displayName || currentUser.displayName || 'Anonymous',
            email: userData.email || currentUser.email || '',
            photoURL: userData.photoURL || currentUser.photoURL || '',
            joinDate: userData.joinDate || firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
          
          showLevelUpNotification(newLevel);
          updateXPWidget();
        } else if (userId === currentUser.uid) {
          updateXPWidget();
        }
      } catch (error) {
        console.error('Error awarding XP:', error);
      }
    }

    function showXPReward(element, amount, reason) {
      if (!element) return;
      
      const rect = element.getBoundingClientRect();
      const popup = document.createElement('div');
      popup.className = 'xp-reward-popup';
      popup.innerHTML = `
        <div style="display: flex; align-items: center; gap: 4px;">
          <i class='bx bx-plus-circle'></i>
          <span>+${amount} XP</span>
        </div>
        <div style="font-size: 0.7rem; opacity: 0.9;">${reason}</div>
      `;
      
      popup.style.position = 'fixed';
      popup.style.left = (rect.left + rect.width / 2) + 'px';
      popup.style.top = (rect.top - 10) + 'px';
      popup.style.transform = 'translateX(-50%)';
      
      document.body.appendChild(popup);
      
      setTimeout(() => {
        popup.remove();
      }, 1500);
    }

    function showLevelUpNotification(levelData) {
      const notification = document.getElementById('levelUpNotification');
      const levelNumber = document.getElementById('newLevelNumber');
      const levelTitle = document.getElementById('levelTitleText');
      const xpReward = document.getElementById('xpRewardAmount');
      
      levelNumber.textContent = levelData.level;
      levelTitle.textContent = levelData.title;
      xpReward.textContent = XP_REWARDS.LEVEL_UP_BONUS;
      
      notification.classList.add('show');
      
      // Auto-hide after 4 seconds
      setTimeout(() => {
        notification.classList.remove('show');
      }, 4000);
    }

    function formatXPProgress(currentXP, currentLevel) {
      const nextLevel = getNextLevel(currentLevel.level);
      if (!nextLevel) {
        return { percentage: 100, current: currentXP, needed: 0, total: currentXP };
      }
      
      const currentLevelXP = currentLevel.xp;
      const nextLevelXP = nextLevel.xp;
      const progressXP = currentXP - currentLevelXP;
      const neededXP = nextLevelXP - currentLevelXP;
      const percentage = Math.round((progressXP / neededXP) * 100);
      
      return {
        percentage: Math.min(100, Math.max(0, percentage)),
        current: progressXP,
        needed: neededXP,
        total: nextLevelXP
      };
    }

    async function updateXPWidget() {
      if (!currentUser) return;
      
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data() || {};
        const currentXP = userData.xp || 0;
        const levelData = calculateLevel(currentXP);
        const progress = formatXPProgress(currentXP, levelData);
        
        // Update XP widget elements
        const userLevel = document.getElementById('userLevel');
        const userLevelTitle = document.getElementById('userLevelTitle');
        const userXPBar = document.getElementById('userXPBar');
        const userXPText = document.getElementById('userXPText');
        
        if (userLevel) userLevel.textContent = `Lv.${levelData.level}`;
        if (userLevelTitle) userLevelTitle.textContent = levelData.title;
        if (userXPBar) userXPBar.style.width = `${progress.percentage}%`;
        if (userXPText) userXPText.textContent = `${progress.current} / ${progress.needed} XP`;
        
      } catch (error) {
        console.error('Error updating XP widget:', error);
      }
    }

    function getLevelBadgeHTML(levelData) {
      const isPrestige = levelData.level >= 15;
      return `<span class="level-badge ${isPrestige ? 'prestige' : ''}" title="${levelData.title}">
        <i class='bx bx-trophy'></i>
        Lv.${levelData.level}
      </span>`;
    }

    // Room Color Customization Functions
    async function openColorPicker() {
      if (!currentUser || !currentRoomId) return;

      // Update current user XP and level
      try {
        const userDoc = await db.collection('users').doc(currentUser.uid).get();
        const userData = userDoc.data() || {};
        currentUserXP = userData.xp || 0;
        const levelData = calculateLevel(currentUserXP);
        currentUserLevel = levelData.level;
      } catch (error) {
        console.error('Error fetching user data:', error);
      }

      // Get current room color
      try {
        const roomDoc = await db.collection('chatRooms').doc(currentRoomId).get();
        const roomData = roomDoc.data() || {};
        selectedColor = roomData.customColor || null;
      } catch (error) {
        console.error('Error fetching room color:', error);
      }

      // Populate color picker
      populateColorPicker();
      
      // Show modal
      document.getElementById('colorPickerModal').classList.add('show');
    }

    function closeColorPicker() {
      document.getElementById('colorPickerModal').classList.remove('show');
      selectedColor = null;
    }

    function populateColorPicker() {
      // Populate default colors
      const defaultGrid = document.getElementById('defaultColors');
      defaultGrid.innerHTML = '';
      
      DEFAULT_COLORS.forEach((colorData, index) => {
        const colorDiv = createColorOption(colorData.color, colorData.name, true);
        if (selectedColor === colorData.color) {
          colorDiv.classList.add('selected');
        }
        defaultGrid.appendChild(colorDiv);
      });

      // Populate XP unlocked colors
      const xpGrid = document.getElementById('xpColors');
      xpGrid.innerHTML = '';
      
      XP_UNLOCKED_COLORS.forEach((colorData, index) => {
        const isUnlocked = currentUserXP >= colorData.requiredXP;
        const colorDiv = createColorOption(colorData.color, colorData.name, isUnlocked, colorData);
        if (selectedColor === colorData.color) {
          colorDiv.classList.add('selected');
        }
        if (!isUnlocked) {
          colorDiv.classList.add('locked');
        }
        xpGrid.appendChild(colorDiv);
      });

      // Setup custom color picker
      const customRequirement = document.getElementById('customColorRequirement');
      const customPicker = document.getElementById('customColorPicker');
      const colorPreview = document.getElementById('colorPreview');
      
      const canUseCustom = currentUserLevel >= 10; // Platinum level
      if (canUseCustom) {
        customRequirement.classList.add('unlocked');
        customRequirement.innerHTML = '<i class="bx bx-check"></i><span>Custom colors unlocked!</span>';
        customPicker.disabled = false;
        
        customPicker.addEventListener('input', (e) => {
          const color = e.target.value;
          selectedColor = color;
          colorPreview.style.background = color;
          colorPreview.textContent = 'Custom Color Selected';
          
          // Clear other selections
          document.querySelectorAll('.color-option.selected').forEach(el => {
            el.classList.remove('selected');
          });
        });
      } else {
        customRequirement.classList.remove('unlocked');
        customRequirement.innerHTML = '<i class="bx bx-lock"></i><span>Unlock at Level 10 (Platinum)</span>';
        customPicker.disabled = true;
      }
    }

    function createColorOption(color, name, unlocked, colorData = null) {
      const colorDiv = document.createElement('div');
      colorDiv.className = 'color-option';
      
      // Handle gradient colors
      if (color.includes('gradient')) {
        colorDiv.style.background = color;
      } else {
        colorDiv.style.backgroundColor = color;
      }
      
      // Add label
      const label = document.createElement('div');
      label.className = 'color-option-label';
      if (colorData && !unlocked) {
        label.textContent = `${name} (Lv.${colorData.requiredLevel})`;
      } else {
        label.textContent = name;
      }
      colorDiv.appendChild(label);
      
      if (unlocked) {
        colorDiv.addEventListener('click', () => {
          // Clear previous selections
          document.querySelectorAll('.color-option.selected').forEach(el => {
            el.classList.remove('selected');
          });
          
          // Select this color
          colorDiv.classList.add('selected');
          selectedColor = color;
          
          // Update custom color preview if needed
          const colorPreview = document.getElementById('colorPreview');
          colorPreview.style.background = color;
          colorPreview.textContent = 'Selected: ' + name;
        });
      } else {
        colorDiv.addEventListener('click', () => {
          if (colorData) {
            alert(`This color requires Level ${colorData.requiredLevel} (${colorData.requiredXP} XP). You are currently Level ${currentUserLevel} (${currentUserXP} XP).`);
          }
        });
      }
      
      return colorDiv;
    }

    async function applyRoomColor() {
      console.log("Applying room color:", { selectedColor, currentRoomId, currentUser: !!currentUser });
      
      if (!selectedColor || !currentRoomId || !currentUser) {
        console.error("Missing required data for room color:", { selectedColor, currentRoomId, currentUser: !!currentUser });
        alert('Please select a color and make sure you are in a room.');
        return;
      }

      try {
        console.log("Updating Firestore with color:", selectedColor);
        
        // Update room with custom color using set with merge
        await db.collection('chatRooms').doc(currentRoomId).set({
          customColor: selectedColor,
          lastColorUpdate: firebase.firestore.FieldValue.serverTimestamp(),
          colorUpdatedBy: currentUser.uid
        }, { merge: true });

        console.log("Successfully updated room color in Firestore");

        // Apply the color to UI immediately
        applyRoomTheme(selectedColor);
        
        // Close modal
        closeColorPicker();
        
        // Show success message
        const chatMessages = document.getElementById('chatMessages');
        if (chatMessages) {
          showXPReward(chatMessages, 0, 'Room color updated!');
        }
        
        console.log("Room color application completed");
        
      } catch (error) {
        console.error('Error applying room color:', error);
        console.error('Error details:', error.code, error.message);
        alert(`Failed to update room color: ${error.message || error.code || 'Unknown error'}`);
      }
    }

    function applyRoomTheme(color) {
      if (!color) {
        console.log("No color provided to applyRoomTheme");
        return;
      }

      console.log("Applying full-page room theme with color:", color);

      // Convert hex to RGB for CSS variables
      let rgbColor = '';
      if (color.startsWith('#')) {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        rgbColor = `${r}, ${g}, ${b}`;
      } else if (color.includes('gradient')) {
        // For gradients, extract first color for RGB
        const firstColor = color.match(/#[0-9a-fA-F]{6}/);
        if (firstColor) {
          const hex = firstColor[0];
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          rgbColor = `${r}, ${g}, ${b}`;
        }
      }
      
      // Set CSS custom properties
      document.documentElement.style.setProperty('--room-color', color);
      if (rgbColor) {
        document.documentElement.style.setProperty('--room-color-rgb', rgbColor);
      }
      
      console.log("Set CSS variables:", { 
        roomColor: document.documentElement.style.getPropertyValue('--room-color'),
        rgbColor: document.documentElement.style.getPropertyValue('--room-color-rgb')
      });
      
      // Apply theme to entire page
      const body = document.body;
      const container = document.querySelector('.container');
      const sidebar = document.querySelector('.sidebar');
      const chatMain = document.querySelector('.chat-main');
      const chatHeader = document.querySelector('.chat-header');
      const chatInputArea = document.querySelector('.chat-input-area');
      const xpWidget = document.querySelector('.xp-widget');
      const userList = document.querySelector('.user-list');
      
      // Add custom-theme class to all major elements
      if (body) body.classList.add('custom-theme');
      if (container) container.classList.add('custom-theme');
      if (sidebar) sidebar.classList.add('custom-theme');
      if (chatMain) chatMain.classList.add('custom-theme');
      if (chatHeader) chatHeader.classList.add('custom-theme');
      if (chatInputArea) chatInputArea.classList.add('custom-theme');
      if (xpWidget) xpWidget.classList.add('custom-theme');
      if (userList) userList.classList.add('custom-theme');
      
      // Apply to all messages
      const messages = document.querySelectorAll('.message');
      messages.forEach(message => {
        message.classList.add('custom-theme');
      });
      
      // Apply to all room items, but highlight the current one
      const roomItems = document.querySelectorAll('.room-item');
      roomItems.forEach(item => {
        item.classList.add('custom-theme');
      });
      
      // Apply to all buttons
      const primaryButtons = document.querySelectorAll('.btn-primary');
      const secondaryButtons = document.querySelectorAll('.btn-secondary');
      primaryButtons.forEach(btn => btn.classList.add('custom-theme'));
      secondaryButtons.forEach(btn => btn.classList.add('custom-theme'));
      
      // Apply to XP bar
      const xpBar = document.querySelector('.xp-bar');
      if (xpBar) xpBar.classList.add('custom-theme');

      console.log("Applied full-page theme to all elements");
    }

    function removeRoomTheme() {
      console.log("Removing full-page room theme");
      
      // Remove custom-theme class from all elements
      const elements = document.querySelectorAll('.custom-theme');
      elements.forEach(el => el.classList.remove('custom-theme'));
      
      // Remove CSS custom properties
      document.documentElement.style.removeProperty('--room-color');
      document.documentElement.style.removeProperty('--room-color-rgb');
      
      console.log("Removed theme from all page elements");
    }

    async function loadRoomTheme(roomId) {
      if (!roomId) return;

      try {
        const roomDoc = await db.collection('chatRooms').doc(roomId).get();
        const roomData = roomDoc.data() || {};
        
        if (roomData.customColor) {
          applyRoomTheme(roomData.customColor);
        } else {
          removeRoomTheme();
        }
      } catch (error) {
        console.error('Error loading room theme:', error);
      }
    }



    // Room Creation
    function showCreateRoomModal() {
      if (!currentUser) {
        alert('Please sign in to create rooms');
        return;
      }
      
      document.getElementById('createRoomModal').classList.add('show');
    }

    function hideCreateRoomModal() {
      document.getElementById('createRoomModal').classList.remove('show');
      document.getElementById('createRoomForm').reset();
      clearRoomNameError();
    }

    function clearRoomNameError() {
      document.getElementById('roomNameError').classList.add('hidden');
      document.getElementById('roomName').classList.remove('input-error');
    }

    // Reply functionality
    function startReply(messageId, authorName, content) {
      if (!currentUser) return;
      
      replyingTo = {
        id: messageId,
        authorName: authorName,
        content: content
      };
      
      // Show reply preview
      const replyPreview = document.getElementById('replyPreview');
      const replyPreviewContent = document.getElementById('replyPreviewContent');
      
      replyPreviewContent.innerHTML = `
        <div class="font-semibold text-rp-foam">${sanitizeText(authorName)}</div>
        <div class="text-rp-text">${sanitizeHTML(content.length > 100 ? content.substring(0, 100) + '...' : content)}</div>
      `;
      
      replyPreview.classList.remove('hidden');
      
      // Focus on message input
      const messageInput = document.getElementById('messageInput');
      messageInput.focus();
      messageInput.placeholder = `Reply to ${authorName}...`;
    }

    function cancelReply() {
      replyingTo = null;
      
      // Hide reply preview
      const replyPreview = document.getElementById('replyPreview');
      replyPreview.classList.add('hidden');
      
      // Reset message input placeholder
      const messageInput = document.getElementById('messageInput');
      messageInput.placeholder = 'Type your message...';
    }

    // Profile viewing functions
    async function showUserProfile(userId, userName, userPhoto) {
      if (!userId || userId === 'ai-assistant') {
        return; // Don't show profile for AI
      }

      const modal = document.getElementById('profileModal');
      const avatar = document.getElementById('profileModalAvatar');
      const name = document.getElementById('profileModalName');
      const status = document.getElementById('profileModalStatus');
      const bio = document.getElementById('profileModalBio');
      const joined = document.getElementById('profileModalJoined');
      const viewFullBtn = document.getElementById('viewFullProfileBtn');

      // Set basic info
      avatar.src = userPhoto || 'https://via.placeholder.com/80';
      name.textContent = userName || 'Unknown User';
      status.textContent = 'Loading...';
      bio.textContent = 'Loading...';
      joined.textContent = 'Loading...';

      // Show modal
      modal.classList.remove('hidden');

      try {
        // Fetch user profile data
        const userDoc = await db.collection('users').doc(userId).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          
          // Update modal with user data
          status.textContent = `Status: ${userData.status || 'Unknown'}`;
          bio.textContent = userData.bio || 'No bio available';
          
          if (userData.createdAt) {
            const joinDate = userData.createdAt.toDate ? userData.createdAt.toDate() : new Date(userData.createdAt);
            joined.textContent = joinDate.toLocaleDateString();
          } else {
            joined.textContent = 'Unknown';
          }

          // Set up view full profile button
          viewFullBtn.onclick = () => {
            window.open(`/profile.html?uid=${userId}`, '_blank');
          };
        } else {
          status.textContent = 'User not found';
          bio.textContent = 'No profile data available';
          joined.textContent = 'Unknown';
          viewFullBtn.style.display = 'none';
        }
      } catch (error) {
        console.error('Error fetching user profile:', error);
        status.textContent = 'Error loading profile';
        bio.textContent = 'Could not load profile data';
        joined.textContent = 'Unknown';
      }
    }

    function closeProfileModal() {
      const modal = document.getElementById('profileModal');
      modal.classList.add('hidden');
    }

    // Secure event handling
    function setupSecureEventListeners() {
      // Reply button event delegation
      document.addEventListener('click', (e) => {
        if (e.target.closest('.reply-button')) {
          const button = e.target.closest('.reply-button');
          const messageId = button.getAttribute('data-message-id');
          const authorName = button.getAttribute('data-author-name');
          const content = button.getAttribute('data-content');
          
          if (messageId && authorName && content) {
            startReply(messageId, authorName, content);
          }
        }
      });

      // Profile viewing event delegation
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('clickable-avatar')) {
          const userId = e.target.getAttribute('data-user-id');
          const userName = e.target.getAttribute('data-user-name');
          const userPhoto = e.target.getAttribute('data-user-photo');
          
          if (userId) {
            showUserProfile(userId, userName, userPhoto);
          }
        }
      });

      // Close profile modal when clicking outside
      document.addEventListener('click', (e) => {
        const modal = document.getElementById('profileModal');
        if (e.target === modal) {
          closeProfileModal();
        }
      });

      // Reaction click handlers
      document.addEventListener('click', (e) => {
        if (e.target.closest('.reaction')) {
          const reaction = e.target.closest('.reaction');
          const messageId = reaction.getAttribute('data-message-id');
          const emoji = reaction.getAttribute('data-emoji');
          
          if (messageId && emoji) {
            toggleReaction(messageId, emoji);
          }
        }
      });

      // Add reaction button handlers
      document.addEventListener('click', (e) => {
        if (e.target.closest('.add-reaction')) {
          const button = e.target.closest('.add-reaction');
          const messageId = button.getAttribute('data-message-id');
          
          if (messageId) {
            showReactionPicker(messageId, e);
          }
        }
      });
    }

    async function createRoom(event) {
      event.preventDefault();
      
      if (!currentUser) return;

      const roomName = sanitizeText(document.getElementById('roomName').value);
      const roomDescription = sanitizeText(document.getElementById('roomDescription').value);
      const roomDuration = parseInt(document.getElementById('roomDuration').value);

      // Validate room name
      if (!contentFilter.isAppropriate(roomName)) {
        console.log('Room name rejected:', roomName, 'Filtered:', contentFilter.filter(roomName));
        document.getElementById('roomNameError').classList.remove('hidden');
        document.getElementById('roomName').classList.add('input-error');
        return;
      }

      try {
        const expiresAt = new Date(Date.now() + roomDuration);
        
        const roomRef = await db.collection('chatRooms').add({
          name: roomName,
          description: roomDescription,
          type: 'temporary',
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          createdBy: currentUser.uid,
          creatorName: currentUser.displayName || 'Anonymous',
          expiresAt: firebase.firestore.Timestamp.fromDate(expiresAt),
          userCount: 0,
          lastActivity: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Add creation message
        await roomRef.collection('messages').add({
          content: `Room "${roomName}" created by ${currentUser.displayName || 'Anonymous'}`,
          type: 'system',
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });

        hideCreateRoomModal();
        joinRoom(roomRef.id);
      } catch (error) {
        console.error('Error creating room:', error);
        alert('Failed to create room. Please try again.');
      }
    }

    // Cleanup Functions
    async function cleanupExpiredRooms() {
      if (!firebaseInitialized) return;

      try {
        const now = new Date();
        const expiredRooms = await db.collection('chatRooms')
          .where('type', '==', 'temporary')
          .where('expiresAt', '<', firebase.firestore.Timestamp.fromDate(now))
          .get();

        const batch = db.batch();
        
        for (const doc of expiredRooms.docs) {
          await cleanupRoomCompletely(doc.ref, batch);
        }

        if (!expiredRooms.empty) {
          await batch.commit();
          console.log(`Cleaned up ${expiredRooms.size} expired rooms`);
        }
      } catch (error) {
        console.error('Error cleaning up expired rooms:', error);
      }
    }

    async function cleanupRoomCompletely(roomRef, batch = null) {
      const shouldCommit = !batch;
      if (!batch) batch = db.batch();

      try {
        // Delete messages subcollection in smaller batches
        const messages = await roomRef.collection('messages').orderBy('timestamp', 'desc').limit(100).get();
        messages.docs.forEach(messageDoc => {
          batch.delete(messageDoc.ref);
        });

        // Delete presence subcollection
        const presence = await roomRef.collection('presence').get();
        presence.docs.forEach(presenceDoc => {
          batch.delete(presenceDoc.ref);
        });

        // Delete room document
        batch.delete(roomRef);

        if (shouldCommit) {
          await batch.commit();
        }

        // If there were 100 messages, there might be more
        if (messages.size === 100) {
          setTimeout(() => cleanupRoomCompletely(roomRef), 1000);
        }
      } catch (error) {
        console.error('Error cleaning up room completely:', error);
      }
    }

    async function cleanupOldMessages(roomId) {
      if (!firebaseInitialized) return;

      try {
        // Get messages older than 24 hours, keeping only the most recent 50
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        const oldMessages = await db.collection('chatRooms').doc(roomId).collection('messages')
          .where('timestamp', '<', firebase.firestore.Timestamp.fromDate(oneDayAgo))
          .orderBy('timestamp', 'asc')
          .limit(20) // Delete in small batches
          .get();

        if (!oldMessages.empty) {
          const batch = db.batch();
          oldMessages.docs.forEach(doc => {
            batch.delete(doc.ref);
          });
          
          await batch.commit();
          console.log(`Cleaned up ${oldMessages.size} old messages from room ${roomId}`);
        }
      } catch (error) {
        console.error('Error cleaning up old messages:', error);
      }
    }

    async function cleanupInactiveRooms() {
      if (!firebaseInitialized) return;

      try {
        // Clean up temporary rooms with no activity for 2 hours
        const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
        const inactiveRooms = await db.collection('chatRooms')
          .where('type', '==', 'temporary')
          .where('lastActivity', '<', firebase.firestore.Timestamp.fromDate(twoHoursAgo))
          .where('userCount', '==', 0)
          .get();

        const batch = db.batch();
        for (const doc of inactiveRooms.docs) {
          await cleanupRoomCompletely(doc.ref, batch);
        }

        if (!inactiveRooms.empty) {
          await batch.commit();
          console.log(`Cleaned up ${inactiveRooms.size} inactive rooms`);
        }
      } catch (error) {
        console.error('Error cleaning up inactive rooms:', error);
      }
    }

    // User Interface Management
    function updateUserSection() {
      const userSection = document.getElementById('userSection');
      const signInBtn = document.getElementById('signInBtn');
      const createRoomBtn = document.getElementById('createRoomBtn');
      const roomManagement = document.getElementById('roomManagement');
      const guestMessage = document.getElementById('guestMessage');
      const messageForm = document.getElementById('messageForm');

      if (currentUser) {
        userSection.innerHTML = `
          <div class="flex items-center gap-3">
            <img src="${currentUser.photoURL || 'https://via.placeholder.com/32'}" alt="Profile" class="w-8 h-8 rounded-full">
            <span class="text-rp-text font-medium hidden md:block">${sanitizeText(currentUser.displayName || 'User')}</span>
            <button onclick="signOut()" class="btn-secondary">
              <i class='bx bx-log-out'></i>
            </button>
          </div>
        `;
        
        createRoomBtn.classList.remove('hidden');
        roomManagement.classList.remove('hidden');
        guestMessage.style.display = 'none';
        
        if (currentRoomId) {
          messageForm.classList.remove('hidden');
        }
      } else {
        userSection.innerHTML = `
          <button onclick="googleSignIn()" class="btn-primary">
            <i class='bx bxl-google mr-2'></i>
            Sign In
          </button>
        `;
        
        createRoomBtn.classList.add('hidden');
        roomManagement.classList.add('hidden');
        messageForm.classList.add('hidden');
        guestMessage.style.display = 'block';
      }
    }

    // Auth State Management
    function startAuthMonitoring() {
      if (!firebaseInitialized) {
        setTimeout(startAuthMonitoring, 100);
        return;
      }

      auth.onAuthStateChanged(async (user) => {
        console.log('Auth state changed:', user ? `Signed in as ${user.email}` : 'Signed out');
        
        if (user) {
          currentUser = user;
          
          // Handle redirect result
          try {
            const result = await auth.getRedirectResult();
            if (result && result.user) {
              console.log('Redirect sign-in successful');
            }
          } catch (error) {
            console.error('Redirect result error:', error);
          }
        } else {
          await leaveCurrentRoom();
          currentUser = null;
        }

        updateUserSection();
      });
    }

    // Initialize Chat System
    function initializeChatSystem() {
      // Start automatic cleanup every 30 minutes for expired rooms
      cleanupInterval = setInterval(() => {
        cleanupExpiredRooms();
        cleanupInactiveRooms();
      }, 30 * 60 * 1000);
      
      // Start message cleanup every 2 hours
      messageCleanupInterval = setInterval(() => {
        if (currentRoomId) {
          cleanupOldMessages(currentRoomId);
        }
      }, 2 * 60 * 60 * 1000);
      
      // Load rooms
      loadRooms();
      
      // Initialize UI
      updateUserSection();
      
      // Start auth monitoring
      startAuthMonitoring();

      // Initial cleanup on startup
      setTimeout(() => {
        cleanupExpiredRooms();
        cleanupInactiveRooms();
      }, 5000);

      // Handle page unload
      window.addEventListener('beforeunload', () => {
        leaveCurrentRoom();
        if (cleanupInterval) {
          clearInterval(cleanupInterval);
        }
        if (messageCleanupInterval) {
          clearInterval(messageCleanupInterval);
        }
      });

      console.log('Chat system initialized with enhanced cleanup');
    }

    // Wait for Firebase and initialize
    function waitForFirebaseAndStartChat() {
      if (firebaseInitialized) {
        initializeChatSystem();
      } else {
        setTimeout(waitForFirebaseAndStartChat, 100);
      }
    }

    // Ensure all functions are available in global scope for onclick handlers
    window.showCreateRoomModal = showCreateRoomModal;
    window.hideCreateRoomModal = hideCreateRoomModal;
    window.cleanupExpiredRooms = cleanupExpiredRooms;
    window.cleanupInactiveRooms = cleanupInactiveRooms;
    window.cleanupOldMessages = cleanupOldMessages;
    window.toggleUserList = toggleUserList;
    window.openColorPicker = openColorPicker;
    window.closeColorPicker = closeColorPicker;
    window.applyRoomColor = applyRoomColor;
    window.leaveCurrentRoom = leaveCurrentRoom;
    window.cancelReply = cancelReply;
    window.closeProfileModal = closeProfileModal;
    window.signOut = signOut;

                      // Start when page loads
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Chat page loaded');
      setupNetworkMonitoring(); // Start network monitoring
      updateConnectionStatus(); // Set initial status
      setupSecureEventListeners(); // Setup secure event handling
      waitForFirebaseAndStartChat();
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideCreateRoomModal();
      }
    });

    // Click outside modal to close
    document.getElementById('createRoomModal').addEventListener('click', (e) => {
      if (e.target.id === 'createRoomModal') {
        hideCreateRoomModal();
      }
    });
  </script>
</body>
</html>