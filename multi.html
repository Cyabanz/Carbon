<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Carbon Multi - Multiplayer Games</title>
    <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Updated Firebase SDK to match index.html -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
    
    <style>
        :root {
            --theme-base: #191724;
            --theme-surface: #1f1d2e;
            --theme-overlay: #26233a;
            --theme-muted: #6e6a86;
            --theme-subtle: #908caa;
            --theme-text: #e0def4;
            --theme-love: #eb6f92;
            --theme-gold: #f6c177;
            --theme-rose: #ebbcba;
            --theme-pine: #31748f;
            --theme-foam: #9ccfd8;
            --theme-iris: #c4a7e7;
            --theme-highlight-low: #21202e;
            --theme-highlight-med: #403d52;
            --theme-highlight-high: #524f67;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: var(--theme-base);
            color: var(--theme-text);
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }
        
        .game-canvas {
            border: 2px solid var(--theme-highlight-med);
            border-radius: 8px;
            background: var(--theme-surface);
        }
        
        .paddle {
            background: var(--theme-foam);
            border-radius: 4px;
        }
        
        .ball {
            background: var(--theme-love);
            border-radius: 50%;
        }
        
        .puck {
            background: var(--theme-gold);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--theme-gold);
        }
        
        .race-car {
            background: var(--theme-iris);
            border-radius: 4px;
            transition: transform 0.1s;
        }
        
        .obstacle {
            background: var(--theme-love);
            border-radius: 2px;
        }
        
        .typing-cursor {
            border-right: 2px solid var(--theme-foam);
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .reaction-zone {
            transition: all 0.3s ease;
        }
        
        .bg-surface { background: var(--theme-surface); }
        .bg-overlay { background: var(--theme-overlay); }
        .bg-highlight-med { background: var(--theme-highlight-med); }
        .bg-highlight-high { background: var(--theme-highlight-high); }
        .text-text { color: var(--theme-text); }
        .text-muted { color: var(--theme-muted); }
        .text-love { color: var(--theme-love); }
        .text-gold { color: var(--theme-gold); }
        .text-foam { color: var(--theme-foam); }
        .text-iris { color: var(--theme-iris); }
        .text-pine { color: var(--theme-pine); }
        .border-highlight-med { border-color: var(--theme-highlight-med); }

        /* Enhanced notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 350px;
            padding: 16px;
            border-radius: 8px;
            color: white;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        }

        .notification.success { background: #22c55e; }
        .notification.error { background: #ef4444; }
        .notification.warning { background: #f59e0b; }
        .notification.info { background: #3b82f6; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Loading spinner */
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--theme-foam);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal styles */
        .modal-backdrop {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .game-canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            
            #racing-canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            
            .grid {
                grid-template-columns: 1fr !important;
            }
            
            /* Make reaction zone larger on mobile */
            #reaction-zone {
                min-height: 200px !important;
                font-size: 1.25rem !important;
            }
            
            /* Improve button sizes for touch */
            button {
                min-height: 44px;
                min-width: 44px;
            }
            
            /* Better spacing on mobile */
            .p-6 {
                padding: 1rem !important;
            }
            
            .mx-4 {
                margin-left: 0.5rem !important;
                margin-right: 0.5rem !important;
            }
        }

        /* Touch device specific styles */
        @media (hover: none) and (pointer: coarse) {
            .hover\:border-foam {
                border-color: var(--theme-foam);
            }
            
            .hover\:bg-foam\/80 {
                background-color: rgba(156, 207, 216, 0.8);
            }
            
            /* Visual feedback for touch */
            button:active, .cursor-pointer:active {
                transform: scale(0.98);
                transition: transform 0.1s;
            }
        }
    </style>
</head>
<body>
    <div class="min-h-screen bg-base">
        <!-- Header -->
        <header class="bg-surface border-b border-highlight-med p-4">
            <div class="max-w-6xl mx-auto flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <i class="bx bx-game text-3xl text-iris"></i>
                    <h1 class="text-2xl font-bold text-text">Carbon Multi</h1>
                    <span class="text-muted">Real-time Multiplayer Games</span>
                </div>
                <div id="auth-section">
                    <!-- Auth buttons will be inserted here -->
                </div>
            </div>
        </header>

        <!-- Authentication Screen -->
        <div id="auth-screen" class="min-h-screen flex items-center justify-center">
            <div class="bg-surface border border-highlight-med rounded-xl p-8 max-w-md w-full mx-4">
                <div class="text-center mb-8">
                    <i class="bx bx-game text-6xl text-iris mb-4"></i>
                    <h2 class="text-3xl font-bold text-text mb-2">Carbon Multi</h2>
                    <p class="text-muted">Sign in to play multiplayer games</p>
                </div>
                
                <div class="space-y-4">
                    <button onclick="signInWithGoogle()" 
                            class="w-full flex items-center justify-center gap-3 px-6 py-3 bg-white hover:bg-gray-100 text-gray-800 rounded-lg font-medium transition-colors">
                        <i class="bx bxl-google text-xl"></i>
                        Continue with Google
                    </button>
                    
                    <div class="text-center text-muted">
                        <span>or</span>
                    </div>
                    
                    <button onclick="signInAnonymously()" 
                            class="w-full px-6 py-3 bg-foam hover:bg-foam/80 text-black rounded-lg font-medium transition-colors">
                        <i class="bx bx-user mr-2"></i>
                        Play as Guest
                    </button>
                </div>
                
                <p class="text-xs text-muted text-center mt-6">
                    Your game data will be synced across devices when signed in
                </p>
            </div>
        </div>

        <!-- Main Content -->
        <main id="main-content" class="max-w-6xl mx-auto p-6 hidden">
            <!-- Game Selection -->
            <div id="game-selection" class="space-y-6">
                <div class="text-center mb-8">
                    <h2 class="text-3xl font-bold text-text mb-2">Choose Your Game</h2>
                    <p class="text-muted">Select a multiplayer game to play with friends</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Ping Pong/Air Hockey -->
                    <div class="bg-surface border border-highlight-med rounded-xl p-6 hover:border-foam transition-colors cursor-pointer" onclick="selectGame('pong')">
                        <div class="flex items-center gap-4 mb-4">
                            <div class="w-16 h-16 bg-foam/20 rounded-lg flex items-center justify-center">
                                <i class="bx bx-tennis-ball text-3xl text-foam"></i>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold text-text">Ping Pong</h3>
                                <p class="text-muted">Real-time paddle action</p>
                            </div>
                        </div>
                        <p class="text-text mb-4">Control your paddle and hit the ball to score against your opponent. Real-time movement synchronization makes it feel like you're playing side by side!</p>
                        <div class="flex items-center gap-2 text-foam">
                            <i class="bx bx-group"></i>
                            <span>2 Players</span>
                        </div>
                    </div>

                    <!-- Typing Duel -->
                    <div class="bg-surface border border-highlight-med rounded-xl p-6 hover:border-gold transition-colors cursor-pointer" onclick="selectGame('typing')">
                        <div class="flex items-center gap-4 mb-4">
                            <div class="w-16 h-16 bg-gold/20 rounded-lg flex items-center justify-center">
                                <i class="bx bx-keyboard text-3xl text-gold"></i>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold text-text">Typing Duel</h3>
                                <p class="text-muted">Speed typing challenge</p>
                            </div>
                        </div>
                        <p class="text-text mb-4">Race to type the sentence correctly! Watch your opponent's progress in real-time as you both type. First to complete wins!</p>
                        <div class="flex items-center gap-2 text-gold">
                            <i class="bx bx-group"></i>
                            <span>2 Players</span>
                        </div>
                    </div>

                    <!-- Reaction Time Test -->
                    <div class="bg-surface border border-highlight-med rounded-xl p-6 hover:border-love transition-colors cursor-pointer" onclick="selectGame('reaction')">
                        <div class="flex items-center gap-4 mb-4">
                            <div class="w-16 h-16 bg-love/20 rounded-lg flex items-center justify-center">
                                <i class="bx bx-stopwatch text-3xl text-love"></i>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold text-text">Reaction Test</h3>
                                <p class="text-muted">Lightning-fast reflexes</p>
                            </div>
                        </div>
                        <p class="text-text mb-4">Test your reaction speed! When the screen changes color, tap as fast as possible. Best of 5 rounds wins the duel!</p>
                        <div class="flex items-center gap-2 text-love">
                            <i class="bx bx-group"></i>
                            <span>2 Players</span>
                        </div>
                    </div>

                    <!-- Mini Racing -->
                    <div class="bg-surface border border-highlight-med rounded-xl p-6 hover:border-iris transition-colors cursor-pointer" onclick="selectGame('racing')">
                        <div class="flex items-center gap-4 mb-4">
                            <div class="w-16 h-16 bg-iris/20 rounded-lg flex items-center justify-center">
                                <i class="bx bx-car text-3xl text-iris"></i>
                            </div>
                            <div>
                                <h3 class="text-xl font-bold text-text">Mini Racing</h3>
                                <p class="text-muted">High-speed track racing</p>
                            </div>
                        </div>
                        <p class="text-text mb-4">Race on a looping track and avoid obstacles! Use arrow keys to steer and try to complete more laps than your opponent!</p>
                        <div class="flex items-center gap-2 text-iris">
                            <i class="bx bx-group"></i>
                            <span>2 Players</span>
                        </div>
                    </div>
                </div>

                <div class="text-center space-y-4">
                    <button onclick="findRandomGame()" class="px-8 py-3 bg-foam hover:bg-foam/80 text-black rounded-lg font-bold transition-colors">
                        <i class="bx bx-shuffle mr-2"></i>
                        Find Random Game
                    </button>
                    
                    <div class="text-muted">or</div>
                    
                    <button onclick="showJoinRoomModal()" class="px-8 py-3 bg-iris hover:bg-iris/80 text-white rounded-lg font-bold transition-colors">
                        <i class="bx bx-log-in mr-2"></i>
                        Join Room by ID
                    </button>
                </div>
            </div>

            <!-- Game Area -->
            <div id="game-area" class="hidden">
                <div class="text-center mb-6">
                    <button onclick="backToSelection()" class="px-4 py-2 bg-muted hover:bg-muted/80 text-white rounded-lg transition-colors">
                        <i class="bx bx-arrow-back mr-2"></i>Back to Games
                    </button>
                </div>
                <div id="game-content"></div>
            </div>
        </main>

        <!-- Join Room Modal -->
        <div id="join-room-modal" class="fixed inset-0 modal-backdrop flex items-center justify-center z-50 hidden">
            <div class="bg-surface border border-highlight-med rounded-xl p-6 max-w-md w-full mx-4">
                <h3 class="text-xl font-bold text-text mb-4">Join Game Room</h3>
                <input type="text" id="room-id-input" placeholder="Enter Room ID" 
                       class="w-full p-3 bg-overlay border border-highlight-med rounded-lg text-text mb-4 focus:outline-none focus:border-foam"
                       onkeypress="if(event.key==='Enter') joinRoomById()">
                <div class="flex gap-3">
                    <button onclick="joinRoomById()" class="flex-1 px-4 py-2 bg-foam hover:bg-foam/80 text-black rounded-lg transition-colors">
                        Join Room
                    </button>
                    <button onclick="hideJoinRoomModal()" class="flex-1 px-4 py-2 bg-muted hover:bg-muted/80 text-white rounded-lg transition-colors">
                        Cancel
                    </button>
                </div>
                <div class="text-xs text-muted mt-3 text-center">
                    Room IDs are case-sensitive and typically look like: -AbCdEfGhIjKlMnOp
                </div>
            </div>
        </div>
    </div>

    <script>
        /*
         * ============================================
         * CARBON MULTI - REAL-TIME MULTIPLAYER GAMES
         * ============================================
         * 
         * Enhanced with full Firebase integration matching index.html:
         * - Same Firebase configuration and collection names ('game-rooms')
         * - Google & Anonymous authentication
         * - Real-time game synchronization across all 4 games
         * - Optimized update frequencies for smooth gameplay:
         *   • Pong: 60 FPS physics, 83Hz paddle updates
         *   • Typing: 33Hz text synchronization  
         *   • Reaction: Instant response detection
         *   • Racing: 60 FPS movement, 30Hz position sync
         * - Enhanced error handling and notifications
         * - Automatic opponent matching and room management
         * - Winner screens with confetti animations
         * - Disconnection handling and cleanup
         * 
         * All games are fully playable in real-time with 2 players!
         */

        // Firebase Configuration (exactly matching index.html)
        const firebaseConfig = {
            apiKey: "AIzaSyC4ilHYP1T-kdXbWPoHJHhD2aj0pNWmMec",
            authDomain: "carbon-services.firebaseapp.com",
            databaseURL: "https://carbon-services-default-rtdb.firebaseio.com/",
            projectId: "carbon-services",
            storageBucket: "carbon-services.firebasestorage.app",
            messagingSenderId: "288385472070",
            appId: "1:288385472070:web:c4be3ff186e248fc645c47",
            measurementId: "G-Y2K1RQYE74"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore(); // Keep for other games
        const realtimeDb = firebase.database(); // Add Realtime Database for ping pong

        // Global variables
        let currentUser = null;
        let currentRoom = null;
        let gameListener = null;
        let currentGameData = null;
        let winnerScreenShown = false;

        // Game-specific intervals and timeouts
        let pongInterval = null;
        let racingUpdateInterval = null;
        let reactionTimeout = null;
        let racingKeys = { left: false, right: false, up: false, down: false };

        // Ping Pong Realtime Database variables
        let pongRoomRef = null;
        let pongPhysicsRef = null;
        let pongPlayersRef = null;
        let isHost = false;
        let lastPaddleUpdate = 0;
        let connectionRef = null;
        
        // Guest prediction variables
        let guestBallPrediction = null;
        let lastServerBallUpdate = 0;
        let guestPhysicsInterval = null;
        let currentServerBall = null;
        let currentServerGameState = null;

        // Auth state listener
        auth.onAuthStateChanged((user) => {
            currentUser = user;
            updateUI();
        });

        function updateUI() {
            const authScreen = document.getElementById('auth-screen');
            const mainContent = document.getElementById('main-content');
            const authSection = document.getElementById('auth-section');
            
            if (currentUser) {
                authScreen.classList.add('hidden');
                mainContent.classList.remove('hidden');
                
                authSection.innerHTML = `
                    <div class="flex items-center gap-3">
                        <img src="${currentUser.photoURL || 'https://via.placeholder.com/32'}" 
                             class="w-8 h-8 rounded-full border-2 border-foam">
                        <span class="text-text font-medium">${currentUser.displayName || currentUser.email || 'Player'}</span>
                        <button onclick="signOut()" class="px-3 py-1 bg-love hover:bg-love/80 text-white rounded text-sm transition-colors">
                            Sign Out
                        </button>
                    </div>
                `;
            } else {
                authScreen.classList.remove('hidden');
                mainContent.classList.add('hidden');
            }
        }

        // Enhanced notification system
        function showNotification(title, message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div class="flex items-start gap-3">
                    <i class="bx ${type === 'success' ? 'bx-check-circle' : 
                                    type === 'error' ? 'bx-x-circle' : 
                                    type === 'warning' ? 'bx-error' : 'bx-info-circle'} text-xl mt-0.5"></i>
                    <div class="flex-1">
                        <div class="font-semibold">${title}</div>
                        <div class="text-sm opacity-90">${message}</div>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="text-white/70 hover:text-white">
                        <i class="bx bx-x text-lg"></i>
                    </button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }

        // Authentication functions
        async function signInWithGoogle() {
            try {
                const provider = new firebase.auth.GoogleAuthProvider();
                await auth.signInWithPopup(provider);
                showNotification('Welcome!', 'Successfully signed in with Google', 'success');
            } catch (error) {
                console.error('Google sign-in error:', error);
                showNotification('Sign In Failed', error.message, 'error');
            }
        }

        async function signInAnonymously() {
            try {
                await auth.signInAnonymously();
                showNotification('Welcome!', 'Playing as guest', 'success');
            } catch (error) {
                console.error('Anonymous sign-in error:', error);
                showNotification('Sign In Failed', error.message, 'error');
            }
        }

        async function signOut() {
            try {
                // Clean up current game if any
                if (currentRoom && currentUser && realtimeDb) {
                    await leaveRoom();
                }
                
                // Clean up all resources before signing out
                cleanupAllGameResources();
                
                await auth.signOut();
                showNotification('Signed Out', 'You have been signed out', 'info');
            } catch (error) {
                console.error('Sign out error:', error);
                showNotification('Error', 'Failed to sign out', 'error');
            }
        }

        // Enhanced game selection and room management
        function selectGame(gameType) {
            showNotification('Creating Room...', 'Setting up your game', 'info');
            createGameRoom(gameType);
        }

        function findRandomGame() {
            const games = ['pong', 'typing', 'reaction', 'racing'];
            const randomGame = games[Math.floor(Math.random() * games.length)];
            showNotification('Finding Game...', `Looking for ${getGameDisplayName(randomGame)} opponents`, 'info');
            findRandomOpponent(randomGame);
        }

        function showJoinRoomModal() {
            document.getElementById('join-room-modal').classList.remove('hidden');
            // Focus the input after a small delay to ensure the modal is visible
            setTimeout(() => {
                const input = document.getElementById('room-id-input');
                if (input) {
                    input.focus();
                    input.select(); // Select any existing text
                }
            }, 100);
        }

        function hideJoinRoomModal() {
            document.getElementById('join-room-modal').classList.add('hidden');
            document.getElementById('room-id-input').value = '';
        }

        async function joinRoomById() {
            const roomId = document.getElementById('room-id-input').value.trim();
            if (!roomId) {
                showNotification('Invalid Input', 'Please enter a room ID', 'warning');
                return;
            }

            // Check if user is authenticated and database is available
            if (!currentUser) {
                showNotification('Authentication Required', 'Please sign in to join a room', 'error');
                return;
            }
            
            if (!realtimeDb) {
                showNotification('Database Error', 'Database not available', 'error');
                return;
            }
            
            try {
                showNotification('Joining Room...', 'Connecting to game', 'info');
                hideJoinRoomModal();
                
                // Try ping pong room first
                const pongSnapshot = await realtimeDb.ref(`pong-rooms/${roomId}`).once('value');
                if (pongSnapshot && pongSnapshot.exists()) {
                    await joinPongRoom(roomId);
                    return;
                }
                
                // Try regular game room in realtime database
                const roomSnapshot = await realtimeDb.ref(`game-rooms/${roomId}`).once('value');
                if (!roomSnapshot || !roomSnapshot.exists()) {
                    showNotification('Room Not Found', 'Game room does not exist!', 'error');
                    return;
                }

                const roomData = roomSnapshot.val();
                if (roomData.status !== 'waiting') {
                    showNotification('Game In Progress', 'This game has already started!', 'warning');
                    return;
                }

                if (roomData.hostId === currentUser.uid) {
                    showNotification('Invalid', 'You cannot join your own game!', 'warning');
                    return;
                }

                if (roomData.guestId) {
                    showNotification('Room Full', 'This game room is already full!', 'warning');
                    return;
                }

                await joinRealtimeRoom(roomId);
            } catch (error) {
                console.error('Error joining room by ID:', error);
                showNotification('Error', 'Failed to join room!', 'error');
            }
        }

        async function createGameRoom(gameType) {
            if (!currentUser) {
                showNotification('Authentication Required', 'Please sign in to play', 'error');
                return;
            }

            try {
                winnerScreenShown = false;
                
                // Handle ping pong with its dedicated system
                if (gameType === 'pong') {
                    await createPongRoom();
                    return;
                }
                
                // Other games use unified Realtime Database system
                await createRealtimeRoom(gameType);
                
            } catch (error) {
                console.error('Error creating room:', error);
                showNotification('Error', 'Failed to create game room!', 'error');
            }
        }

        async function createRealtimeRoom(gameType) {
            // Check if user is authenticated and database is available
            if (!currentUser) {
                throw new Error('User not authenticated');
            }
            
            if (!realtimeDb) {
                throw new Error('Realtime database not initialized');
            }
            
            try {
                // Try to find an existing waiting room first (use same logic as findValidRegularRoom)
                const foundRoom = await findValidRegularRoom(gameType);
                if (foundRoom) {
                    console.log('🎯 Found existing room in createRealtimeRoom, joining:', foundRoom.roomId);
                    await joinRealtimeRoom(foundRoom.roomId);
                    return;
                }

                // Create new room if no valid rooms found
                // Generate a unique room ID without pushing to parent path
                const roomId = realtimeDb.ref().push().key;
                const roomData = {
                    gameType: gameType,
                    hostId: currentUser.uid,
                    hostName: currentUser.displayName || currentUser.email || 'Player',
                    hostPhoto: currentUser.photoURL || '',
                    guestId: null,
                    guestName: null,
                    guestPhoto: null,
                    status: 'waiting',
                    gameState: getInitialGameState(gameType),
                    winner: null,
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                };

                await realtimeDb.ref(`game-rooms/${roomId}`).set(roomData);
                currentRoom = roomId;
                isHost = true;
                
                showGameLobby(roomData, roomId, true);
                await setupRealtimeRoom(roomId, gameType);
                
                showNotification(`${getGameDisplayName(gameType)} Room Created!`, 'Share the room ID with a friend to play', 'success');
            } catch (error) {
                console.error('Error creating realtime room:', error);
                showNotification('Error', 'Failed to create game room!', 'error');
            }
        }

        // Ping Pong Realtime Database Functions
        async function createPongRoom() {
            try {
                const roomId = realtimeDb.ref().push().key;
                const roomData = {
                    gameType: 'pong',
                    hostId: currentUser.uid,
                    hostName: currentUser.displayName || currentUser.email || 'Player',
                    hostPhoto: currentUser.photoURL || '',
                    guestId: null,
                    guestName: null,
                    guestPhoto: null,
                    status: 'waiting',
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                };

                await realtimeDb.ref(`pong-rooms/${roomId}`).set(roomData);
                currentRoom = roomId;
                isHost = true;
                
                showGameLobby(roomData, roomId, true);
                await setupPongRoom(roomId);
                
                showNotification('Ping Pong Room Created!', 'Share the room ID with a friend to play', 'success');
            } catch (error) {
                console.error('Error creating pong room:', error);
                showNotification('Error', 'Failed to create ping pong room!', 'error');
            }
        }

        async function joinPongRoom(roomId) {
            // Check if user is authenticated and database is available
            if (!currentUser) {
                showNotification('Authentication Required', 'Please sign in to join a room', 'error');
                return;
            }
            
            if (!realtimeDb) {
                showNotification('Database Error', 'Database not available', 'error');
                return;
            }
            
            try {
                const roomSnapshot = await realtimeDb.ref(`pong-rooms/${roomId}`).once('value');
                if (!roomSnapshot || !roomSnapshot.exists()) {
                    showNotification('Room Not Found', 'Ping pong room does not exist!', 'error');
                    return;
                }

                const roomData = roomSnapshot.val();
                if (roomData.status !== 'waiting') {
                    showNotification('Game In Progress', 'This ping pong game has already started!', 'warning');
                    return;
                }

                if (roomData.guestId) {
                    showNotification('Room Full', 'This ping pong room is already full!', 'warning');
                    return;
                }

                if (roomData.hostId === currentUser.uid) {
                    showNotification('Invalid', 'You cannot join your own game!', 'warning');
                    return;
                }

                // Enhanced guest name resolution with better fallback
                const guestName = currentUser.displayName || currentUser.email || currentUser.uid || 'Player';
                console.log('🎯 Setting guest name for pong room:', {
                    displayName: currentUser.displayName,
                    email: currentUser.email,
                    uid: currentUser.uid,
                    resolvedName: guestName
                });

                await realtimeDb.ref(`pong-rooms/${roomId}`).update({
                    guestId: currentUser.uid,
                    guestName: guestName,
                    guestPhoto: currentUser.photoURL || '',
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                    // Note: Keep status as 'waiting' so host can see guest join
                });

                currentRoom = roomId;
                isHost = false;
                
                const updatedData = { ...roomData, guestId: currentUser.uid, guestName: currentUser.displayName || 'Player' };
                showGameLobby(updatedData, roomId, false);
                await setupPongRoom(roomId);
                
                showNotification('Joined Ping Pong!', 'Game will start shortly', 'success');
            } catch (error) {
                console.error('Error joining pong room:', error);
                showNotification('Error', 'Failed to join ping pong room!', 'error');
            }
        }

        async function setupPongRoom(roomId) {
            // Clean up existing listeners first
            if (pongRoomRef) {
                pongRoomRef.off();
                pongRoomRef = null;
            }
            if (pongPhysicsRef) {
                pongPhysicsRef.off();
                pongPhysicsRef = null;
            }
            if (pongPlayersRef) {
                pongPlayersRef.off();
                pongPlayersRef = null;
            }
            if (connectionRef) {
                connectionRef.off();
                connectionRef = null;
            }

            // Clean up previous disconnect handlers
            await cleanupDisconnectHandlers();

            // Setup room references
            pongRoomRef = realtimeDb.ref(`pong-rooms/${roomId}`);
            pongPhysicsRef = realtimeDb.ref(`pong-physics/${roomId}`);
            pongPlayersRef = realtimeDb.ref(`pong-players/${roomId}`);

            // Enhanced disconnect handling with conflict prevention
            const playerRef = realtimeDb.ref(`pong-rooms/${roomId}/players/${currentUser.uid}`);
            const pongPlayersUserRef = realtimeDb.ref(`pong-players/${roomId}/${currentUser.uid}`);
            
            // Set up disconnect handlers
            playerRef.onDisconnect().remove();
            pongPlayersUserRef.onDisconnect().remove();
            pongRoomRef.onDisconnect().update({
                disconnectedPlayer: currentUser.uid,
                disconnectedAt: firebase.database.ServerValue.TIMESTAMP,
                status: 'completed'
            });
            
            // Track disconnect handlers
            activeDisconnectHandlers.add({ ref: playerRef, roomId, type: 'pong-player' });
            activeDisconnectHandlers.add({ ref: pongPlayersUserRef, roomId, type: 'pong-players' });
            activeDisconnectHandlers.add({ ref: pongRoomRef, roomId, type: 'pong-room' });

            // Listen for room changes with error handling
            pongRoomRef.on('value', (snapshot) => {
                if (!snapshot.exists()) {
                    showNotification('Game Ended', 'The ping pong room was closed', 'info');
                    cleanupPongRoom();
                    cleanupAndBackToSelection();
                    return;
                }

                const roomData = snapshot.val();
                handlePongRoomUpdate(roomData, roomId);
            }, (error) => {
                console.error('Error listening to pong room:', error);
                showNotification('Connection Error', 'Lost connection to ping pong game', 'error');
                cleanupPongRoom();
                cleanupAndBackToSelection();
            });

            // Setup connection monitoring with enhanced handling
            connectionRef = realtimeDb.ref('.info/connected');
            connectionRef.on('value', (snapshot) => {
                if (snapshot.val() === false) {
                    showNotification('Connection Lost', 'Reconnecting to game...', 'warning');
                } else if (currentRoom) {
                    // Update last activity when reconnected
                    realtimeDb.ref(`pong-rooms/${currentRoom}/lastActivity`).set(firebase.database.ServerValue.TIMESTAMP).catch(console.error);
                }
            }, (error) => {
                console.error('Connection monitoring error:', error);
            });
            
            // Mark player as online with error handling
            try {
                await realtimeDb.ref(`pong-rooms/${roomId}/players/${currentUser.uid}`).set({
                    name: currentUser.displayName || currentUser.email || 'Player',
                    photo: currentUser.photoURL || '',
                    online: true,
                    lastSeen: firebase.database.ServerValue.TIMESTAMP
                });
                
                console.log('✅ Player marked as online in pong room');
            } catch (error) {
                console.error('Error marking player as online:', error);
                throw error; // Re-throw to trigger error handling in caller
            }
        }

        async function joinGameRoom(roomId, roomData) {
            try {
                await db.collection('game-rooms').doc(roomId).update({
                    guestId: currentUser.uid,
                    guestName: currentUser.displayName || currentUser.email || 'Player',
                    guestPhoto: currentUser.photoURL || '',
                    lastActivity: firebase.firestore.FieldValue.serverTimestamp()
                });

                currentRoom = roomId;
                showGameLobby({ ...roomData, guestId: currentUser.uid, guestName: currentUser.displayName || 'Player' }, roomId, false);
                listenToRoom(roomId);
                
                showNotification('Joined Game!', 'Game will start shortly', 'success');
            } catch (error) {
                console.error('Error joining room:', error);
                showNotification('Error', 'Failed to join game room!', 'error');
            }
        }

        function getInitialGameState(gameType) {
            switch (gameType) {
                case 'pong':
                    return {
                        ball: { x: 400, y: 200, dx: 3, dy: 2 },
                        player1: { y: 175, score: 0 },
                        player2: { y: 175, score: 0 },
                        gameStarted: false
                    };
                case 'typing':
                    return {
                        sentence: generateRandomSentence(),
                        player1Progress: 0,
                        player2Progress: 0,
                        player1Text: '',
                        player2Text: '',
                        winner: null
                    };
                case 'reaction':
                    // Enhanced reaction game state with proper initialization
                    return {
                        round: 1,
                        maxRounds: 5,
                        player1Score: 0,
                        player2Score: 0,
                        currentState: 'waiting',
                        changeTime: null,
                        player1Time: null,
                        player2Time: null,
                        gameStarted: false,
                        hostReady: false,
                        guestReady: false,
                        lastRoundTime: null,
                        roundStartedAt: null
                    };
                case 'racing':
                    return {
                        player1: { x: 50, y: 200, laps: 0, obstacles: [] },
                        player2: { x: 50, y: 250, laps: 0, obstacles: [] },
                        maxLaps: 3,
                        obstacles: generateObstacles()
                    };
                default:
                    return {};
            }
        }

        function generateRandomSentence() {
            const sentences = [
                "The quick brown fox jumps over the lazy dog",
                "Pack my box with five dozen liquor jugs",
                "How razorback jumping frogs can level six piqued gymnasts",
                "The five boxing wizards jump quickly",
                "Sphinx of black quartz judge my vow",
                "Waltz bad nymph for quick jigs vex",
                "Glib jocks quiz nymph to vex dwarf",
                "Bright vixens jump dozy fowl quack"
            ];
            return sentences[Math.floor(Math.random() * sentences.length)];
        }

        function generateObstacles() {
            const obstacles = [];
            for (let i = 0; i < 10; i++) {
                obstacles.push({
                    x: Math.random() * 700 + 100,
                    y: Math.random() * 300 + 150,
                    width: 20,
                    height: 20
                });
            }
            return obstacles;
        }

        function showGameLobby(roomData, roomId, isHost) {
            document.getElementById('game-selection').classList.add('hidden');
            document.getElementById('game-area').classList.remove('hidden');
            
            const gameContent = document.getElementById('game-content');
            gameContent.innerHTML = `
                <div class="bg-surface border border-highlight-med rounded-xl shadow-2xl max-w-4xl w-[95vw] h-[90vh] flex flex-col">
                    <!-- Header -->
                    <div class="flex items-center justify-between p-6 border-b border-highlight-med">
                        <div class="flex items-center gap-3">
                            <i class="bx ${getGameIcon(roomData.gameType)} text-3xl text-foam"></i>
                            <div>
                                <h2 class="text-2xl font-bold text-text">${getGameDisplayName(roomData.gameType)}</h2>
                                <p class="text-muted">Room ID: ${roomId}</p>
                            </div>
                        </div>
                        <button onclick="leaveRoom()" class="text-muted hover:text-love transition-colors">
                            <i class="bx bx-x text-2xl"></i>
                        </button>
                    </div>
                    
                    <!-- Game Content -->
                    <div class="flex-1 flex">
                        <!-- Game Area -->
                        <div class="flex-1 p-6 flex flex-col items-center justify-center">
                            <div id="lobby-content">
                                ${roomData.status === 'waiting' ? `
                                    <div class="text-center">
                                        <div class="w-32 h-32 mx-auto mb-6 bg-highlight-med rounded-full flex items-center justify-center">
                                            <div class="spinner"></div>
                                        </div>
                                        <h3 class="text-xl font-bold text-text mb-2">Waiting for Player...</h3>
                                        <p class="text-muted mb-4">Share the room ID with a friend to start playing!</p>
                                        <div class="flex gap-2 justify-center">
                                            <input type="text" value="${roomId}" readonly class="px-3 py-2 bg-overlay border border-highlight-med rounded-lg text-text text-sm font-mono">
                                            <button onclick="copyRoomId('${roomId}')" class="px-4 py-2 bg-foam hover:bg-foam/80 text-base rounded-lg transition-colors">
                                                <i class="bx bx-copy"></i>
                                            </button>
                                        </div>
                                    </div>
                                ` : '<!-- Game will be rendered here -->'}
                            </div>
                        </div>
                        
                        <!-- Players Panel -->
                        <div class="w-80 bg-highlight-med/50 p-6 border-l border-highlight-med">
                            <h3 class="text-lg font-bold text-text mb-4">Players</h3>
                            
                            <!-- Host Player -->
                            <div class="bg-surface rounded-lg p-4 mb-3">
                                <div class="flex items-center gap-3">
                                    ${roomData.hostPhoto ? 
                                        `<img src="${roomData.hostPhoto}" class="w-10 h-10 rounded-full border-2 border-foam">` :
                                        `<div class="w-10 h-10 rounded-full border-2 border-foam bg-foam/20 flex items-center justify-center">
                                            <i class="bx bx-user text-foam"></i>
                                        </div>`
                                    }
                                    <div class="flex-1">
                                        <div class="font-semibold text-text">${roomData.hostName}</div>
                                        <div class="text-xs text-foam">Host (Player 1)</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Guest Player -->
                            <div id="guest-slot" class="bg-surface rounded-lg p-4 mb-6">
                                ${roomData.guestId ? `
                                    <div class="flex items-center gap-3">
                                        ${roomData.guestPhoto ? 
                                            `<img src="${roomData.guestPhoto}" class="w-10 h-10 rounded-full border-2 border-iris">` :
                                            `<div class="w-10 h-10 rounded-full border-2 border-iris bg-iris/20 flex items-center justify-center">
                                                <i class="bx bx-user text-iris"></i>
                                            </div>`
                                        }
                                        <div class="flex-1">
                                            <div class="font-semibold text-text">${roomData.guestName}</div>
                                            <div class="text-xs text-iris">Guest (Player 2)</div>
                                        </div>
                                    </div>
                                ` : `
                                    <div class="flex items-center gap-3">
                                        <div class="w-10 h-10 rounded-full border-2 border-dashed border-muted flex items-center justify-center">
                                            <i class="bx bx-user text-muted"></i>
                                        </div>
                                        <div class="flex-1">
                                            <div class="font-semibold text-muted">Waiting...</div>
                                            <div class="text-xs text-muted">Guest (Player 2)</div>
                                        </div>
                                    </div>
                                `}
                            </div>
                            
                            <!-- Game Status -->
                            <div class="bg-surface rounded-lg p-4 mb-6">
                                <h4 class="font-semibold text-text mb-2">Game Status</h4>
                                <div id="game-status" class="text-sm">
                                    ${roomData.status === 'waiting' ? 
                                        (roomData.guestId ? 
                                            '<span class="text-foam">Both players ready! Starting...</span>' :
                                            '<span class="text-gold">Waiting for player...</span>') : 
                                        roomData.status === 'playing' ? 
                                        '<span class="text-foam">Game in progress</span>' : 
                                        '<span class="text-love">Game completed</span>'}
                                </div>
                            </div>
                            
                            <!-- Quick Actions -->
                            <div class="space-y-2">
                                ${roomData.status === 'waiting' && !roomData.guestId ? `
                                    <button onclick="findRandomOpponent('${roomData.gameType}')" 
                                            class="w-full px-4 py-2 bg-iris hover:bg-iris/80 text-white rounded-lg transition-colors text-sm">
                                        <i class="bx bx-shuffle mr-2"></i>Find Random Player
                                    </button>
                                ` : ''}
                                <button onclick="leaveRoom()" 
                                        class="w-full px-4 py-2 bg-love hover:bg-love/80 text-white rounded-lg transition-colors text-sm">
                                    <i class="bx bx-exit mr-2"></i>Leave Game
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function getGameIcon(gameType) {
            const icons = {
                'pong': 'bx-tennis-ball',
                'typing': 'bx-keyboard',
                'reaction': 'bx-stopwatch',
                'racing': 'bx-car'
            };
            return icons[gameType] || 'bx-game';
        }

        function getGameDisplayName(gameType) {
            const names = {
                'pong': 'Ping Pong',
                'typing': 'Typing Duel',
                'reaction': 'Reaction Test',
                'racing': 'Mini Racing'
            };
            return names[gameType] || gameType;
        }

        async function joinRealtimeRoom(roomId) {
            try {
                const roomRef = realtimeDb.ref(`game-rooms/${roomId}`);
                const roomSnapshot = await roomRef.once('value');
                
                if (!roomSnapshot.exists()) {
                    showNotification('Error', 'Room not found!', 'error');
                    return;
                }
                
                const roomData = roomSnapshot.val();
                
                if (roomData.status !== 'waiting' || roomData.guestId) {
                    showNotification('Error', 'Room is not available!', 'error');
                    return;
                }
                
                // Join the room but keep status as 'waiting' - let host transition to 'playing'
                await roomRef.update({
                    guestId: currentUser.uid,
                    guestName: currentUser.displayName || currentUser.email || 'Player',
                    guestPhoto: currentUser.photoURL || '',
                    status: 'waiting', // Keep as 'waiting' so both players can see each other first
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                });
                
                currentRoom = roomId;
                isHost = false;
                
                showGameLobby(roomData, roomId, false);
                await setupRealtimeRoom(roomId, roomData.gameType);
                
                showNotification(`Joined ${getGameDisplayName(roomData.gameType)} Room!`, 'Waiting for host to start...', 'success');
            } catch (error) {
                console.error('Error joining room:', error);
                showNotification('Error', 'Failed to join room!', 'error');
            }
        }

        // Track active disconnect handlers to prevent conflicts
        let activeDisconnectHandlers = new Set();
        
        async function setupRealtimeRoom(roomId, gameType) {
            // Clean up any existing disconnect handlers first
            await cleanupDisconnectHandlers();
            
            // Set up disconnect cleanup with conflict prevention
            const userRef = realtimeDb.ref(`game-rooms/${roomId}`);
            const disconnectRef = userRef.child('disconnectHandler').child(currentUser.uid);
            
            // Create unique disconnect handler
            const disconnectData = {
                status: 'completed',
                disconnectedPlayer: currentUser.uid,
                disconnectedPlayerName: currentUser.displayName || currentUser.email || 'Player',
                disconnectedAt: firebase.database.ServerValue.TIMESTAMP,
                lastActivity: firebase.database.ServerValue.TIMESTAMP
            };
            
            // Set up disconnect handler with proper cleanup
            userRef.onDisconnect().update(disconnectData);
            activeDisconnectHandlers.add({ ref: userRef, roomId, type: 'regular' });
            
            // Clean up any existing room listeners to prevent memory leaks
            if (gameListener && typeof gameListener === 'function') {
                gameListener();
                gameListener = null;
            }
            
            // Listen to room changes with enhanced error handling
            gameListener = userRef.on('value', (snapshot) => {
                if (snapshot && snapshot.exists()) {
                    const roomData = snapshot.val();
                    handleRoomUpdate(roomData, roomId);
                } else {
                    console.log('❌ Room no longer exists or snapshot is null');
                    showNotification('Game Ended', 'The game room was closed', 'info');
                    cleanupAndBackToSelection();
                }
            }, (error) => {
                console.error('❌ Error listening to room:', error);
                showNotification('Connection Error', 'Lost connection to game room', 'error');
                cleanupAndBackToSelection();
            });
            
            // Set up game-specific listeners
            await setupGameSpecificListeners(roomId, gameType);
        }

        async function cleanupDisconnectHandlers() {
            // Cancel all active disconnect handlers
            for (const handler of activeDisconnectHandlers) {
                try {
                    handler.ref.onDisconnect().cancel();
                    console.log('🧹 Cancelled disconnect handler for room:', handler.roomId);
                } catch (error) {
                    console.warn('Error cancelling disconnect handler:', error);
                }
            }
            activeDisconnectHandlers.clear();
        }

        function cleanupAndBackToSelection() {
            // Enhanced cleanup to prevent race conditions
            cleanupDisconnectHandlers();
            
            // Clean up game listeners
            if (gameListener && typeof gameListener === 'function') {
                gameListener();
                gameListener = null;
            }
            
            // Reset state and go back
            setTimeout(() => {
                backToSelection();
            }, 100);
        }

        async function setupGameSpecificListeners(roomId, gameType) {
            switch (gameType) {
                case 'pong':
                    // Ping pong uses separate system - no additional listeners needed
                    // The pong system handles its own listeners in setupPongRoom
                    break;
                case 'typing':
                    await setupTypingListeners(roomId);
                    break;
                case 'reaction':
                    await setupReactionListeners(roomId);
                    break;
                case 'racing':
                    await setupRacingListeners(roomId);
                    break;
            }
        }

        function handleRoomUpdate(roomData, roomId) {
            const previousStatus = currentGameData ? currentGameData.status : null;
            const previousGuestId = currentGameData ? currentGameData.guestId : null;
            
            currentGameData = roomData;
            
            // Update lobby UI if in lobby
            if (document.getElementById('lobby-content')) {
                updateLobbyStatus(roomData);
            }
            
            // Handle when second player joins while first is in lobby (for regular games)
            if (roomData.status === 'waiting' && roomData.guestId && !previousGuestId) {
                console.log('👥 Second player joined regular game:', roomData.guestName);
                updateLobbyWithGuest(roomData);
            }
            
            // Start game if status changed to playing
            if (roomData.status === 'playing' && !document.getElementById('game-container')) {
                initializeGameInLobby(roomData, roomId);
            }
            
            // Handle disconnections
            if (roomData.status === 'disconnected' || (roomData.status === 'completed' && roomData.disconnectedPlayer)) {
                const disconnectedPlayerName = roomData.disconnectedPlayerName || 
                    (roomData.disconnectedPlayer === roomData.hostId ? 
                        (roomData.hostName || 'Host') : 
                        (roomData.guestName || 'Guest'));
                
                const remainingPlayerName = roomData.winnerName || 
                    (roomData.winner === 'player1' ? roomData.hostName : roomData.guestName);
                
                if (roomData.disconnectedPlayer !== currentUser.uid) {
                    showNotification('Player Left', `${disconnectedPlayerName} left the game. ${remainingPlayerName} wins!`, 'info');
                    
                    // Show winner screen for remaining player if game was in progress
                    if (roomData.status === 'completed' && roomData.winner && !winnerScreenShown) {
                        setTimeout(() => showWinnerScreen(roomData), 1500);
                    }
                } else {
                    showNotification('Left Game', 'You have left the game', 'info');
                }
                
                setTimeout(() => backToSelection(), 3000);
            }
        }

        function updateLobbyStatus(roomData) {
            const gameStatus = document.getElementById('game-status');
            const guestSlot = document.getElementById('guest-slot');
            
            if (gameStatus) {
                let statusText = '';
                if (roomData.status === 'waiting') {
                    statusText = roomData.guestId ? 
                        '<span class="text-foam">Both players ready! Starting...</span>' :
                        '<span class="text-gold">Waiting for player...</span>';
                } else if (roomData.status === 'playing') {
                    statusText = '<span class="text-foam">Game in progress</span>';
                } else if (roomData.status === 'completed') {
                    statusText = '<span class="text-love">Game completed</span>';
                }
                gameStatus.innerHTML = statusText;
            }
            
            if (guestSlot && roomData.guestId) {
                guestSlot.innerHTML = `
                    <div class="flex items-center gap-3">
                        ${roomData.guestPhoto ? 
                            `<img src="${roomData.guestPhoto}" class="w-10 h-10 rounded-full border-2 border-iris">` :
                            `<div class="w-10 h-10 rounded-full border-2 border-iris bg-iris/20 flex items-center justify-center">
                                <i class="bx bx-user text-iris"></i>
                            </div>`
                        }
                        <div class="flex-1">
                            <div class="font-semibold text-text">${roomData.guestName}</div>
                            <div class="text-xs text-iris">Guest (Player 2)</div>
                        </div>
                    </div>
                `;
            }
        }

        // Global window functions for HTML onclick handlers
        window.copyRoomId = function(roomId) {
            navigator.clipboard.writeText(roomId).then(() => {
                showNotification('Copied!', 'Room ID copied to clipboard', 'success');
            }).catch(() => {
                showNotification('Error', 'Failed to copy room ID', 'error');
            });
        };

        // Debouncing for find random opponent to prevent rapid clicking
        let findRandomInProgress = false;
        let lastFindRandomAttempt = 0;
        
        window.findRandomOpponent = async function(gameType) {
            // Prevent rapid clicking and multiple simultaneous searches
            const now = Date.now();
            if (findRandomInProgress) {
                console.log('Find random already in progress, ignoring request');
                return;
            }
            
            if (now - lastFindRandomAttempt < 2000) {
                showNotification('Please Wait', 'Please wait before searching again', 'warning');
                return;
            }
            
            findRandomInProgress = true;
            lastFindRandomAttempt = now;
            
            try {
                showNotification('Searching...', 'Looking for available players', 'info');
                
                // Clean up any existing room connections first
                if (currentRoom) {
                    console.log('🧹 Cleaning up existing room before finding new opponent');
                    await leaveRoom();
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait for cleanup
                }
                
                // Search for pong rooms first if pong game type
                if (gameType === 'pong') {
                    const foundRoom = await findValidPongRoom();
                    if (foundRoom) {
                        await joinPongRoom(foundRoom.roomId);
                        return;
                    }
                } else {
                    // Search for regular game rooms with enhanced validation
                    console.log('🔍 Finding random opponent for regular game:', gameType);
                    const foundRoom = await findValidRegularRoom(gameType);
                    if (foundRoom) {
                        console.log('✅ Found room, joining:', foundRoom.roomId);
                        showNotification('Found Player!', `Joining ${foundRoom.roomData.hostName}'s game`, 'success');
                        await joinRealtimeRoom(foundRoom.roomId);
                        return;
                    } else {
                        console.log('❌ No valid rooms found for game type:', gameType);
                    }
                }
                
                // If no rooms found, create a new one
                console.log('📝 Creating new room for game type:', gameType);
                showNotification('No Players Found', 'Creating a new room for other players to join!', 'info');
                selectGame(gameType);
                
            } catch (error) {
                console.error('Error finding opponent:', error);
                showNotification('Error', 'Failed to find opponent. Please try again.', 'error');
                
                // Reset state on error
                if (currentRoom) {
                    backToSelection();
                }
            } finally {
                // Always reset the flag
                setTimeout(() => {
                    findRandomInProgress = false;
                }, 1000);
            }
        };

        // Enhanced room finding with staleness detection
        async function findValidPongRoom() {
            // Check if user is authenticated and database is available
            if (!currentUser || !realtimeDb) {
                console.error('User not authenticated or database not available');
                return null;
            }
            
            try {
                const pongRoomsSnapshot = await realtimeDb.ref(`pong-rooms`)
                    .orderByChild('status')
                    .equalTo('waiting')
                    .limitToFirst(10) // Limit search to prevent excessive queries
                    .once('value');
                
                if (!pongRoomsSnapshot || !pongRoomsSnapshot.exists()) {
                    return null;
                }
                
                const rooms = pongRoomsSnapshot.val();
                const now = Date.now();
                const fiveMinutesAgo = now - (5 * 60 * 1000);
                
                for (const [roomId, roomData] of Object.entries(rooms)) {
                    // Enhanced validation
                    if (roomData.status === 'waiting' && 
                        !roomData.guestId && 
                        roomData.hostId !== currentUser.uid &&
                        roomData.lastActivity && roomData.lastActivity > fiveMinutesAgo) {
                        
                        // Double-check room is still valid by reading it again
                        const verifySnapshot = await realtimeDb.ref(`pong-rooms/${roomId}`).once('value');
                        if (verifySnapshot && verifySnapshot.exists()) {
                            const currentRoomData = verifySnapshot.val();
                            if (currentRoomData.status === 'waiting' && !currentRoomData.guestId) {
                                console.log('✅ Found valid pong room:', roomId);
                                return { roomId, roomData: currentRoomData };
                            }
                        }
                    }
                }
                
                return null;
            } catch (error) {
                console.error('Error finding valid pong room:', error);
                return null;
            }
        }

        async function findValidRegularRoom(gameType) {
            // Check if user is authenticated and database is available
            if (!currentUser || !realtimeDb) {
                console.error('User not authenticated or database not available');
                return null;
            }
            
            try {
                console.log('🔍 Searching for waiting rooms of type:', gameType);
                
                const waitingRoomsSnapshot = await realtimeDb.ref(`game-rooms`)
                    .orderByChild('status')
                    .equalTo('waiting')
                    .limitToFirst(20) // Increased limit to find more rooms
                    .once('value');
                
                if (!waitingRoomsSnapshot || !waitingRoomsSnapshot.exists()) {
                    console.log('❌ No waiting rooms found in database');
                    return null;
                }
                
                const rooms = waitingRoomsSnapshot.val();
                console.log('📋 Found waiting rooms:', Object.keys(rooms).length);
                
                // Simplified validation - focus on core requirements
                for (const [roomId, roomData] of Object.entries(rooms)) {
                    console.log(`🔍 Checking room ${roomId}:`, {
                        gameType: roomData.gameType,
                        status: roomData.status,
                        hasGuest: !!roomData.guestId,
                        hostId: roomData.hostId,
                        isOwnRoom: roomData.hostId === currentUser.uid
                    });
                    
                    // Core validation - must match game type, be waiting, no guest, not own room
                    if (roomData.status === 'waiting' && 
                        !roomData.guestId && 
                        roomData.hostId !== currentUser.uid &&
                        roomData.gameType === gameType) {
                        
                        // Double-check room is still valid with fresh data
                        const verifySnapshot = await realtimeDb.ref(`game-rooms/${roomId}`).once('value');
                        if (verifySnapshot && verifySnapshot.exists()) {
                            const currentRoomData = verifySnapshot.val();
                            if (currentRoomData.status === 'waiting' && !currentRoomData.guestId) {
                                console.log('✅ Found valid regular room:', roomId, 'Host:', currentRoomData.hostName);
                                return { roomId, roomData: currentRoomData };
                            } else {
                                console.log('❌ Room validation failed on double-check:', {
                                    status: currentRoomData.status,
                                    hasGuest: !!currentRoomData.guestId
                                });
                            }
                        } else {
                            console.log('❌ Room no longer exists on verification');
                        }
                    }
                }
                
                console.log('❌ No valid rooms found matching criteria');
                return null;
            } catch (error) {
                console.error('Error finding valid regular room:', error);
                return null;
            }
        }

        async function listenToRoom(roomId) {
            if (!db) return;
            
            if (gameListener) {
                gameListener();
            }
            
            console.log('🎧 Starting to listen to room:', roomId);
            
            gameListener = db.collection('game-rooms').doc(roomId).onSnapshot(doc => {
                if (!doc.exists) {
                    console.log('❌ Room no longer exists');
                    showNotification('Game Ended', 'The game room was closed', 'info');
                    backToSelection();
                    return;
                }
                
                const roomData = doc.data();
                console.log('📡 Room update received:', {
                    status: roomData.status,
                    host: roomData.hostName,
                    guest: roomData.guestName,
                    hasGameState: !!roomData.gameState
                });
                
                updateGameUI(roomData, roomId);
            }, error => {
                console.error('❌ Error listening to room:', error);
                showNotification('Connection Error', 'Lost connection to game room', 'error');
            });
        }

        function updateGameUI(roomData, roomId) {
            // Handle disconnections - ensure correct winner is shown
            if (roomData.status === 'completed' && roomData.disconnectedPlayer) {
                const disconnectedPlayerName = roomData.disconnectedPlayerName || 
                    (roomData.disconnectedPlayer === roomData.hostId ? 
                        (roomData.hostName || 'Host') : 
                        (roomData.guestName || 'Guest'));
                
                const remainingPlayerName = roomData.winnerName || 
                    (roomData.winner === 'player1' ? roomData.hostName : roomData.guestName);
                
                if (roomData.disconnectedPlayer !== currentUser.uid) {
                    showNotification('Player Left', `${disconnectedPlayerName} left the game. ${remainingPlayerName} wins!`, 'info');
                    
                    // Show winner screen for the remaining player
                    if (!winnerScreenShown) {
                        setTimeout(() => {
                            // Create a modified room data for winner screen
                            const winnerRoomData = { ...roomData };
                            // Ensure the winner is correctly set to the remaining player
                            if (roomData.winner === 'player1' || roomData.winner === 'player2') {
                                winnerRoomData.winner = roomData.winner;
                            }
                            showWinnerScreen(winnerRoomData);
                        }, 1500);
                    }
                    
                    setTimeout(() => {
                        backToSelection();
                    }, 4000);
                    return;
                } else {
                    // Current user is the one who left - just go back
                    showNotification('Left Game', 'You have left the game', 'info');
                    setTimeout(() => {
                        backToSelection();
                    }, 1000);
                    return;
                }
            }
            
            // Update current game data for real-time sync
            if (currentGameData) {
                const previousStatus = currentGameData.status;
                const previousGuestId = currentGameData.guestId;
                currentGameData = roomData;
                
                // Handle transition from waiting to playing - BOTH players need to see this
                if (roomData.status === 'playing' && previousStatus === 'waiting') {
                    console.log('🚀 Game starting transition for:', currentUser.uid === roomData.hostId ? 'Host' : 'Guest');
                    initializeGameInLobby(roomData, roomId);
                }
                
                // Handle when second player joins while first is in lobby  
                if (roomData.status === 'waiting' && roomData.guestId && !previousGuestId) {
                    console.log('👥 Second player joined:', roomData.guestName);
                    updateLobbyWithGuest(roomData);
                }
                
                // Sync guest prediction with server data every few updates
                if (roomData.gameType === 'pong' && roomData.hostId !== currentUser.uid) {
                    if (roomData.gameState && roomData.gameState.ball) {
                        const serverBall = roomData.gameState.ball;
                        
                        // Initialize guest prediction if it doesn't exist
                        if (!guestPredictedBall) {
                            console.log('🎯 Late initialization of guest prediction from server sync');
                            guestPredictedBall = { ...serverBall };
                            lastServerSync = Date.now();
                        } else {
                            // Check if prediction drifted too far from server
                            const distance = Math.sqrt(
                                Math.pow(guestPredictedBall.x - serverBall.x, 2) + 
                                Math.pow(guestPredictedBall.y - serverBall.y, 2)
                            );
                            
                            // If guest prediction drifted too far from server, resync
                            if (distance > 50) {
                                console.log('🔄 Resyncing guest prediction with server (distance:', distance, ')');
                                guestPredictedBall = { ...serverBall };
                                lastServerSync = Date.now();
                            }
                        }
                    }
                }
                
                // Handle game completion for all players
                if (roomData.status === 'completed' && previousStatus === 'playing') {
                    console.log('🏁 Game completed for player:', currentUser.uid === roomData.hostId ? 'Host' : 'Guest');
                    
                    // Stop any running intervals
                    if (pongInterval) {
                        clearInterval(pongInterval);
                        pongInterval = null;
                    }
                    if (racingUpdateInterval) {
                        clearInterval(racingUpdateInterval);
                        racingUpdateInterval = null;
                    }
                    if (reactionTimeout) {
                        clearTimeout(reactionTimeout);
                        reactionTimeout = null;
                    }
                }
                
                // Update game data without recreating UI (prevents flickering)
                if (roomData.status === 'playing' || roomData.status === 'completed') {
                    // Call specific update functions that only update dynamic content
                    switch (roomData.gameType) {
                        case 'pong':
                            if (window.updatePongScores) window.updatePongScores();
                            break;
                        case 'typing':
                            if (window.updateTypingProgress) window.updateTypingProgress(roomData);
                            break;
                        case 'reaction':
                            if (window.updateReactionGame) window.updateReactionGame(roomData);
                            break;
                        case 'racing':
                            if (window.updateRacingScores) window.updateRacingScores(roomData);
                            break;
                    }
                }
                
                // Show winner screen for normal completions (not disconnections)
                if (roomData.status === 'completed' && !roomData.disconnectedPlayer && !winnerScreenShown) {
                    setTimeout(() => showWinnerScreen(roomData), 1000);
                }
            } else {
                // First time receiving room data - set currentGameData
                console.log('📥 First time receiving room data:', {
                    status: roomData.status,
                    hasHost: !!roomData.hostId,
                    hasGuest: !!roomData.guestId,
                    playerRole: currentUser.uid === roomData.hostId ? 'Host' : 'Guest'
                });
                
                currentGameData = roomData;
                
                if (roomData.status === 'playing') {
                    // Initialize game for the first time - BOTH players will see this
                    console.log('🎮 Initializing game for:', currentUser.uid === roomData.hostId ? 'Host' : 'Guest');
                    initializeGameInLobby(roomData, roomId);
                } else if (roomData.status === 'waiting' && roomData.guestId) {
                    updateLobbyWithGuest(roomData);
                }
            }
        }
        
        function initializeGameInLobby(roomData, roomId) {
            console.log('🎮 Initializing game in lobby:', roomData.gameType, 'for player:', currentUser.uid === roomData.hostId ? 'Host' : 'Guest');
            
            // Enhanced currentGameData setting with name validation
            currentGameData = {
                ...roomData,
                // Ensure proper names are set - fix guest display issue
                hostName: roomData.hostName || currentGameData?.hostName || 'Host',
                guestName: roomData.guestName && roomData.guestName !== 'guest' && roomData.guestName !== 'Guest' 
                    ? roomData.guestName 
                    : (currentGameData?.guestName || 'Player 2')
            };
            
            // Update lobby content to show game is starting
            const lobbyContent = document.getElementById('lobby-content');
            if (!lobbyContent) {
                console.error('❌ Lobby content element not found!');
                return;
            }
            
            // Update game status to show game starting
            const gameStatus = document.getElementById('game-status');
            if (gameStatus) {
                gameStatus.innerHTML = '<span class="text-foam">Game starting...</span>';
            }
            
            // Force update guest slot with correct name before game starts
            const guestSlot = document.getElementById('guest-slot');
            if (guestSlot && currentGameData.guestName) {
                guestSlot.innerHTML = `
                    <div class="flex items-center gap-3">
                        ${currentGameData.guestPhoto ? 
                            `<img src="${currentGameData.guestPhoto}" class="w-10 h-10 rounded-full border-2 border-iris">` :
                            `<div class="w-10 h-10 rounded-full border-2 border-iris bg-iris/20 flex items-center justify-center">
                                <i class="bx bx-user text-iris"></i>
                            </div>`
                        }
                        <div class="flex-1">
                            <div class="font-semibold text-text">${currentGameData.guestName}</div>
                            <div class="text-xs text-iris">Guest (Player 2)</div>
                        </div>
                    </div>
                `;
            }
            
            console.log('✅ Creating game container with correct player names...');
            lobbyContent.innerHTML = `
                <div id="game-container" class="w-full h-full flex flex-col items-center justify-center">
                    <div class="text-center mb-4">
                        <h3 class="text-2xl font-bold text-foam mb-2">Game Started!</h3>
                        <p class="text-muted">${getGameDisplayName(currentGameData.gameType)} is now in progress</p>
                        <p class="text-xs text-muted mt-2">
                            Host: ${currentGameData.hostName} vs Guest: ${currentGameData.guestName}
                        </p>
                    </div>
                    <div id="game-area-content" class="w-full flex-1 flex items-center justify-center min-h-[400px]">
                        <div class="flex items-center justify-center">
                            <div class="spinner mr-3"></div>
                            <span class="text-muted">Loading ${getGameDisplayName(currentGameData.gameType)}...</span>
                        </div>
                    </div>
                </div>
            `;
            
            // Enhanced game initialization with proper error handling
            setTimeout(() => {
                const gameAreaContent = document.getElementById('game-area-content');
                if (!gameAreaContent) {
                    console.error('❌ Game area content element not found after creation!');
                    showNotification('Error', 'Failed to initialize game UI', 'error');
                    return;
                }
                
                // Validate game state before starting
                if (!currentGameData.gameState) {
                    console.error('❌ Missing game state for game type:', currentGameData.gameType);
                    gameAreaContent.innerHTML = `
                        <div class="text-center text-love">
                            <h3 class="text-xl font-bold mb-4">Game Error</h3>
                            <p>Game state is missing. Please try starting a new game.</p>
                        </div>
                    `;
                    return;
                }
                
                console.log('✅ Game area content found, starting game:', currentGameData.gameType);
                console.log('✅ Player names confirmed - Host:', currentGameData.hostName, 'Guest:', currentGameData.guestName);
                
                try {
                    startGame(currentGameData, roomId);
                } catch (error) {
                    console.error('❌ Error starting game:', error);
                    gameAreaContent.innerHTML = `
                        <div class="text-center text-love">
                            <h3 class="text-xl font-bold mb-4">Game Error</h3>
                            <p>Failed to start game: ${error.message}</p>
                            <button onclick="backToSelection()" class="mt-4 px-4 py-2 bg-love hover:bg-love/80 text-white rounded-lg">
                                Back to Games
                            </button>
                        </div>
                    `;
                    showNotification('Error', 'Failed to start game', 'error');
                }
            }, 100);
        }

        function updateLobbyWithGuest(roomData) {
            console.log('🎯 Updating lobby with guest:', roomData.guestName, 'Host:', roomData.hostName);
            
            // Ensure currentGameData is set for both players and force name update
            currentGameData = {
                ...currentGameData,
                ...roomData,
                // Force update names to prevent "guest" showing
                hostName: roomData.hostName || currentGameData?.hostName || 'Host',
                guestName: roomData.guestName || currentGameData?.guestName || 'Guest'
            };
            
            const guestSlot = document.getElementById('guest-slot');
            if (guestSlot && roomData.guestName) {
                // Enhanced name display with better fallback handling
                const displayName = roomData.guestName && 
                                  roomData.guestName !== 'guest' && 
                                  roomData.guestName !== 'Guest' && 
                                  roomData.guestName !== 'undefined'
                    ? roomData.guestName 
                    : (currentUser?.displayName || currentUser?.email || currentUser?.uid || 'Player 2');
                
                guestSlot.innerHTML = `
                    <div class="flex items-center gap-3">
                        ${roomData.guestPhoto ? 
                            `<img src="${roomData.guestPhoto}" class="w-10 h-10 rounded-full border-2 border-iris">` :
                            `<div class="w-10 h-10 rounded-full border-2 border-iris bg-iris/20 flex items-center justify-center">
                                <i class="bx bx-user text-iris"></i>
                            </div>`
                        }
                        <div class="flex-1">
                            <div class="font-semibold text-text">${displayName}</div>
                            <div class="text-xs text-iris">Guest (Player 2)</div>
                        </div>
                    </div>
                `;
                guestSlot.classList.remove('border-dashed', 'border-highlight-med');
                guestSlot.classList.add('border-solid', 'border-iris');
                
                // Update game status to show both players found
                const gameStatus = document.getElementById('game-status');
                if (gameStatus) {
                    gameStatus.innerHTML = '<span class="text-foam">Both players connected!</span>';
                }
                
                // Enhanced game start logic - ensure both players see correct names
                if (roomData.hostId === currentUser.uid && roomData.guestId && roomData.status === 'waiting') {
                    console.log('🚀 Host starting game automatically - both players ready');
                    
                    // Update names in database before starting game to prevent display issues
                    const nameUpdate = {
                        hostName: roomData.hostName || currentGameData.hostName,
                        guestName: displayName, // Use the properly resolved name
                        status: 'playing',
                        gameStartedAt: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : firebase.database.ServerValue.TIMESTAMP,
                        lastActivity: firebase.firestore ? firebase.firestore.FieldValue.serverTimestamp() : firebase.database.ServerValue.TIMESTAMP
                    };
                    
                    setTimeout(() => {
                        // Use appropriate database based on game type
                        if (roomData.gameType === 'pong') {
                            realtimeDb.ref(`pong-rooms/${currentRoom}`).update(nameUpdate).then(() => {
                                console.log('✅ Pong game status updated to playing with correct names');
                                // Initialize pong physics after status update
                                startPongGame(currentRoom);
                            }).catch(error => {
                                console.error('❌ Error starting pong game:', error);
                            });
                        } else {
                            // Handle regular games (typing, reaction, racing) - use Realtime DB
                            realtimeDb.ref(`game-rooms/${currentRoom}`).update(nameUpdate).then(() => {
                                console.log('✅ Regular game status updated to playing with correct names');
                                showNotification('Game Starting!', 'Both players connected - game begins now!', 'success');
                            }).catch(error => {
                                console.error('❌ Error starting regular game:', error);
                            });
                        }
                    }, 1000); // Slight delay to ensure name propagation
                }
            }
        }

        function startGame(roomData, roomId) {
            const gameContent = document.getElementById('game-content');
            
            switch (roomData.gameType) {
                case 'pong':
                    startPongGame(roomData, roomId);
                    break;
                case 'typing':
                    startTypingGame(roomData, roomId);
                    break;
                case 'reaction':
                    startReactionGame(roomData, roomId);
                    break;
                case 'racing':
                    startRacingGame(roomData, roomId);
                    break;
            }
        }

        // Global game state for real-time updates
        // currentGameData and pongInterval are already declared above

        // Pong Game Implementation
        function startPongGame(roomData, roomId) {
            console.log('🏓 Starting Pong Game...');
            currentGameData = roomData;
            
            const gameAreaContent = document.getElementById('game-area-content');
            if (!gameAreaContent) {
                console.error('❌ Game area content not found for Pong!');
                return;
            }
            
            // Validate game state
            if (!currentGameData.gameState || !currentGameData.gameState.ball || !currentGameData.gameState.player1 || !currentGameData.gameState.player2) {
                console.error('❌ Invalid game state for Pong:', currentGameData.gameState);
                gameAreaContent.innerHTML = `
                    <div class="text-center text-love">
                        <h3 class="text-xl font-bold mb-4">Game Error</h3>
                        <p>Invalid pong game state. Please try again.</p>
                    </div>
                `;
                return;
            }
            
            // Initialize guest prediction system for non-host players
            const isGuest = roomData.hostId !== currentUser.uid;
            if (isGuest) {
                console.log('🎯 Setting up guest prediction system');
                guestPredictedBall = { ...currentGameData.gameState.ball };
                lastServerSync = Date.now();
                console.log('🎯 Guest ball initialized:', guestPredictedBall);
            }
            
            // Create UI once and never recreate it
            gameAreaContent.innerHTML = `
                <div class="w-full max-w-4xl">
                    <div class="flex justify-between items-center mb-4">
                        <div class="text-text">
                            <span class="text-foam font-bold">${currentGameData.hostName}</span>
                            <span id="player1-score" class="text-2xl font-bold ml-2">${currentGameData.gameState.player1.score || 0}</span>
                        </div>
                        <div class="text-xl font-bold text-text">Ping Pong</div>
                        <div class="text-text">
                            <span id="player2-score" class="text-2xl font-bold mr-2">${currentGameData.gameState.player2.score || 0}</span>
                            <span class="text-iris font-bold">${currentGameData.guestName}</span>
                        </div>
                    </div>
                    <div class="bg-surface border border-highlight-med rounded-xl p-4">
                        <canvas id="pong-canvas" class="mx-auto border border-highlight-med rounded-lg" width="800" height="400" style="max-width: 100%; height: auto; background-color: #1f1d2e;"></canvas>
                    </div>
                    <div class="text-center mt-4 text-muted">
                        Use mouse to move your paddle • First to 5 points wins
                    </div>
                </div>
            `;
            
            // Initialize game
            setTimeout(() => initPongGame(roomId), 100);
            
                            // Update scores function
            window.updatePongScores = function() {
                const p1Score = document.getElementById('player1-score');
                const p2Score = document.getElementById('player2-score');
                if (p1Score && currentGameData) p1Score.textContent = currentGameData.gameState.player1.score || 0;
                if (p2Score && currentGameData) p2Score.textContent = currentGameData.gameState.player2.score || 0;
            };
        }

        function initPongGame(roomId) {
            // Clean up any existing intervals
            if (pongInterval) {
                clearInterval(pongInterval);
                pongInterval = null;
            }
            
            // Wait for canvas to be ready in the DOM
            setTimeout(() => {
                const canvas = document.getElementById('pong-canvas');
                if (!canvas) {
                    console.error('Pong canvas not found!');
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Canvas context not available!');
                    return;
                }
                
                const isPlayer1 = currentGameData.hostId === currentUser.uid;
                
                // Validate game state and show debug info
                if (!currentGameData.gameState || !currentGameData.gameState.ball || !currentGameData.gameState.player1 || !currentGameData.gameState.player2) {
                    console.error('Invalid game state for Pong:', currentGameData.gameState);
                    
                    // Show error on canvas
                    ctx.fillStyle = '#1f1d2e';
                    ctx.fillRect(0, 0, 800, 400);
                    ctx.fillStyle = '#eb6f92';
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Game State Error - Check Console', 400, 200);
                    return;
                }
                
                // Initial render to show something immediately
                renderPongFrame(ctx, currentGameData.gameState, currentGameData);
                
                // Mouse control with aggressive updates for collision detection
                const mouseHandler = (e) => {
                    if (currentGameData.status !== 'playing') return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseY = e.clientY - rect.top;
                    const paddleY = Math.max(0, Math.min(350, mouseY - 25));
                    
                    // Ultra-conservative paddle updates - 10 FPS to prevent quota exhaustion
                    if (!canvas.lastUpdate || Date.now() - canvas.lastUpdate > 100) {
                        const updateData = {};
                        updateData[`gameState.${isPlayer1 ? 'player1' : 'player2'}.y`] = paddleY;
                        updateData[`gameState.${isPlayer1 ? 'player1' : 'player2'}.lastUpdate`] = Date.now();
                        updateData['lastActivity'] = firebase.firestore.FieldValue.serverTimestamp();
                        
                        // Update local data immediately for smooth rendering
                        if (isPlayer1) {
                            currentGameData.gameState.player1.y = paddleY;
                            currentGameData.gameState.player1.lastUpdate = Date.now();
                        } else {
                            currentGameData.gameState.player2.y = paddleY;
                            currentGameData.gameState.player2.lastUpdate = Date.now();
                        }
                        
                        // Add retry logic for Firebase errors
                        db.collection('game-rooms').doc(roomId).update(updateData).catch(error => {
                            console.warn('Paddle update failed:', error.code || error);
                            recordFirebaseError(error.code);
                            
                            // Only retry for specific error types and if not in emergency mode
                            if (error.code === 'unavailable' && !quotaExceeded && firebaseErrorCount < 5) {
                                setTimeout(() => {
                                    db.collection('game-rooms').doc(roomId).update(updateData).catch(console.error);
                                }, 500);
                            }
                        });
                        canvas.lastUpdate = Date.now();
                    }
                };
                
                canvas.addEventListener('mousemove', mouseHandler);
                
                // Store handler for cleanup
                canvas.pongMouseHandler = mouseHandler;
                
                // Game physics loop with ultra-conservative rates
                if (isPlayer1) {
                    console.log('🎮 Starting Pong physics loop for host at 10 FPS (quota conserving)');
                    pongInterval = setInterval(() => {
                        updatePongPhysics(roomId);
                    }, 100); // 10 FPS to prevent quota exhaustion
                } else {
                    // Guest runs local physics prediction for smooth ball movement
                    console.log('🎮 Starting local prediction physics for guest at 60 FPS');
                    
                    // Reset guest prediction for new game
                    guestPredictedBall = null;
                    lastServerSync = 0;
                    
                    pongInterval = setInterval(() => {
                        updateGuestPrediction();
                    }, 16.67); // 60 FPS local prediction (no Firebase writes)
                }
                
                // Render loop
                function render() {
                    const canvas = document.getElementById('pong-canvas');
                    if (!currentGameData || !canvas || !currentGameData.gameState) {
                        console.log('Stopping Pong render - missing data or canvas');
                        if (pongInterval) {
                            clearInterval(pongInterval);
                            pongInterval = null;
                        }
                        return;
                    }
                    
                    const gameState = currentGameData.gameState;
                    
                    // Validate required properties
                    if (!gameState.ball || !gameState.player1 || !gameState.player2) {
                        console.warn('Invalid game state in render:', gameState);
                        requestAnimationFrame(render);
                        return;
                    }
                    
                    try {
                        renderPongFrame(ctx, gameState, currentGameData);
                        
                        // Check for game completion - ensure both players stop
                        if (currentGameData.status === 'completed') {
                            console.log('🏁 Game completed in render loop');
                            if (pongInterval) {
                                clearInterval(pongInterval);
                                pongInterval = null;
                            }
                            
                            // Show final state with winner overlay
                            renderPongFrame(ctx, gameState, currentGameData);
                            return;
                        }
                        
                        requestAnimationFrame(render);
                    } catch (error) {
                        console.error('Error rendering Pong game:', error);
                        requestAnimationFrame(render);
                    }
                }
                
                // Start 60 FPS render loop for smooth visuals (physics runs at 30 FPS for network optimization)
                render();
            }, 150); // Wait a bit longer for DOM to be ready
        }
        
        function renderPongFrame(ctx, gameState, roomData) {
            // Clear canvas
            ctx.fillStyle = '#1f1d2e';
            ctx.fillRect(0, 0, 800, 400);
            
            // Draw center line
            ctx.strokeStyle = '#403d52';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(400, 0);
            ctx.lineTo(400, 400);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw paddles with smoother interpolation
            ctx.fillStyle = '#9ccfd8';
            
            // Smooth paddle positions for better visual experience
            const paddle1Y = gameState.player1.y || 175;
            const paddle2Y = gameState.player2.y || 175;
            
            ctx.fillRect(10, paddle1Y, 10, 50);
            ctx.fillRect(780, paddle2Y, 10, 50);
            
            // Draw collision zones for debugging (semi-transparent)
            const isHost = roomData.hostId === currentUser.uid;
            if (!isHost) {
                ctx.fillStyle = 'rgba(156, 207, 216, 0.3)';
                // Left paddle collision zone (expanded)
                ctx.fillRect(5, paddle1Y - 15, 35, 80);
                // Right paddle collision zone (expanded for guest)  
                ctx.fillRect(760, paddle2Y - 15, 35, 80);
                
                // Draw collision zone borders for clarity
                ctx.strokeStyle = 'rgba(156, 207, 216, 0.8)';
                ctx.lineWidth = 1;
                ctx.strokeRect(5, paddle1Y - 15, 35, 80);
                ctx.strokeRect(760, paddle2Y - 15, 35, 80);
            }
            
            // Use local predicted ball for guests, server ball for host
            let ballX, ballY;
            
            if (!isHost && guestPredictedBall && guestPredictedBall.x !== undefined && guestPredictedBall.y !== undefined) {
                // Guest uses locally predicted ball for 60 FPS smooth movement
                ballX = guestPredictedBall.x;
                ballY = guestPredictedBall.y;
            } else {
                // Fallback to server ball (host or guest without prediction)
                ballX = gameState.ball.x || 400;
                ballY = gameState.ball.y || 200;
                
                // Debug log for guest fallback
                if (!isHost && !guestPredictedBall) {
                    console.log('⚠️ Guest using server ball, prediction not ready');
                }
            }
            
            ctx.fillStyle = '#eb6f92';
            ctx.beginPath();
            ctx.arc(ballX, ballY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw scores
            ctx.fillStyle = '#e0def4';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${gameState.player1.score || 0}`, 200, 40);
            ctx.fillText(`${gameState.player2.score || 0}`, 600, 40);
            
            // Draw enhanced debug info
            ctx.fillStyle = '#6e6a86';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            const ballType = (!isHost && guestPredictedBall) ? 'Pred' : 'Auth';
            ctx.fillText(`Ball ${ballType}: (${Math.round(ballX)}, ${Math.round(ballY)})`, 10, 380);
            ctx.fillText(`P1: ${Math.round(paddle1Y)}, P2: ${Math.round(paddle2Y)}`, 10, 392);
            
            // Show sync info for guests
            if (!isHost) {
                const lastUpdate = gameState.ball.lastUpdate;
                const syncLag = lastUpdate ? Date.now() - lastUpdate : 0;
                const usingPrediction = guestPredictedBall ? 'Local 60FPS' : 'Server';
                let connectionStatus = firebaseErrorCount > 10 ? 'Critical' : firebaseErrorCount > 5 ? 'Poor' : firebaseErrorCount > 0 ? 'Fair' : 'Good';
                
                if (quotaExceeded) {
                    connectionStatus = 'QUOTA EXCEEDED';
                }
                
                ctx.fillText(`Sync: ${syncLag}ms | Connection: ${connectionStatus}`, 200, 380);
                ctx.fillText(`Ball: ${usingPrediction}`, 200, 392);
                
                if (guestPredictedBall) {
                    ctx.fillText(`Speed: ${guestPredictedBall.dx.toFixed(1)}, ${guestPredictedBall.dy.toFixed(1)}`, 350, 380);
                } else {
                    ctx.fillText(`Server: ${gameState.ball.dx?.toFixed(1) || 0}, ${gameState.ball.dy?.toFixed(1) || 0}`, 350, 380);
                }
                
                // Show additional debug info
                ctx.fillText(`LastSync: ${Date.now() - lastServerSync}ms ago`, 500, 392);
            }
            
            // Check for game completion
            if (roomData.status === 'completed') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 800, 400);
                ctx.fillStyle = '#e0def4';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                const winner = (gameState.player1.score || 0) >= 5 ? roomData.hostName : roomData.guestName;
                ctx.fillText(`${winner} Wins!`, 400, 200);
            }
        }

        // Guest-specific local prediction variables
        let guestPredictedBall = null;
        let lastServerSync = 0;
        let firebaseErrorCount = 0;
        let lastFirebaseError = 0;
        
        // Rate limiting for Firebase updates
        function shouldAllowUpdate() {
            const now = Date.now();
            
            // Emergency mode - near zero updates if quota exceeded
            if (quotaExceeded) {
                return now - lastFirebaseError > 2000; // 0.5 FPS emergency mode
            }
            
            // If we've had quota errors, be extremely conservative
            if (firebaseErrorCount > 10 && now - lastFirebaseError < 15000) {
                return now - lastFirebaseError > 1000; // Slow down to 1 FPS if quota errors
            }
            
            // If we've had recent errors, be more conservative
            if (firebaseErrorCount > 5 && now - lastFirebaseError < 10000) {
                return now - lastFirebaseError > 500; // Slow down to 2 FPS if errors
            }
            
            // Always enforce minimum 10 FPS to prevent quota exhaustion
            return now - lastFirebaseError > 100;
        }
        
        let quotaExceeded = false;
        
        function recordFirebaseError(errorCode) {
            firebaseErrorCount++;
            lastFirebaseError = Date.now();
            
            // Handle quota exhaustion specifically
            if (errorCode === 'resource-exhausted') {
                quotaExceeded = true;
                firebaseErrorCount += 10; // Heavy penalty for quota errors
                showNotification('Quota Exceeded', 'Firebase quota exhausted - switching to emergency mode', 'error');
                
                // Emergency mode - stop all physics updates for host
                if (pongInterval) {
                    clearInterval(pongInterval);
                    pongInterval = setInterval(() => {
                        updatePongPhysics(currentRoom);
                    }, 2000); // 0.5 FPS emergency mode
                }
                
                // Reset quota flag after 5 minutes
                setTimeout(() => {
                    quotaExceeded = false;
                    showNotification('Quota Reset', 'Resuming normal operation', 'success');
                }, 300000);
            }
            
            // Show notification for poor connection
            if (firebaseErrorCount === 3) {
                showNotification('Connection Issues', 'Experiencing network lag - game may feel slower', 'warning');
            } else if (firebaseErrorCount === 5) {
                showNotification('Poor Connection', 'Switching to offline mode for better experience', 'info');
            }
            
            // Reset error count after 60 seconds of no errors (increased from 30)
            setTimeout(() => {
                if (Date.now() - lastFirebaseError > 60000) {
                    const hadPoorConnection = firebaseErrorCount >= 3;
                    firebaseErrorCount = Math.max(0, firebaseErrorCount - 5); // Gradual recovery
                    if (hadPoorConnection && firebaseErrorCount === 0) {
                        showNotification('Connection Restored', 'Network stability improved', 'success');
                    }
                }
            }, 60000);
        }
        
        function updateGuestPrediction() {
            if (!currentGameData || currentGameData.status !== 'playing' || !currentGameData.gameState || !currentGameData.gameState.ball) {
                return;
            }
            
            const serverBall = currentGameData.gameState.ball;
            const now = Date.now();
            
            // Initialize guest prediction if not exists or server ball changed significantly
            if (!guestPredictedBall) {
                console.log('🎯 Initializing guest ball prediction:', serverBall);
                guestPredictedBall = { ...serverBall };
                // Ensure ball has velocity
                if (!guestPredictedBall.dx || !guestPredictedBall.dy) {
                    guestPredictedBall.dx = guestPredictedBall.dx || 3;
                    guestPredictedBall.dy = guestPredictedBall.dy || 2;
                    console.log('⚡ Added default velocity to guest ball:', guestPredictedBall.dx, guestPredictedBall.dy);
                }
                lastServerSync = now;
                return;
            }
            
            // Sync with server every 200ms or if ball velocity is zero (stuck)
            const ballStuck = (guestPredictedBall.dx === 0 && guestPredictedBall.dy === 0);
            const syncDue = (now - lastServerSync > 200);
            
            if (syncDue || ballStuck) {
                console.log('🔄 Syncing guest prediction with server ball', ballStuck ? '(ball stuck)' : '(periodic sync)');
                guestPredictedBall = { ...serverBall };
                // Ensure ball has velocity after sync
                if (!guestPredictedBall.dx || !guestPredictedBall.dy) {
                    guestPredictedBall.dx = guestPredictedBall.dx || 3;
                    guestPredictedBall.dy = guestPredictedBall.dy || 2;
                    console.log('⚡ Added default velocity after sync:', guestPredictedBall.dx, guestPredictedBall.dy);
                }
                lastServerSync = now;
                return;
            }
            
            // Run local physics at 60 FPS for smooth movement
            guestPredictedBall.x += guestPredictedBall.dx;
            guestPredictedBall.y += guestPredictedBall.dy;
            
            // Wall bounces
            if (guestPredictedBall.y <= 8 || guestPredictedBall.y >= 392) {
                guestPredictedBall.dy = -guestPredictedBall.dy;
            }
            
            // Paddle collisions (simplified for guest prediction)
            const player1 = currentGameData.gameState.player1;
            const player2 = currentGameData.gameState.player2;
            
            // Left paddle collision
            if (guestPredictedBall.x <= 40 && guestPredictedBall.x >= 5 && guestPredictedBall.dx < 0 &&
                guestPredictedBall.y >= player1.y - 15 && guestPredictedBall.y <= player1.y + 65) {
                guestPredictedBall.dx = Math.abs(guestPredictedBall.dx) + 0.1;
                guestPredictedBall.dy += (guestPredictedBall.y - (player1.y + 25)) * 0.05;
                guestPredictedBall.x = 40;
            }
            
            // Right paddle collision
            if (guestPredictedBall.x >= 760 && guestPredictedBall.x <= 795 && guestPredictedBall.dx > 0 &&
                guestPredictedBall.y >= player2.y - 15 && guestPredictedBall.y <= player2.y + 65) {
                guestPredictedBall.dx = -Math.abs(guestPredictedBall.dx) - 0.1;
                guestPredictedBall.dy += (guestPredictedBall.y - (player2.y + 25)) * 0.05;
                guestPredictedBall.x = 760;
            }
            
            // Reset if ball goes off screen
            if (guestPredictedBall.x < 0 || guestPredictedBall.x > 800) {
                console.log('⚠️ Ball went off screen, resyncing with server');
                guestPredictedBall = { ...serverBall };
                lastServerSync = now;
            }
        }

        async function updatePongPhysics(roomId) {
            try {
                // Check rate limiting before proceeding
                if (!shouldAllowUpdate()) {
                    return;
                }
                
                // Fetch fresh data from Firebase to ensure we have latest paddle positions
                const doc = await db.collection('game-rooms').doc(roomId).get();
                if (!doc.exists || doc.data().status !== 'playing') {
                    return;
                }
                
                const roomData = doc.data();
                const ball = { ...roomData.gameState.ball };
                const player1 = { ...roomData.gameState.player1 };
                const player2 = { ...roomData.gameState.player2 };
                
                // Update ball position
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Ball collision with top/bottom walls
                if (ball.y <= 8 || ball.y >= 392) {
                    ball.dy = -ball.dy;
                }
                
                // Ultra-generous collision detection with massive lag compensation
                let collided = false;
                
                // Ball collision with left paddle (Player 1) - expanded hit zone
                if (ball.x <= 40 && ball.x >= 5 && ball.dx < 0 &&
                    ball.y >= player1.y - 15 && ball.y <= player1.y + 65) {
                    ball.dx = Math.abs(ball.dx) + 0.1;
                    ball.dy += (ball.y - (player1.y + 25)) * 0.05;
                    ball.x = 40; // Move ball well away from paddle
                    collided = true;
                    console.log('🏓 Player 1 paddle hit!');
                }
                
                // Ball collision with right paddle (Player 2) - expanded hit zone for guest
                if (ball.x >= 760 && ball.x <= 795 && ball.dx > 0 &&
                    ball.y >= player2.y - 15 && ball.y <= player2.y + 65) {
                    ball.dx = -Math.abs(ball.dx) - 0.1;
                    ball.dy += (ball.y - (player2.y + 25)) * 0.05;
                    ball.x = 760; // Move ball well away from paddle
                    collided = true;
                    console.log('🏓 Player 2 paddle hit!');
                }
                
                // Scoring
                let scored = false;
                if (ball.x < 0) {
                    player2.score++;
                    scored = true;
                }
                if (ball.x > 800) {
                    player1.score++;
                    scored = true;
                }
                
                if (scored) {
                    // Reset ball
                    ball.x = 400;
                    ball.y = 200;
                    ball.dx = (Math.random() > 0.5 ? 3 : -3);
                    ball.dy = (Math.random() - 0.5) * 4;
                }
                
                // Check for game completion
                let gameCompleted = false;
                if (player1.score >= 5 || player2.score >= 5) {
                    gameCompleted = true;
                }
                
                // Add timestamp for client prediction
                ball.lastUpdate = Date.now();
                
                // Update Firebase with new positions
                const updateData = {
                    'gameState.ball': ball,
                    'gameState.player1': player1,
                    'gameState.player2': player2,
                    'lastActivity': firebase.firestore.FieldValue.serverTimestamp()
                };
                
                if (gameCompleted) {
                    updateData.status = 'completed';
                    updateData.winner = player1.score >= 5 ? 'player1' : 'player2';
                    console.log('🏆 Game completed! Winner:', updateData.winner);
                    
                    // Stop physics immediately
                    if (pongInterval) {
                        clearInterval(pongInterval);
                        pongInterval = null;
                    }
                }
                
                // Update local data immediately for smooth rendering
                currentGameData.gameState.ball = ball;
                currentGameData.gameState.player1 = player1;
                currentGameData.gameState.player2 = player2;
                if (gameCompleted) {
                    currentGameData.status = 'completed';
                    currentGameData.winner = updateData.winner;
                }
                
                await db.collection('game-rooms').doc(roomId).update(updateData);
                
            } catch (error) {
                console.error('❌ Error updating pong physics:', error.code || error);
                recordFirebaseError(error.code);
                
                // Handle specific Firebase errors
                if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
                    console.warn('Firebase temporarily unavailable, will retry next frame');
                } else if (error.code === 'permission-denied') {
                    console.error('Permission denied - check Firebase rules');
                } else if (error.code === 'resource-exhausted') {
                    console.error('🚨 QUOTA EXCEEDED - Emergency slowdown activated');
                    // Emergency mode already handled in recordFirebaseError
                } else if (error.message && error.message.includes('400')) {
                    console.warn('Bad request to Firebase - likely rate limited');
                }
            }
        }

        // Typing Game Implementation
        async function setupTypingListeners(roomId) {
            const gameStateRef = realtimeDb.ref(`game-rooms/${roomId}/gameState`);
            gameStateRef.on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    if (currentGameData) {
                        currentGameData.gameState = gameState;
                        if (window.updateTypingProgress) {
                            window.updateTypingProgress(currentGameData);
                        }
                    }
                }
            });
        }

        function startTypingGame(roomData, roomId) {
            currentGameData = roomData;
            const isPlayer1 = roomData.hostId === currentUser.uid;
            
            console.log('Starting Typing Game:', {
                isPlayer1: isPlayer1,
                gameState: roomData.gameState,
                sentence: roomData.gameState.sentence
            });
            
            const gameAreaContent = document.getElementById('game-area-content');
            if (!gameAreaContent) return;
            
            const gameState = currentGameData.gameState;
            
            // Validate game state
            if (!gameState || !gameState.sentence) {
                console.error('Invalid typing game state:', gameState);
                gameAreaContent.innerHTML = `
                    <div class="text-center text-love">
                        <h3 class="text-xl font-bold mb-4">Game Error</h3>
                        <p>Invalid typing game state. Please try again.</p>
                    </div>
                `;
                return;
            }
            
            // Create UI once
            gameAreaContent.innerHTML = `
                <div class="w-full max-w-4xl">
                    <h3 class="text-2xl font-bold text-text mb-6 text-center">Typing Duel</h3>
                    
                    <div class="bg-overlay rounded-lg p-4 mb-6 border-2 border-gold">
                        <div class="text-center text-lg text-text font-mono leading-relaxed break-words">
                            "${gameState.sentence.trim()}"
                        </div>
                        <div class="text-center text-xs text-muted mt-2">
                            ${gameState.sentence.length} characters
                        </div>
                    </div>
                    
                    <div class="space-y-4 mb-6">
                        <div class="p-4 bg-highlight-med rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-foam font-bold">${currentGameData.hostName}</span>
                                <span id="typing-p1-percent" class="text-muted">${Math.round(((gameState.player1Progress || 0) / gameState.sentence.length) * 100)}%</span>
                            </div>
                            <div class="w-full bg-overlay rounded-full h-3">
                                <div id="typing-p1-progress" class="bg-foam h-3 rounded-full transition-all duration-300" style="width: ${((gameState.player1Progress || 0) / gameState.sentence.length) * 100}%"></div>
                            </div>
                            <div id="typing-p1-text" class="text-xs text-muted mt-1 font-mono">${gameState.player1Text || ''}</div>
                        </div>
                        
                        <div class="p-4 bg-highlight-med rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-iris font-bold">${currentGameData.guestName}</span>
                                <span id="typing-p2-percent" class="text-muted">${Math.round(((gameState.player2Progress || 0) / gameState.sentence.length) * 100)}%</span>
                            </div>
                            <div class="w-full bg-overlay rounded-full h-3">
                                <div id="typing-p2-progress" class="bg-iris h-3 rounded-full transition-all duration-300" style="width: ${((gameState.player2Progress || 0) / gameState.sentence.length) * 100}%"></div>
                            </div>
                            <div id="typing-p2-text" class="text-xs text-muted mt-1 font-mono">${gameState.player2Text || ''}</div>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <input type="text" id="typing-input" class="w-full p-4 bg-overlay border-2 border-highlight-med rounded-lg text-text font-mono text-lg focus:outline-none focus:border-foam transition-colors" placeholder="Start typing the sentence..." autocomplete="off" spellcheck="false" ${currentGameData.status === 'completed' ? 'disabled' : ''}>
                        <div class="text-xs text-muted mt-1 text-center">
                            <span class="text-foam">Green border</span> = correct so far, 
                            <span class="text-love">Red border</span> = error detected
                        </div>
                    </div>
                    
                    <div id="typing-status" class="text-center text-muted">
                        ${currentGameData.status === 'completed' ? 
                            `🎉 ${gameState.winner === 'player1' ? currentGameData.hostName : currentGameData.guestName} wins!` :
                            '<strong>Type the sentence exactly as shown above</strong> - spaces and punctuation must match!'
                        }
                    </div>
                    
                    ${currentGameData.status !== 'completed' ? `
                        <div class="mt-4 text-center">
                            <div class="text-xs text-muted">
                                Your progress: <span id="typing-my-progress" class="text-foam font-bold">${Math.round(((isPlayer1 ? (gameState.player1Progress || 0) : (gameState.player2Progress || 0)) / gameState.sentence.length) * 100)}%</span>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Attach input handler once
            if (currentGameData.status !== 'completed') {
                attachTypingInputHandler(gameState, isPlayer1, roomId);
            }
            
            // Update function that only updates dynamic content - capture isPlayer1 in closure
            window.updateTypingProgress = function(newRoomData) {
                const newGameState = newRoomData.gameState;
                
                // Determine player role from current user ID
                const currentIsPlayer1 = newRoomData.hostId === currentUser?.uid;
                
                // Update progress bars and percentages
                const p1Percent = document.getElementById('typing-p1-percent');
                const p2Percent = document.getElementById('typing-p2-percent');
                const p1Progress = document.getElementById('typing-p1-progress');
                const p2Progress = document.getElementById('typing-p2-progress');
                const p1Text = document.getElementById('typing-p1-text');
                const p2Text = document.getElementById('typing-p2-text');
                const status = document.getElementById('typing-status');
                const myProgress = document.getElementById('typing-my-progress');
                
                if (p1Percent) p1Percent.textContent = `${Math.round(((newGameState.player1Progress || 0) / newGameState.sentence.length) * 100)}%`;
                if (p2Percent) p2Percent.textContent = `${Math.round(((newGameState.player2Progress || 0) / newGameState.sentence.length) * 100)}%`;
                if (p1Progress) p1Progress.style.width = `${((newGameState.player1Progress || 0) / newGameState.sentence.length) * 100}%`;
                if (p2Progress) p2Progress.style.width = `${((newGameState.player2Progress || 0) / newGameState.sentence.length) * 100}%`;
                if (p1Text) p1Text.textContent = newGameState.player1Text || '';
                if (p2Text) p2Text.textContent = newGameState.player2Text || '';
                if (myProgress) myProgress.textContent = `${Math.round(((currentIsPlayer1 ? (newGameState.player1Progress || 0) : (newGameState.player2Progress || 0)) / newGameState.sentence.length) * 100)}%`;
                
                if (status) {
                    if (newRoomData.status === 'completed') {
                        status.textContent = `🎉 ${newGameState.winner === 'player1' ? newRoomData.hostName : newRoomData.guestName} wins!`;
                    } else {
                        status.innerHTML = '<strong>Type the sentence exactly as shown above</strong> - spaces and punctuation must match!';
                    }
                }
                
                // Disable input if game completed
                const input = document.getElementById('typing-input');
                if (input && newRoomData.status === 'completed') {
                    input.disabled = true;
                }
            };
            
            function attachTypingInputHandler(gameState, isPlayer1, roomId) {
                setTimeout(() => {
                    const input = document.getElementById('typing-input');
                    if (!input) return;
                    
                    // Restore current player's text
                    const playerText = isPlayer1 ? (gameState.player1Text || '') : (gameState.player2Text || '');
                    input.value = playerText;
                    input.focus();
                    
                    let lastUpdate = 0;
                    input.addEventListener('input', (e) => {
                        const now = Date.now();
                        if (now - lastUpdate < 100) return; // Throttle updates for better network performance
                        lastUpdate = now;
                        
                        const text = e.target.value;
                        const sentence = gameState.sentence;
                        
                        // Calculate progress - only count consecutive correct characters from start
                        let progress = 0;
                        for (let i = 0; i < text.length && i < sentence.length; i++) {
                            if (text[i] === sentence[i]) {
                                progress = i + 1;
                            } else {
                                break;
                            }
                        }
                        
                        // Visual feedback for correctness
                        const isCorrectSoFar = text === sentence.substring(0, text.length);
                        input.style.borderColor = isCorrectSoFar ? '#9ccfd8' : '#eb6f92';
                        
                        // Check for winner - exact match and complete
                        const isWinner = text.length > 0 && text === sentence;
                        
                        const updateData = {};
                        updateData[`${isPlayer1 ? 'player1' : 'player2'}Progress`] = progress;
                        updateData[`${isPlayer1 ? 'player1' : 'player2'}Text`] = text;
                        
                        if (isWinner) {
                            console.log('🎉 WINNER DETECTED!', isPlayer1 ? 'player1' : 'player2');
                            updateData['winner'] = isPlayer1 ? 'player1' : 'player2';
                            
                            // Disable input immediately
                            input.disabled = true;
                            input.style.borderColor = '#22c55e'; // Green for winner
                            showNotification('🎉 You Won!', 'You completed the sentence first!', 'success');
                        }
                        
                        // Update game state in realtime database
                        realtimeDb.ref(`game-rooms/${roomId}/gameState`).update(updateData).catch(console.error);
                        
                        // Update room lastActivity
                        realtimeDb.ref(`game-rooms/${roomId}`).update({
                            lastActivity: firebase.database.ServerValue.TIMESTAMP
                        }).catch(console.error);
                        
                        // Update room status if winner
                        if (isWinner) {
                            realtimeDb.ref(`game-rooms/${roomId}`).update({
                                status: 'completed'
                            }).catch(console.error);
                        }
                    });
                }, 100);
            }
        }

        // Reaction Game Implementation
        async function setupReactionListeners(roomId) {
            const gameStateRef = realtimeDb.ref(`game-rooms/${roomId}/gameState`);
            gameStateRef.on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    if (currentGameData) {
                        currentGameData.gameState = gameState;
                        if (window.updateReactionGame) {
                            window.updateReactionGame(currentGameData);
                        }
                    }
                }
            });
        }

        function startReactionGame(roomData, roomId) {
            currentGameData = roomData;
            const isPlayer1 = roomData.hostId === currentUser.uid;
            
            const gameAreaContent = document.getElementById('game-area-content');
            if (!gameAreaContent) return;
            
            // Create UI once
            createReactionUI(gameAreaContent, currentGameData, isPlayer1);
            
            // Enhanced event listener setup with proper debouncing
            setTimeout(() => {
                const zone = document.getElementById('reaction-zone');
                if (zone) {
                    // Remove any existing event listeners to prevent duplicates
                    const existingClickHandler = zone.clickHandler;
                    const existingTouchHandler = zone.touchHandler;
                    const existingContextHandler = zone.contextHandler;
                    
                    if (existingClickHandler) {
                        zone.removeEventListener('click', existingClickHandler);
                    }
                    if (existingTouchHandler) {
                        zone.removeEventListener('touchstart', existingTouchHandler);
                    }
                    if (existingContextHandler) {
                        zone.removeEventListener('contextmenu', existingContextHandler);
                    }
                    
                    // Create new handlers with proper debouncing
                    const clickHandler = (e) => {
                        e.preventDefault();
                        handleReactionClick(roomId, isPlayer1);
                    };
                    
                    const touchHandler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        handleReactionClick(roomId, isPlayer1);
                    };
                    
                    const contextHandler = (e) => {
                        e.preventDefault();
                    };
                    
                    // Add new event listeners
                    zone.addEventListener('click', clickHandler);
                    zone.addEventListener('touchstart', touchHandler);
                    zone.addEventListener('contextmenu', contextHandler);
                    
                    // Store handlers for cleanup
                    zone.clickHandler = clickHandler;
                    zone.touchHandler = touchHandler;
                    zone.contextHandler = contextHandler;
                }
                
                // Host controls game flow
                if (isPlayer1) {
                    console.log('Host initializing reaction game flow');
                    handleReactionFlow(roomId, currentGameData.gameState);
                }
            }, 100);
            
            // Update function that only updates dynamic content - with recursion prevention
            let reactionUpdateInProgress = false;
            window.updateReactionGame = function(newGameData) {
                // Prevent infinite recursion from state updates
                if (reactionUpdateInProgress) {
                    console.log('Reaction update already in progress, skipping to prevent recursion');
                    return;
                }
                
                reactionUpdateInProgress = true;
                
                try {
                    currentGameData = newGameData;
                    const gameState = newGameData.gameState;
                    
                    // Determine if current user is host (player1)
                    const currentIsPlayer1 = newGameData.hostId === currentUser?.uid;
                    
                    // Update scores
                    const p1Score = document.getElementById('reaction-p1-score');
                    const p2Score = document.getElementById('reaction-p2-score');
                    const p1Time = document.getElementById('reaction-p1-time');
                    const p2Time = document.getElementById('reaction-p2-time');
                    const round = document.getElementById('reaction-round');
                    const zone = document.getElementById('reaction-zone');
                    const text = document.getElementById('reaction-text');
                    const status = document.getElementById('reaction-status');
                    
                    if (p1Score) p1Score.textContent = gameState.player1Score || 0;
                    if (p2Score) p2Score.textContent = gameState.player2Score || 0;
                    if (p1Time) p1Time.textContent = gameState.player1Time && gameState.player1Time > 0 ? gameState.player1Time + 'ms' : gameState.player1Time === -1 ? 'Too Early!' : '';
                    if (p2Time) p2Time.textContent = gameState.player2Time && gameState.player2Time > 0 ? gameState.player2Time + 'ms' : gameState.player2Time === -1 ? 'Too Early!' : '';
                    if (round) round.textContent = `Round ${gameState.round} of ${gameState.maxRounds}`;
                    if (text) text.textContent = getReactionText(gameState.currentState, gameState, newGameData);
                    
                    // Update zone color - improved class removal
                    if (zone) {
                        // Remove existing background color classes more reliably
                        zone.classList.remove('bg-green-500', 'bg-red-500', 'bg-overlay', 'bg-yellow-500', 'bg-blue-500');
                        
                        // Add appropriate background color
                        if (gameState.currentState === 'go') {
                            zone.classList.add('bg-green-500');
                        } else if (gameState.currentState === 'early') {
                            zone.classList.add('bg-red-500');
                        } else {
                            zone.classList.add('bg-overlay');
                        }
                    }
                    
                    // Update status
                    if (status) {
                        if (newGameData.status === 'completed') {
                            status.textContent = `🎉 ${(gameState.player1Score || 0) > (gameState.player2Score || 0) ? newGameData.hostName : newGameData.guestName} wins ${Math.max(gameState.player1Score || 0, gameState.player2Score || 0)}-${Math.min(gameState.player1Score || 0, gameState.player2Score || 0)}!`;
                        } else {
                            status.textContent = 'Click or tap the area above when it turns green!';
                        }
                    }
                    
                    // Host continues game flow - with additional safeguards
                    if (currentIsPlayer1 && newGameData.status === 'playing' && gameState) {
                        // Use setTimeout to break potential recursion and allow UI updates
                        setTimeout(() => {
                            if (currentGameData && currentGameData.status === 'playing') {
                                handleReactionFlow(roomId, gameState);
                            }
                        }, 10);
                    }
                } finally {
                    // Always reset the flag, even if an error occurs
                    reactionUpdateInProgress = false;
                }
            };
        }
        
        function createReactionUI(gameAreaContent, roomData, isPlayer1) {
            const gameState = roomData.gameState;
            const zoneColor = gameState.currentState === 'go' ? 'bg-green-500' : 
                            gameState.currentState === 'early' ? 'bg-red-500' : 'bg-overlay';
            
            gameAreaContent.innerHTML = `
                <div class="w-full max-w-2xl">
                    <div class="text-center mb-6">
                        <h3 class="text-2xl font-bold text-text mb-2">Reaction Test</h3>
                        <div id="reaction-round" class="text-muted">Round ${gameState.round} of ${gameState.maxRounds}</div>
                    </div>
                    
                    <div class="flex justify-between mb-6">
                        <div class="text-center">
                            <div class="text-foam font-bold text-lg">${roomData.hostName}</div>
                            <div id="reaction-p1-score" class="text-2xl font-bold text-text">${gameState.player1Score || 0}</div>
                            <div id="reaction-p1-time" class="text-xs text-muted">${gameState.player1Time && gameState.player1Time > 0 ? gameState.player1Time + 'ms' : gameState.player1Time === -1 ? 'Too Early!' : ''}</div>
                        </div>
                        <div class="text-center">
                            <div class="text-iris font-bold text-lg">${roomData.guestName}</div>
                            <div id="reaction-p2-score" class="text-2xl font-bold text-text">${gameState.player2Score || 0}</div>
                            <div id="reaction-p2-time" class="text-xs text-muted">${gameState.player2Time && gameState.player2Time > 0 ? gameState.player2Time + 'ms' : gameState.player2Time === -1 ? 'Too Early!' : ''}</div>
                        </div>
                    </div>
                    
                    <div id="reaction-zone" class="reaction-zone w-full h-64 ${zoneColor} rounded-lg flex items-center justify-center cursor-pointer mb-4 transition-colors duration-300 border-2 border-highlight-med">
                        <div id="reaction-text" class="text-xl font-bold text-white text-center">
                            ${getReactionText(gameState.currentState, gameState, roomData)}
                        </div>
                    </div>
                    
                    <div id="reaction-status" class="text-center text-muted">
                        ${roomData.status === 'completed' ? 
                            `🎉 ${(gameState.player1Score || 0) > (gameState.player2Score || 0) ? roomData.hostName : roomData.guestName} wins ${Math.max(gameState.player1Score || 0, gameState.player2Score || 0)}-${Math.min(gameState.player1Score || 0, gameState.player2Score || 0)}!` :
                            'Click or tap the area above when it turns green!'
                        }
                    </div>
                </div>
            `;
        }

        function getReactionText(state, gameState, roomData = null) {
            // Use roomData for player names if available, fallback to generic names
            const hostName = roomData?.hostName || currentGameData?.hostName || 'Player 1';
            const guestName = roomData?.guestName || currentGameData?.guestName || 'Player 2';
            
            switch (state) {
                case 'waiting': return 'Get Ready...';
                case 'go': return 'TAP NOW!';
                case 'early': return 'Too Early! Wait for green.';
                case 'results': 
                    if (gameState.player1Time && gameState.player2Time) {
                        if (gameState.player1Time === -1 && gameState.player2Time === -1) return 'Both too early!';
                        if (gameState.player1Time === -1) return `${guestName} wins round!`;
                        if (gameState.player2Time === -1) return `${hostName} wins round!`;
                        const winner = gameState.player1Time < gameState.player2Time ? hostName : guestName;
                        return `${winner} wins round!`;
                    }
                    return 'Waiting for results...';
                default: return 'Get Ready...';
            }
        }

        function handleReactionClick(roomId, isPlayer1) {
            // Enhanced validation and debouncing
            if (!currentGameData || !currentGameData.gameState || !roomId) {
                console.warn('Invalid game state for reaction click:', { currentGameData, roomId });
                return;
            }
            
            const gameState = currentGameData.gameState;
            const now = Date.now();
            
            // Prevent double clicks and ensure game is active
            if (currentGameData.status !== 'playing') {
                console.warn('Game not in playing state:', currentGameData.status);
                return;
            }
            
            // Check if this player has already responded this round
            const playerTimeKey = isPlayer1 ? 'player1Time' : 'player2Time';
            if (gameState[playerTimeKey] !== null && gameState[playerTimeKey] !== undefined) {
                console.warn('Player already responded this round');
                return;
            }
            
            // Add debouncing to prevent rapid clicks
            const clickKey = `lastClick_${isPlayer1 ? 'p1' : 'p2'}`;
            if (window[clickKey] && now - window[clickKey] < 100) {
                console.warn('Click too rapid, ignoring');
                return;
            }
            window[clickKey] = now;
            
            if (gameState.currentState === 'waiting') {
                // Too early penalty
                console.log('Player clicked too early');
                const updateData = {};
                updateData[playerTimeKey] = -1;
                updateData['currentState'] = 'early';
                
                realtimeDb.ref(`game-rooms/${roomId}/gameState`).update(updateData).catch(error => {
                    console.error('Failed to update early click:', error);
                    showNotification('Error', 'Failed to register click', 'error');
                });
                
                // Update room activity
                realtimeDb.ref(`game-rooms/${roomId}`).update({
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                }).catch(console.error);
                
            } else if (gameState.currentState === 'go' && gameState.changeTime) {
                // Valid reaction - calculate time
                const reactionTime = Math.max(1, now - gameState.changeTime); // Minimum 1ms to prevent 0ms cheating
                
                console.log(`Player ${isPlayer1 ? 1 : 2} reaction time:`, reactionTime + 'ms');
                
                const updateData = {};
                updateData[playerTimeKey] = reactionTime;
                
                realtimeDb.ref(`game-rooms/${roomId}/gameState`).update(updateData).catch(error => {
                    console.error('Failed to update reaction time:', error);
                    showNotification('Error', 'Failed to register reaction time', 'error');
                });
                
                // Update room activity
                realtimeDb.ref(`game-rooms/${roomId}`).update({
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                }).catch(console.error);
                
            } else {
                console.warn('Invalid game state for click:', gameState.currentState);
            }
        }

        function handleReactionFlow(roomId, gameState) {
            // Enhanced validation and state management
            if (!roomId || !gameState || !currentGameData) {
                console.error('Invalid parameters for reaction flow:', { roomId, gameState, currentGameData });
                return;
            }
            
            // Only host should control the reaction flow to prevent conflicts
            const isHost = currentGameData.hostId === currentUser.uid;
            if (!isHost) {
                console.log('Guest player - skipping reaction flow control');
                return;
            }
            
            // Ensure game is still active
            if (currentGameData.status !== 'playing') {
                console.log('Game no longer active, stopping reaction flow');
                if (reactionTimeout) {
                    clearTimeout(reactionTimeout);
                    reactionTimeout = null;
                }
                return;
            }
            
            console.log('Reaction flow state:', gameState.currentState, 'Round:', gameState.round);
            
            if (gameState.currentState === 'waiting' && 
                (gameState.player1Time === null || gameState.player1Time === undefined) && 
                (gameState.player2Time === null || gameState.player2Time === undefined)) {
                
                // Start countdown for next round
                console.log('Starting reaction timer for round', gameState.round);
                
                // Clear any existing timeout to prevent race conditions
                if (reactionTimeout) {
                    clearTimeout(reactionTimeout);
                    reactionTimeout = null;
                }
                
                const delay = Math.random() * 3000 + 2000; // 2-5 seconds random delay
                console.log('Reaction delay set to:', delay + 'ms');
                
                reactionTimeout = setTimeout(() => {
                    // Double-check game is still active before updating
                    if (currentGameData && currentGameData.status === 'playing') {
                        console.log('Triggering GO state for reaction game');
                        realtimeDb.ref(`game-rooms/${roomId}/gameState`).update({
                            'currentState': 'go',
                            'changeTime': Date.now()
                        }).catch(error => {
                            console.error('Failed to update game state to GO:', error);
                            showNotification('Error', 'Game state update failed', 'error');
                        });
                    } else {
                        console.log('Game no longer active, skipping GO state');
                    }
                    reactionTimeout = null;
                }, delay);
                
            } else if (gameState.currentState === 'early') {
                // Handle early click state - wait before processing
                console.log('Handling early click state');
                setTimeout(() => {
                    if (currentGameData && currentGameData.status === 'playing') {
                        processReactionRound(roomId, gameState);
                    }
                }, 1500);
                
            } else if (gameState.currentState === 'go' || gameState.currentState === 'results' || 
                     (gameState.player1Time !== null && gameState.player2Time !== null)) {
                
                // Both players have responded OR we're in results state, process results
                console.log('Processing reaction results - both players responded');
                
                // Clear any pending timeout since round is complete
                if (reactionTimeout) {
                    clearTimeout(reactionTimeout);
                    reactionTimeout = null;
                }
                
                setTimeout(() => {
                    if (currentGameData && currentGameData.status === 'playing') {
                        processReactionRound(roomId, gameState);
                    }
                }, 1500); // Give time for UI updates
            }
        }

        async function processReactionRound(roomId, gameState) {
            try {
                // Enhanced validation and safety checks
                if (!roomId || !gameState || !currentGameData) {
                    console.error('Invalid parameters for processing reaction round');
                    return;
                }
                
                // Only host should process rounds to prevent conflicts
                const isHost = currentGameData.hostId === currentUser.uid;
                if (!isHost) {
                    console.log('Guest player - skipping round processing');
                    return;
                }
                
                // Ensure game is still active
                if (currentGameData.status !== 'playing') {
                    console.log('Game no longer active - stopping round processing');
                    return;
                }
                
                console.log('Processing reaction round:', gameState.round, 'Times:', gameState.player1Time, gameState.player2Time);
                
                let player1Won = false;
                let player2Won = false;
                
                // Enhanced winner determination logic
                const p1Time = gameState.player1Time;
                const p2Time = gameState.player2Time;
                
                // Validate times exist
                if (p1Time === null || p1Time === undefined || p2Time === null || p2Time === undefined) {
                    console.log('Waiting for both players to respond...');
                    return; // Don't process until both players respond
                }
                
                // Determine round winner with enhanced logic
                if (p1Time === -1 && p2Time === -1) {
                    // Both too early, no one wins
                    console.log('Both players clicked too early - no winner');
                } else if (p1Time === -1 && p2Time > 0) {
                    // Player 1 too early, Player 2 wins
                    player2Won = true;
                    console.log('Player 1 too early, Player 2 wins');
                } else if (p2Time === -1 && p1Time > 0) {
                    // Player 2 too early, Player 1 wins
                    player1Won = true;
                    console.log('Player 2 too early, Player 1 wins');
                } else if (p1Time > 0 && p2Time > 0) {
                    // Both valid times - faster time wins
                    if (p1Time < p2Time) {
                        player1Won = true;
                        console.log(`Player 1 wins with ${p1Time}ms vs ${p2Time}ms`);
                    } else if (p2Time < p1Time) {
                        player2Won = true;
                        console.log(`Player 2 wins with ${p2Time}ms vs ${p1Time}ms`);
                    } else {
                        // Extremely rare tie case
                        console.log('Exact tie - no winner');
                    }
                } else {
                    console.warn('Unexpected time values:', { p1Time, p2Time });
                }
                
                // Calculate new scores with bounds checking
                const currentScore1 = Math.max(0, gameState.player1Score || 0);
                const currentScore2 = Math.max(0, gameState.player2Score || 0);
                const newScore1 = currentScore1 + (player1Won ? 1 : 0);
                const newScore2 = currentScore2 + (player2Won ? 1 : 0);
                const newRound = (gameState.round || 1) + 1;
                const maxRounds = gameState.maxRounds || 5;
                
                console.log('Score update:', { currentScore1, currentScore2, newScore1, newScore2, newRound, maxRounds });
                
                // Prepare game state update
                const gameStateUpdateData = {
                    'player1Score': newScore1,
                    'player2Score': newScore2,
                    'round': newRound,
                    'player1Time': null,
                    'player2Time': null,
                    'currentState': newRound > maxRounds ? 'completed' : 'waiting',
                    'changeTime': null // Reset change time
                };
                
                // Update game state
                await realtimeDb.ref(`game-rooms/${roomId}/gameState`).update(gameStateUpdateData);
                
                // Check if game is complete
                if (newRound > maxRounds) {
                    console.log('Game completed! Final scores:', newScore1, newScore2);
                    
                    // Determine overall winner
                    let overallWinner = 'tie';
                    let winnerName = 'Tie Game';
                    
                    if (newScore1 > newScore2) {
                        overallWinner = 'player1';
                        winnerName = currentGameData.hostName || 'Player 1';
                    } else if (newScore2 > newScore1) {
                        overallWinner = 'player2';
                        winnerName = currentGameData.guestName || 'Player 2';
                    }
                    
                    // Update room status to completed
                    await realtimeDb.ref(`game-rooms/${roomId}`).update({
                        status: 'completed',
                        winner: overallWinner,
                        winnerName: winnerName,
                        finalScore1: newScore1,
                        finalScore2: newScore2,
                        completedAt: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    console.log('✅ Reaction game completed:', winnerName, 'wins!');
                }
                
            } catch (error) {
                console.error('Error processing reaction round:', error);
                showNotification('Error', 'Failed to process round results', 'error');
                
                // Try to reset round state on error
                try {
                    await realtimeDb.ref(`game-rooms/${roomId}/gameState`).update({
                        'player1Time': null,
                        'player2Time': null,
                        'currentState': 'waiting'
                    });
                } catch (resetError) {
                    console.error('Failed to reset round state:', resetError);
                }
            }
        }

        // Racing Game Implementation
        async function setupRacingListeners(roomId) {
            const gameStateRef = realtimeDb.ref(`game-rooms/${roomId}/gameState`);
            gameStateRef.on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    if (currentGameData) {
                        currentGameData.gameState = gameState;
                        if (window.updateRacingScores) {
                            window.updateRacingScores(currentGameData);
                        }
                    }
                }
            });
        }
        
        function startRacingGame(roomData, roomId) {
            currentGameData = roomData;
            const isPlayer1 = roomData.hostId === currentUser.uid;
            
            const gameAreaContent = document.getElementById('game-area-content');
            if (!gameAreaContent) return;
            
            const gameState = currentGameData.gameState;
            
            // Validate game state
            if (!gameState || !gameState.player1 || !gameState.player2) {
                console.error('Invalid racing game state:', gameState);
                gameAreaContent.innerHTML = `
                    <div class="text-center text-love">
                        <h3 class="text-xl font-bold mb-4">Game Error</h3>
                        <p>Invalid racing game state. Please try again.</p>
                    </div>
                `;
                return;
            }
            
            // Create UI once
            gameAreaContent.innerHTML = `
                <div class="w-full max-w-4xl">
                    <div class="flex justify-between items-center mb-4">
                        <div class="text-text">
                            <span class="text-foam font-bold">${currentGameData.hostName}</span>
                            <span id="racing-p1-laps" class="ml-2">Laps: ${gameState.player1.laps || 0}/${gameState.maxLaps}</span>
                        </div>
                        <div class="text-xl font-bold text-text">Mini Racing</div>
                        <div class="text-text">
                            <span id="racing-p2-laps" class="mr-2">Laps: ${gameState.player2.laps || 0}/${gameState.maxLaps}</span>
                            <span class="text-iris font-bold">${currentGameData.guestName}</span>
                        </div>
                    </div>
                    <div class="bg-surface border border-highlight-med rounded-xl p-4">
                        <canvas id="racing-canvas" class="mx-auto border border-highlight-med rounded-lg" width="800" height="400" style="max-width: 100%; height: auto; background-color: #1f1d2e;"></canvas>
                    </div>
                    <div id="racing-status" class="text-center mt-4 text-muted">
                        ${currentGameData.status === 'completed' ? 
                            `🏆 ${(gameState.player1.laps || 0) >= gameState.maxLaps ? currentGameData.hostName : currentGameData.guestName} wins the race!` :
                            '🏎️ Use arrow keys or touch to steer and avoid 📦 crates • First to 3 laps wins 🏁'
                        }
                    </div>
                </div>
            `;
            
            // Initialize racing game once
            if (currentGameData.status !== 'completed') {
                setTimeout(() => initRacingGame(roomId, isPlayer1), 100);
            }
            
            // Update function that only updates lap counts
            window.updateRacingScores = function(newRoomData) {
                const newGameState = newRoomData.gameState;
                const p1Laps = document.getElementById('racing-p1-laps');
                const p2Laps = document.getElementById('racing-p2-laps');
                const status = document.getElementById('racing-status');
                
                if (p1Laps) p1Laps.textContent = `Laps: ${newGameState.player1.laps || 0}/${newGameState.maxLaps}`;
                if (p2Laps) p2Laps.textContent = `Laps: ${newGameState.player2.laps || 0}/${newGameState.maxLaps}`;
                
                if (status) {
                    if (newRoomData.status === 'completed') {
                        status.textContent = `🏆 ${(newGameState.player1.laps || 0) >= newGameState.maxLaps ? newRoomData.hostName : newRoomData.guestName} wins the race!`;
                    } else {
                        status.textContent = '🏎️ Use arrow keys or touch to steer and avoid 📦 crates • First to 3 laps wins 🏁';
                    }
                }
            };
        }

        function initRacingGame(roomId, isPlayer1) {
            const canvas = document.getElementById('racing-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Key event listeners
            const handleKeyDown = (e) => {
                switch (e.key) {
                    case 'ArrowLeft': racingKeys.left = true; e.preventDefault(); break;
                    case 'ArrowRight': racingKeys.right = true; e.preventDefault(); break;
                    case 'ArrowUp': racingKeys.up = true; e.preventDefault(); break;
                    case 'ArrowDown': racingKeys.down = true; e.preventDefault(); break;
                }
            };
            
            const handleKeyUp = (e) => {
                switch (e.key) {
                    case 'ArrowLeft': racingKeys.left = false; e.preventDefault(); break;
                    case 'ArrowRight': racingKeys.right = false; e.preventDefault(); break;
                    case 'ArrowUp': racingKeys.up = false; e.preventDefault(); break;
                    case 'ArrowDown': racingKeys.down = false; e.preventDefault(); break;
                }
            };
            
            // Touch controls for mobile
            let touchControlActive = false;
            let initialTouchPosition = null;
            
            const handleTouchStart = (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    touchControlActive = true;
                    const rect = canvas.getBoundingClientRect();
                    initialTouchPosition = {
                        x: e.touches[0].clientX - rect.left,
                        y: e.touches[0].clientY - rect.top
                    };
                }
            };
            
            const handleTouchMove = (e) => {
                e.preventDefault();
                if (!touchControlActive || !initialTouchPosition || e.touches.length === 0) return;
                
                const rect = canvas.getBoundingClientRect();
                const currentTouch = {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
                
                const deltaX = currentTouch.x - initialTouchPosition.x;
                const deltaY = currentTouch.y - initialTouchPosition.y;
                
                // Minimum movement threshold to avoid jitter
                const threshold = 20;
                
                // Reset all racing keys
                racingKeys.left = false;
                racingKeys.right = false;
                racingKeys.up = false;
                racingKeys.down = false;
                
                // Horizontal movement
                if (Math.abs(deltaX) > threshold) {
                    if (deltaX > 0) {
                        racingKeys.right = true;
                    } else {
                        racingKeys.left = true;
                    }
                }
                
                // Vertical movement
                if (Math.abs(deltaY) > threshold) {
                    if (deltaY > 0) {
                        racingKeys.down = true;
                    } else {
                        racingKeys.up = true;
                    }
                }
            };
            
            const handleTouchEnd = (e) => {
                e.preventDefault();
                touchControlActive = false;
                initialTouchPosition = null;
                
                // Reset all keys when touch ends
                racingKeys.left = false;
                racingKeys.right = false;
                racingKeys.up = false;
                racingKeys.down = false;
            };
            
            // Add keyboard events
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Add touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);
            
            // Prevent context menu on long press
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // Store event listeners for cleanup
            canvas.keyHandlers = { handleKeyDown, handleKeyUp };
            
            // Update loop - 30 FPS for better network performance
            if (racingUpdateInterval) clearInterval(racingUpdateInterval);
            racingUpdateInterval = setInterval(() => {
                updateRacingGame(roomId, isPlayer1);
            }, 33.33); // ~30 FPS
            
            // Render loop
            function render() {
                if (!currentGameData || !canvas.parentElement) {
                    // Cleanup
                    if (racingUpdateInterval) {
                        clearInterval(racingUpdateInterval);
                        racingUpdateInterval = null;
                    }
                    if (canvas.keyHandlers) {
                        document.removeEventListener('keydown', canvas.keyHandlers.handleKeyDown);
                        document.removeEventListener('keyup', canvas.keyHandlers.handleKeyUp);
                    }
                    return;
                }
                
                renderRacingGame(ctx, currentGameData);
                
                if (currentGameData.status !== 'completed') {
                    requestAnimationFrame(render);
                } else {
                    // Game completed, stop update loop
                    if (racingUpdateInterval) {
                        clearInterval(racingUpdateInterval);
                        racingUpdateInterval = null;
                    }
                }
            }
            
            render();
        }

        function updateRacingGame(roomId, isPlayer1) {
            if (!currentGameData || currentGameData.status === 'completed') return;
            
            try {
                const gameState = currentGameData.gameState;
                const player = isPlayer1 ? { ...gameState.player1 } : { ...gameState.player2 };
                const speed = 3;
                
                // Update player position based on keys
                if (racingKeys.left) player.x = Math.max(25, player.x - speed);
                if (racingKeys.right) player.x = Math.min(755, player.x + speed);
                if (racingKeys.up) player.y = Math.max(25, player.y - speed);
                if (racingKeys.down) player.y = Math.min(355, player.y + speed);
                
                // Check lap completion - must pass through finish line area
                if (player.x >= 730 && player.x <= 770 && player.y >= 20 && player.y <= 80) {
                    if (!player.finishLineCrossed) {
                        player.laps++;
                        player.finishLineCrossed = true;
                        
                        // Reset position for next lap
                        if (player.laps < gameState.maxLaps) {
                            player.x = 50;
                            player.y = isPlayer1 ? 200 : 250;
                        }
                    }
                } else if (player.x < 700) {
                    // Reset finish line flag when away from finish line
                    player.finishLineCrossed = false;
                }
                
                // Check collision with obstacles (emoji cars vs emoji crates)
                let collided = false;
                for (const obstacle of gameState.obstacles) {
                    const carSize = 20; // Size of emoji car
                    const crateSize = 18; // Size of emoji crate
                    if (player.x < obstacle.x + crateSize &&
                        player.x + carSize > obstacle.x &&
                        player.y < obstacle.y + crateSize &&
                        player.y + carSize > obstacle.y) {
                        collided = true;
                        break;
                    }
                }
                
                if (collided) {
                    // Collision - move player back slightly
                    player.x = Math.max(25, player.x - 10);
                    player.y = Math.max(25, player.y - 10);
                }
                
                // Update Firebase with throttling - optimized for better network performance
                if (!updateRacingGame.lastUpdate || Date.now() - updateRacingGame.lastUpdate > 100) {
                    const gameStateUpdateData = {};
                    gameStateUpdateData[`${isPlayer1 ? 'player1' : 'player2'}`] = player;
                    
                    // Update game state in realtime database
                    realtimeDb.ref(`game-rooms/${roomId}/gameState`).update(gameStateUpdateData).catch(console.error);
                    
                    // Update room activity
                    realtimeDb.ref(`game-rooms/${roomId}`).update({
                        lastActivity: firebase.database.ServerValue.TIMESTAMP
                    }).catch(console.error);
                    
                    // Check for winner
                    if (player.laps >= gameState.maxLaps) {
                        realtimeDb.ref(`game-rooms/${roomId}`).update({
                            status: 'completed',
                            winner: isPlayer1 ? 'player1' : 'player2'
                        }).catch(console.error);
                    }
                    
                    updateRacingGame.lastUpdate = Date.now();
                }
                
            } catch (error) {
                console.error('Error updating racing game:', error);
            }
        }

        function renderRacingGame(ctx, roomData) {
            const gameState = roomData.gameState;
            
            // Clear canvas
            ctx.fillStyle = '#1f1d2e';
            ctx.fillRect(0, 0, 800, 400);
            
            // Draw outer track boundary (grass texture)
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, 800, 400);
            
            // Draw track surface
            ctx.fillStyle = '#404040';
            ctx.fillRect(20, 20, 760, 360);
            
            // Draw track stripes
            ctx.fillStyle = '#606060';
            for (let i = 0; i < 800; i += 40) {
                ctx.fillRect(i, 200, 20, 4);
            }
            
            // Draw inner track boundary  
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(100, 100, 600, 200);
            
            // Draw finish line with checkered pattern
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(740, 20, 20, 60);
            ctx.fillStyle = '#000000';
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 2; j++) {
                    if ((i + j) % 2 === 0) {
                        ctx.fillRect(740 + j * 10, 20 + i * 10, 10, 10);
                    }
                }
            }
            
            // Draw start positions
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(25, 185, 35, 8); // Player 1 start line
            ctx.fillRect(25, 235, 35, 8); // Player 2 start line
            
            // Draw track direction arrows
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 24px Arial';
            ctx.fillText('→', 300, 50);
            ctx.fillText('↓', 760, 200);
            ctx.fillText('←', 400, 370);
            ctx.fillText('↑', 40, 200);
            
            // Draw obstacles as crates 📦
            ctx.font = '18px Arial';
            for (const obstacle of gameState.obstacles) {
                ctx.fillText('📦', obstacle.x, obstacle.y + 18);
            }
            
            // Draw players as cars 🏎️
            const player1 = gameState.player1;
            const player2 = gameState.player2;
            
            // Player 1 car (blue car)
            ctx.font = '24px Arial';
            ctx.fillText('🏎️', player1.x - 2, player1.y + 18);
            
            // Player 2 car (red car) 
            ctx.fillText('🚗', player2.x - 2, player2.y + 18);
            
            // Draw lap progress
            ctx.fillStyle = '#e0def4';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`🏎️ ${roomData.hostName}: ${player1.laps}/${gameState.maxLaps} laps`, 30, 390);
            ctx.fillText(`🚗 ${roomData.guestName}: ${player2.laps}/${gameState.maxLaps} laps`, 300, 390);
            
            // Draw winner overlay
            if (roomData.status === 'completed') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, 800, 400);
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                const winner = player1.laps >= gameState.maxLaps ? roomData.hostName : roomData.guestName;
                const winnerCar = player1.laps >= gameState.maxLaps ? '🏎️' : '🚗';
                ctx.fillText(`${winnerCar} ${winner} Wins! 🏆`, 400, 180);
                ctx.font = '32px Arial';
                ctx.fillText('🏁 Race Complete! 🏁', 400, 240);
                ctx.textAlign = 'start';
            }
        }

        // Winner Screen
        function showWinnerScreen(roomData) {
            if (winnerScreenShown || document.getElementById('winnerModal')) return;
            
            winnerScreenShown = true;
            
            // Determine if current user won
            const didIWin = (
                (roomData.winner === 'player1' && roomData.hostId === currentUser.uid) ||
                (roomData.winner === 'player2' && roomData.guestId === currentUser.uid)
            );
            
            // Handle disconnection cases - if there's a disconnected player, the other player wins
            if (roomData.disconnectedPlayer) {
                const amIDisconnected = roomData.disconnectedPlayer === currentUser.uid;
                // If I disconnected, I lost. If someone else disconnected, I won.
                const actualDidIWin = !amIDisconnected;
                
                // Override the win status for disconnection cases
                if (actualDidIWin !== didIWin) {
                    console.log('🔄 Correcting winner status due to disconnection');
                }
                const finalDidIWin = actualDidIWin;
                
                showWinnerModal(roomData, finalDidIWin, true);
            } else {
                // Normal game completion
                showWinnerModal(roomData, didIWin, false);
            }
        }

        function showWinnerModal(roomData, didIWin, wasDisconnection) {
            const isDraw = roomData.winner === 'draw' || roomData.winner === 'tie';
            const gameTitle = getGameDisplayName(roomData.gameType);
            
            const winnerModal = document.createElement('div');
            winnerModal.id = 'winnerModal';
            winnerModal.className = 'fixed inset-0 bg-black/90 backdrop-blur-md flex items-center justify-center z-[10000]';
            
            let titleText, titleColor, bgGradient, icon, subtitleText;
            
            if (isDraw) {
                titleText = "It's a Draw!";
                titleColor = 'text-gold';
                bgGradient = 'from-gold/20 to-gold/10';
                icon = 'bx-medal';
                subtitleText = 'Great game!';
            } else if (didIWin) {
                titleText = wasDisconnection ? "You Won!" : "You Won!";
                titleColor = 'text-foam';
                bgGradient = 'from-foam/20 to-foam/10';
                icon = 'bx-trophy';
                subtitleText = wasDisconnection ? 'Opponent left the game' : 'Congratulations!';
            } else {
                titleText = wasDisconnection ? "Game Ended" : "You Lost";
                titleColor = 'text-love';
                bgGradient = 'from-love/20 to-love/10';
                icon = wasDisconnection ? 'bx-exit' : 'bx-sad';
                subtitleText = wasDisconnection ? 'You left the game' : 'Better luck next time!';
            }
            
            // Get winner and loser names for display
            let winnerName = '';
            let loserName = '';
            
            if (!isDraw) {
                if (roomData.disconnectedPlayer) {
                    const disconnectedName = roomData.disconnectedPlayerName || 
                        (roomData.disconnectedPlayer === roomData.hostId ? roomData.hostName : roomData.guestName);
                    const remainingName = roomData.winnerName || 
                        (roomData.winner === 'player1' ? roomData.hostName : roomData.guestName);
                    
                    winnerName = remainingName;
                    loserName = disconnectedName;
                } else {
                    winnerName = roomData.winner === 'player1' ? roomData.hostName : roomData.guestName;
                    loserName = roomData.winner === 'player1' ? roomData.guestName : roomData.hostName;
                }
            }
            
            winnerModal.innerHTML = `
                <div class="bg-surface border border-highlight-med rounded-2xl shadow-2xl max-w-md w-[90vw] mx-4 overflow-hidden">
                    <div class="bg-gradient-to-br ${bgGradient} p-8 text-center relative">
                        ${didIWin && !wasDisconnection ? `
                            <div class="absolute inset-0 overflow-hidden">
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                                <div class="confetti"></div>
                            </div>
                        ` : ''}
                        
                        <div class="relative z-10">
                            <div class="w-20 h-20 mx-auto mb-4 ${isDraw ? 'bg-gold/20' : didIWin ? 'bg-foam/20' : 'bg-love/20'} rounded-full flex items-center justify-center animate-bounce">
                                <i class="bx ${icon} text-4xl ${titleColor}"></i>
                            </div>
                            
                            <h2 class="text-3xl font-bold ${titleColor} mb-2">${titleText}</h2>
                            <p class="text-muted text-lg">${gameTitle} Complete</p>
                            <p class="text-muted text-sm mt-1">${subtitleText}</p>
                            
                            ${!isDraw && winnerName ? `
                                <div class="mt-4 flex items-center justify-center gap-4">
                                    <div class="text-center">
                                        <div class="text-sm text-muted">Winner</div>
                                        <div class="text-foam font-bold">${winnerName}</div>
                                    </div>
                                    ${!wasDisconnection ? `
                                        <div class="text-muted">vs</div>
                                        <div class="text-center">
                                            <div class="text-sm text-muted">Runner-up</div>
                                            <div class="text-love font-bold">${loserName}</div>
                                        </div>
                                    ` : ''}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    
                    <div class="p-6 space-y-3">
                        <button onclick="startNewGame('${roomData.gameType}')" 
                                class="w-full px-4 py-3 bg-foam hover:bg-foam/80 text-base rounded-lg transition-colors font-semibold">
                            <i class="bx bx-refresh mr-2"></i>Play Again
                        </button>
                        
                        <button onclick="closeWinnerScreen()" 
                                class="w-full px-4 py-3 bg-highlight-med hover:bg-highlight-high text-text rounded-lg transition-colors font-semibold">
                            <i class="bx bx-home mr-2"></i>Back to Games
                        </button>
                    </div>
                </div>
                
                <style>
                    .confetti {
                        position: absolute;
                        width: 10px;
                        height: 10px;
                        background: linear-gradient(45deg, #9ccfd8, #c4a7e7, #eb6f92, #f6c177);
                        animation: confetti-fall 3s linear infinite;
                    }
                    
                    .confetti:nth-child(1) { left: 10%; animation-delay: 0s; }
                    .confetti:nth-child(2) { left: 20%; animation-delay: 0.2s; }
                    .confetti:nth-child(3) { left: 30%; animation-delay: 0.4s; }
                    .confetti:nth-child(4) { left: 40%; animation-delay: 0.6s; }
                    .confetti:nth-child(5) { left: 60%; animation-delay: 0.8s; }
                    .confetti:nth-child(6) { left: 70%; animation-delay: 1s; }
                    .confetti:nth-child(7) { left: 80%; animation-delay: 1.2s; }
                    .confetti:nth-child(8) { left: 90%; animation-delay: 1.4s; }
                    
                    @keyframes confetti-fall {
                        0% {
                            transform: translateY(-100vh) rotate(0deg);
                            opacity: 1;
                        }
                        100% {
                            transform: translateY(100vh) rotate(720deg);
                            opacity: 0;
                        }
                    }
                </style>
            `;
            
            document.body.appendChild(winnerModal);
        }

        window.startNewGame = function(gameType) {
            closeWinnerScreen();
            setTimeout(() => {
                winnerScreenShown = false;
                createGameRoom(gameType);
            }, 500);
        };

        window.closeWinnerScreen = function() {
            const winnerModal = document.getElementById('winnerModal');
            if (winnerModal) {
                winnerModal.remove();
            }
            winnerScreenShown = false;
            backToSelection();
        };

        // Prevent multiple simultaneous leave operations
        let leavingInProgress = false;
        
        async function leaveRoom() {
            console.log('🚪 Player leaving room:', currentRoom);
            
            // Prevent race conditions with multiple leave calls
            if (leavingInProgress) {
                console.log('Leave already in progress, skipping...');
                return;
            }
            
            leavingInProgress = true;
            winnerScreenShown = false;
            
            try {
                // Clean up disconnect handlers first to prevent conflicts
                await cleanupDisconnectHandlers();
                
                // Clean up game listeners
                if (gameListener && typeof gameListener === 'function') {
                    gameListener();
                    gameListener = null;
                }
                
                if (currentRoom) {
                    try {
                        // Handle ping pong room
                        if (pongRoomRef) {
                            await leavePongRoom();
                        }
                        // Handle regular game room (all games now use realtime database)
                        else {
                            await leaveRegularRoom();
                        }
                    } catch (error) {
                        console.error('❌ Error leaving room:', error);
                        // Continue with cleanup even if leaving fails
                    }
                    
                    currentRoom = null;
                }
                
                // Additional cleanup to prevent memory leaks
                cleanupAllGameResources();
                
            } finally {
                leavingInProgress = false;
                backToSelection();
            }
        }

        function cleanupAllGameResources() {
            // Clean up all possible game intervals and timeouts
            if (pongInterval) {
                clearInterval(pongInterval);
                pongInterval = null;
            }
            
            if (guestPhysicsInterval) {
                clearInterval(guestPhysicsInterval);
                guestPhysicsInterval = null;
            }
            
            if (racingUpdateInterval) {
                clearInterval(racingUpdateInterval);
                racingUpdateInterval = null;
            }
            
            if (reactionTimeout) {
                clearTimeout(reactionTimeout);
                reactionTimeout = null;
            }
            
            // Clean up pong-specific resources
            if (pongRoomRef) {
                pongRoomRef.off();
                pongRoomRef = null;
            }
            if (pongPhysicsRef) {
                pongPhysicsRef.off();
                pongPhysicsRef = null;
            }
            if (pongPlayersRef) {
                pongPlayersRef.off();
                pongPlayersRef = null;
            }
            if (connectionRef) {
                connectionRef.off();
                connectionRef = null;
            }
            
            // Reset game state variables
            currentGameData = null;
            isHost = false;
            guestBallPrediction = null;
            lastServerBallUpdate = 0;
            currentServerBall = null;
            currentServerGameState = null;
            lastPaddleUpdate = 0;
            guestPredictedBall = null;
            lastServerSync = 0;
            
            console.log('🧹 All game resources cleaned up');
        }

        async function leavePongRoom() {
            // Check if user and database are available
            if (!currentUser || !realtimeDb || !currentRoom) {
                console.warn('Cannot leave pong room: missing user, database, or room');
                return;
            }
            
            try {
                const roomSnapshot = await realtimeDb.ref(`pong-rooms/${currentRoom}`).once('value');
                if (roomSnapshot && roomSnapshot.exists()) {
                    const roomData = roomSnapshot.val();
                    const isHostPlayer = roomData.hostId === currentUser.uid;
                    
                    console.log('🚪 Leaving pong room, status:', roomData.status, 'Is host:', isHostPlayer);
                    
                    if (isHostPlayer && roomData.status === 'waiting') {
                        // Host leaves before game starts - delete room
                        console.log('🗑️ Host deleting pong room');
                        await Promise.all([
                            realtimeDb.ref(`pong-rooms/${currentRoom}`).remove(),
                            realtimeDb.ref(`pong-physics/${currentRoom}`).remove(),
                            realtimeDb.ref(`pong-players/${currentRoom}`).remove()
                        ]);
                    } else if (roomData.status === 'playing' || roomData.status === 'waiting') {
                        // Player leaves during game - mark as completed with remaining player as winner
                        const updateData = {
                            status: 'completed',
                            winner: isHostPlayer ? 'player2' : 'player1',
                            winnerName: isHostPlayer ? roomData.guestName : roomData.hostName,
                            disconnectedPlayer: currentUser.uid,
                            disconnectedPlayerName: isHostPlayer ? roomData.hostName : roomData.guestName,
                            disconnectedAt: firebase.database.ServerValue.TIMESTAMP
                        };
                        
                        console.log('🏆 Pong game ended due to disconnect, winner:', updateData.winnerName, '(remaining player)');
                        await realtimeDb.ref(`pong-rooms/${currentRoom}`).update(updateData);
                    }
                }
                
                // Clean up listeners
                cleanupPongRoom();
            } catch (error) {
                console.error('Error leaving pong room:', error);
            }
        }

        async function leaveRegularRoom() {
            // Check if user and database are available
            if (!currentUser || !realtimeDb || !currentRoom) {
                console.warn('Cannot leave regular room: missing user, database, or room');
                return;
            }
            
            try {
                const roomSnapshot = await realtimeDb.ref(`game-rooms/${currentRoom}`).once('value');
                if (roomSnapshot && roomSnapshot.exists()) {
                    const roomData = roomSnapshot.val();
                    const isHost = roomData.hostId === currentUser.uid;
                    
                    console.log('🚪 Room status:', roomData.status, 'Is host:', isHost);
                    
                    if (isHost && roomData.status === 'waiting') {
                        // Host leaves before game starts - delete room
                        console.log('🗑️ Host deleting room');
                        await realtimeDb.ref(`game-rooms/${currentRoom}`).remove();
                    } else if (roomData.status === 'playing' || roomData.status === 'waiting') {
                        // Player leaves during game or waiting - mark as disconnected
                        const updateData = {
                            status: 'completed',
                            disconnectedPlayer: currentUser.uid,
                            disconnectedPlayerName: isHost ? roomData.hostName : roomData.guestName,
                            disconnectedAt: firebase.database.ServerValue.TIMESTAMP,
                            lastActivity: firebase.database.ServerValue.TIMESTAMP
                        };
                        
                        // Determine winner: the remaining player (NOT the one who left)
                        if (roomData.status === 'playing' && roomData.guestId) {
                            updateData.winner = isHost ? 'player2' : 'player1';
                            updateData.winnerName = isHost ? roomData.guestName : roomData.hostName;
                            console.log('🏆 Game ended due to disconnect, winner:', updateData.winnerName, '(remaining player)');
                        }
                        
                        await realtimeDb.ref(`game-rooms/${currentRoom}`).update(updateData);
                    } else if (roomData.status === 'completed') {
                        // Game already completed, just clean up
                        console.log('🧹 Cleaning up completed game');
                        setTimeout(() => {
                            realtimeDb.ref(`game-rooms/${currentRoom}`).remove().catch(console.error);
                        }, 5000); // Delete after 5 seconds
                    }
                } else {
                    console.log('⚠️ Room no longer exists');
                }
            } catch (error) {
                console.error('Error leaving regular room:', error);
            }
        }

        function backToSelection() {
            console.log('🔙 Going back to game selection...');
            
            document.getElementById('game-area').classList.add('hidden');
            document.getElementById('game-selection').classList.remove('hidden');
            
            // Comprehensive cleanup to prevent memory leaks and conflicts
            cleanupAllGameResources();
            
            // Clean up find random state
            findRandomInProgress = false;
            
            // Clean up UI update functions
            window.updatePongUI = null;
            window.updateTypingUI = null;
            window.updateReactionUI = null;
            window.updateRacingUI = null;
            window.updatePongScores = null;
            window.updateTypingProgress = null;
            window.updateReactionGame = null;
            window.updateRacingScores = null;
            
            // Clean up canvas event listeners
            const pongCanvas = document.getElementById('pong-canvas');
            if (pongCanvas && pongCanvas.pongMouseHandler) {
                pongCanvas.removeEventListener('mousemove', pongCanvas.pongMouseHandler);
                pongCanvas.removeEventListener('touchmove', pongCanvas.pongTouchHandler);
                pongCanvas.pongMouseHandler = null;
                pongCanvas.pongTouchHandler = null;
            }
            
            const racingCanvas = document.getElementById('racing-canvas');
            if (racingCanvas && racingCanvas.keyHandlers) {
                document.removeEventListener('keydown', racingCanvas.keyHandlers.handleKeyDown);
                document.removeEventListener('keyup', racingCanvas.keyHandlers.handleKeyUp);
                racingCanvas.keyHandlers = null;
            }
            
            // Clean up click debouncing variables to prevent memory leaks
            if ('lastClick_p1' in window) delete window.lastClick_p1;
            if ('lastClick_p2' in window) delete window.lastClick_p2;
            
            // Reset recursion prevention flags
            if (typeof reactionUpdateInProgress !== 'undefined') {
                reactionUpdateInProgress = false;
            }
            
            // Reset winner screen state
            winnerScreenShown = false;
            
            // Force garbage collection of large objects
            if (window.gc && typeof window.gc === 'function') {
                try {
                    window.gc();
                } catch (e) {
                    // Ignore errors - gc() might not be available
                }
            }
            
            console.log('✅ Back to selection cleanup complete');
        }

        // Enhanced cleanup on page unload with improved error handling
        window.addEventListener('beforeunload', (e) => {
            if (currentRoom && currentUser) {
                try {
                    // Handle ping pong room cleanup
                    if (pongRoomRef) {
                        // Use sendBeacon for more reliable cleanup on unload
                        const cleanupData = {
                            disconnectedPlayer: currentUser.uid,
                            disconnectedAt: Date.now(),
                            status: 'completed'
                        };
                        
                        // Try multiple cleanup approaches
                        realtimeDb.ref(`pong-rooms/${currentRoom}/players/${currentUser.uid}`).remove().catch(console.error);
                        realtimeDb.ref(`pong-players/${currentRoom}/${currentUser.uid}`).remove().catch(console.error);
                        realtimeDb.ref(`pong-rooms/${currentRoom}`).update(cleanupData).catch(console.error);
                    }
                    // Handle regular room cleanup (now all use realtime database)
                    else {
                        const cleanupData = {
                            status: 'completed',
                            disconnectedPlayer: currentUser.uid,
                            disconnectedAt: Date.now(),
                            lastActivity: Date.now()
                        };
                        
                        realtimeDb.ref(`game-rooms/${currentRoom}`).update(cleanupData).catch(console.error);
                    }
                    
                    // Clean up disconnect handlers
                    cleanupDisconnectHandlers().catch(console.error);
                    
                } catch (error) {
                    console.error('Error during page unload cleanup:', error);
                }
            }
        });

                 // Handle visibility change (tab switching, mobile background)
         document.addEventListener('visibilitychange', () => {
             if (document.hidden && currentRoom && currentGameData?.status === 'playing') {
                 console.log('⚠️ Player backgrounded during game');
                 
                 // Update last activity to indicate potential disconnection
                 if (pongRoomRef) {
                     realtimeDb.ref(`pong-rooms/${currentRoom}/lastActivity`).set(Date.now()).catch(console.error);
                 } else if (currentRoom) {
                     realtimeDb.ref(`game-rooms/${currentRoom}/lastActivity`).set(Date.now()).catch(console.error);
                 }
             }
         });
        
                 // Auto-cleanup old completed games (run every 10 minutes)
         setInterval(async () => {
             if (!realtimeDb) return;
             
             try {
                 const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
                 
                 // Clean up regular game rooms
                 const gameRoomsSnapshot = await realtimeDb.ref('game-rooms')
                     .orderByChild('status')
                     .equalTo('completed')
                     .limitToFirst(20)
                     .once('value');
                 
                 if (gameRoomsSnapshot.exists()) {
                     const rooms = gameRoomsSnapshot.val();
                     let cleanedCount = 0;
                     
                     for (const [roomId, roomData] of Object.entries(rooms)) {
                         if (roomData.lastActivity && roomData.lastActivity < tenMinutesAgo) {
                             await realtimeDb.ref(`game-rooms/${roomId}`).remove();
                             cleanedCount++;
                         }
                     }
                     
                     if (cleanedCount > 0) {
                         console.log('🧹 Cleaned up', cleanedCount, 'old completed regular game rooms');
                     }
                 }
                 
                 // Clean up pong rooms
                 const pongRoomsSnapshot = await realtimeDb.ref('pong-rooms')
                     .orderByChild('status')
                     .equalTo('completed')
                     .limitToFirst(20)
                     .once('value');
                 
                 if (pongRoomsSnapshot.exists()) {
                     const rooms = pongRoomsSnapshot.val();
                     let cleanedCount = 0;
                     
                     for (const [roomId, roomData] of Object.entries(rooms)) {
                         if (roomData.lastActivity && roomData.lastActivity < tenMinutesAgo) {
                             // Clean up all pong-related data
                             await Promise.all([
                                 realtimeDb.ref(`pong-rooms/${roomId}`).remove(),
                                 realtimeDb.ref(`pong-physics/${roomId}`).remove(),
                                 realtimeDb.ref(`pong-players/${roomId}`).remove()
                             ]);
                             cleanedCount++;
                         }
                     }
                     
                     if (cleanedCount > 0) {
                         console.log('🧹 Cleaned up', cleanedCount, 'old completed pong rooms');
                     }
                 }
                 
             } catch (error) {
                 console.error('Error cleaning up old games:', error);
             }
         }, 10 * 60 * 1000); // Every 10 minutes

        // Add after setupPongRoom function

        function handlePongRoomUpdate(roomData, roomId) {
            console.log('🏓 Pong room update:', roomData.status, 'Host:', roomData.hostName, 'Guest:', roomData.guestName);
            console.log('🔍 Full room data debug:', {
                status: roomData.status,
                hostId: roomData.hostId,
                hostName: roomData.hostName,
                guestId: roomData.guestId,
                guestName: roomData.guestName,
                hasGuestName: roomData.guestName !== undefined,
                guestNameType: typeof roomData.guestName
            });
            
            // Update current game data
            currentGameData = roomData;
            
            // Handle disconnections first
            if (roomData.status === 'completed' && roomData.disconnectedPlayer) {
                const disconnectedPlayerName = roomData.disconnectedPlayerName || 
                    (roomData.disconnectedPlayer === roomData.hostId ? 
                        (roomData.hostName || 'Host') : 
                        (roomData.guestName || 'Guest'));
                
                const remainingPlayerName = roomData.winnerName || 
                    (roomData.winner === 'player1' ? roomData.hostName : roomData.guestName);
                
                if (roomData.disconnectedPlayer !== currentUser.uid) {
                    showNotification('Player Left', `${disconnectedPlayerName} left the game. ${remainingPlayerName} wins!`, 'info');
                    
                    // Show winner screen for the remaining player
                    if (!winnerScreenShown) {
                        setTimeout(() => {
                            // Create a modified room data for winner screen
                            const winnerRoomData = { ...roomData };
                            // Ensure the winner is correctly set to the remaining player
                            if (roomData.winner === 'player1' || roomData.winner === 'player2') {
                                winnerRoomData.winner = roomData.winner;
                            }
                            showWinnerScreen(winnerRoomData);
                        }, 1500);
                    }
                    
                    setTimeout(() => {
                        backToSelection();
                    }, 4000);
                    return;
                } else {
                    // Current user is the one who left - just go back
                    showNotification('Left Game', 'You have left the game', 'info');
                    setTimeout(() => {
                        backToSelection();
                    }, 1000);
                    return;
                }
            }
            
            // Handle guest joining
            if (roomData.status === 'waiting' && roomData.guestId) {
                console.log('🎯 Guest joined, updating lobby');
                
                // Fix undefined guest name by updating database if needed
                if (!roomData.guestName || roomData.guestName === 'undefined') {
                    console.log('⚠️ Guest name is undefined, fixing it...');
                    // If we're the guest and our name is missing, fix it
                    if (roomData.guestId === currentUser.uid) {
                        const fixedName = currentUser.displayName || currentUser.email || currentUser.uid || 'Player';
                        realtimeDb.ref(`pong-rooms/${roomId}`).update({
                            guestName: fixedName
                        }).then(() => {
                            console.log('✅ Fixed guest name to:', fixedName);
                        }).catch(console.error);
                        
                        // Update local data immediately for UI
                        roomData.guestName = fixedName;
                        currentGameData.guestName = fixedName;
                    }
                }
                
                updateLobbyWithGuest(roomData);
                // Note: updateLobbyWithGuest handles auto-starting the game for the host
            }
            
            // Handle game starting
            if (roomData.status === 'playing' && !document.getElementById('pong-canvas')) {
                console.log('🎮 Game status is playing, initializing UI');
                initializePongGame(roomData, roomId);
            }
            
            // Handle game completion (normal win, not disconnect)
            if (roomData.status === 'completed' && !roomData.disconnectedPlayer) {
                console.log('🏁 Game completed normally');
                if (pongInterval) {
                    clearInterval(pongInterval);
                    pongInterval = null;
                }
                if (guestPhysicsInterval) {
                    clearInterval(guestPhysicsInterval);
                    guestPhysicsInterval = null;
                }
                
                if (!winnerScreenShown) {
                    setTimeout(() => showWinnerScreen(roomData), 1000);
                }
            }
        }

        async function startPongGame(roomId) {
            try {
                console.log('🎮 Starting pong game initialization...');
                
                // Initialize game state in Realtime Database with safe values
                const gameState = {
                    ball: { 
                        x: 400, 
                        y: 200, 
                        dx: 3,  // Simple fixed values for testing
                        dy: 2 
                    },
                    player1: { y: 175, score: 0 },
                    player2: { y: 175, score: 0 },
                    gameStarted: true,
                    lastUpdate: Date.now()
                };

                console.log('🎮 Setting initial game state:', gameState);

                // Set physics state first, then update room status
                await realtimeDb.ref(`pong-physics/${roomId}`).set(gameState);
                console.log('✅ Physics state set');
                
                await realtimeDb.ref(`pong-rooms/${roomId}`).update({
                    status: 'playing',
                    startedAt: Date.now()
                });
                console.log('✅ Room status updated to playing');

                console.log('🎮 Pong game started successfully!');
            } catch (error) {
                console.error('Error starting pong game:', error);
            }
        }

        function initializePongGame(roomData, roomId) {
            console.log('🏓 Initializing pong game UI');
            
            const lobbyContent = document.getElementById('lobby-content');
            if (!lobbyContent) return;

            lobbyContent.innerHTML = `
                <div class="w-full max-w-4xl">
                    <div class="flex justify-between items-center mb-4">
                        <div class="text-text">
                            <span class="text-foam font-bold">${roomData.hostName}</span>
                            <span id="player1-score" class="text-2xl font-bold ml-2">0</span>
                        </div>
                        <div class="text-xl font-bold text-text">Ping Pong</div>
                        <div class="text-text">
                            <span id="player2-score" class="text-2xl font-bold mr-2">0</span>
                            <span class="text-iris font-bold">${roomData.guestName}</span>
                        </div>
                    </div>
                    <div class="bg-surface border border-highlight-med rounded-xl p-4">
                        <canvas id="pong-canvas" class="mx-auto border border-highlight-med rounded-lg" width="800" height="400" style="max-width: 100%; height: auto; background-color: #1f1d2e;"></canvas>
                    </div>
                    <div class="text-center mt-4 text-muted">
                        Use mouse to move your paddle • First to 5 points wins
                    </div>
                    <div class="text-center mt-2 text-xs text-muted">
                        <span id="connection-status">Connected</span> | 
                        <span id="ping-display">Realtime Database</span>
                    </div>
                </div>
            `;

            setTimeout(() => setupPongGame(roomId), 100);
        }

        function setupPongGame(roomId) {
            const canvas = document.getElementById('pong-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            
            // Listen to physics updates
            pongPhysicsRef.on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const gameState = snapshot.val();
                    
                    // Update server data for guests
                    if (!isHost && gameState.ball) {
                        currentServerBall = { ...gameState.ball };
                        currentServerGameState = { ...gameState };
                        lastServerBallUpdate = Date.now();
                        
                        // Initialize or sync guest prediction
                        if (!guestBallPrediction) {
                            console.log('🎯 Initializing guest ball prediction');
                            guestBallPrediction = { ...currentServerBall };
                        } else {
                            // Check if prediction drifted too far from server
                            const distance = Math.sqrt(
                                Math.pow(guestBallPrediction.x - currentServerBall.x, 2) + 
                                Math.pow(guestBallPrediction.y - currentServerBall.y, 2)
                            );
                            
                            // Resync if too far off (>30 pixels) or ball stopped
                            if (distance > 30 || (guestBallPrediction.dx === 0 && guestBallPrediction.dy === 0)) {
                                console.log('🔄 Resyncing guest prediction (distance:', Math.round(distance), ')');
                                guestBallPrediction = { ...currentServerBall };
                            }
                        }
                    }
                    
                    // Render with appropriate ball data
                    const renderState = { ...gameState };
                    if (!isHost && guestBallPrediction) {
                        renderState.ball = guestBallPrediction;
                    }
                    
                    renderPongGame(ctx, renderState, currentGameData);
                }
            });

            // Setup paddle control for both mouse and touch
            function updatePaddlePosition(clientY) {
                const now = Date.now();
                if (now - lastPaddleUpdate < 16) return; // 60 FPS limit
                
                const rect = canvas.getBoundingClientRect();
                const relativeY = clientY - rect.top;
                const paddleY = Math.max(0, Math.min(350, relativeY - 25));
                
                // Validate paddle position before setting
                if (isValidNumber(paddleY)) {
                    pongPlayersRef.child(`${currentUser.uid}`).set({
                        y: paddleY,
                        lastUpdate: Date.now()
                    });
                    lastPaddleUpdate = now;
                }
            }

            // Mouse controls
            canvas.addEventListener('mousemove', (e) => {
                updatePaddlePosition(e.clientY);
            });

            // Touch controls for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                if (e.touches.length > 0) {
                    updatePaddlePosition(e.touches[0].clientY);
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                if (e.touches.length > 0) {
                    updatePaddlePosition(e.touches[0].clientY);
                }
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault(); // Prevent default behavior
            });

            // Prevent context menu on long press (mobile)
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Start physics loop with a small delay to ensure everything is ready
            setTimeout(() => {
                if (isHost) {
                    console.log('🎮 Starting host physics loop at 30 FPS');
                    pongInterval = setInterval(() => {
                        updatePongPhysics(roomId);
                    }, 33); // 30 FPS
                } else {
                    console.log('🎮 Starting guest prediction physics at 60 FPS');
                    guestPhysicsInterval = setInterval(() => {
                        updateGuestBallPrediction();
                    }, 16.67); // 60 FPS for smooth guest experience
                }
            }, 500); // Wait 500ms for everything to be ready

            // Listen to player movements
            pongPlayersRef.on('value', (snapshot) => {
                if (snapshot.exists()) {
                    const players = snapshot.val();
                    updatePlayerPositions(roomId, players);
                }
            });
        }

        function updateGuestBallPrediction() {
            if (!guestBallPrediction || !currentServerBall) return;
            
            // Run local physics at 60 FPS
            guestBallPrediction.x += guestBallPrediction.dx;
            guestBallPrediction.y += guestBallPrediction.dy;
            
            // Wall bounces
            if (guestBallPrediction.y <= 8 || guestBallPrediction.y >= 392) {
                guestBallPrediction.dy = -guestBallPrediction.dy;
            }
            
            // Enhanced paddle collision prediction using server paddle data
            if (currentServerGameState && currentServerGameState.player1 && currentServerGameState.player2) {
                const player1Y = currentServerGameState.player1.y || 175;
                const player2Y = currentServerGameState.player2.y || 175;
                
                // Left paddle (host) collision
                if (guestBallPrediction.x <= 20 && guestBallPrediction.dx < 0 &&
                    guestBallPrediction.y >= player1Y && guestBallPrediction.y <= player1Y + 50) {
                    guestBallPrediction.dx = Math.abs(guestBallPrediction.dx) + 0.1;
                    guestBallPrediction.dy += (guestBallPrediction.y - (player1Y + 25)) * 0.05;
                    guestBallPrediction.x = 20;
                }
                
                // Right paddle (guest) collision  
                if (guestBallPrediction.x >= 780 && guestBallPrediction.dx > 0 &&
                    guestBallPrediction.y >= player2Y && guestBallPrediction.y <= player2Y + 50) {
                    guestBallPrediction.dx = -Math.abs(guestBallPrediction.dx) - 0.1;
                    guestBallPrediction.dy += (guestBallPrediction.y - (player2Y + 25)) * 0.05;
                    guestBallPrediction.x = 780;
                }
            } else {
                // Fallback collision detection without paddle data
                if (guestBallPrediction.x <= 10 && guestBallPrediction.dx < 0) {
                    guestBallPrediction.x = 10;
                    guestBallPrediction.dx = Math.abs(guestBallPrediction.dx);
                }
                if (guestBallPrediction.x >= 790 && guestBallPrediction.dx > 0) {
                    guestBallPrediction.x = 790;
                    guestBallPrediction.dx = -Math.abs(guestBallPrediction.dx);
                }
            }
            
            // Reset if ball goes off screen (let server handle scoring)
            if (guestBallPrediction.x < -50 || guestBallPrediction.x > 850) {
                if (currentServerBall) {
                    guestBallPrediction = { ...currentServerBall };
                }
            }
            
            // Periodic sync with server (every 100ms)
            const now = Date.now();
            if (currentServerBall && now - lastServerBallUpdate < 100) {
                // Gently pull prediction towards server position to prevent drift
                const pullStrength = 0.1;
                guestBallPrediction.x += (currentServerBall.x - guestBallPrediction.x) * pullStrength;
                guestBallPrediction.y += (currentServerBall.y - guestBallPrediction.y) * pullStrength;
            }
        }

        async function updatePlayerPositions(roomId, players) {
            try {
                if (!players || !currentGameData) return;
                
                const updates = {};
                
                Object.keys(players).forEach(playerId => {
                    const player = players[playerId];
                    if (!player || typeof player.y !== 'number') return;
                    
                    // Validate y position is within bounds
                    const validY = Math.max(0, Math.min(350, player.y));
                    
                    if (playerId === currentGameData.hostId) {
                        updates['player1/y'] = validY;
                    } else if (playerId === currentGameData.guestId) {
                        updates['player2/y'] = validY;
                    }
                });

                if (Object.keys(updates).length > 0) {
                    await pongPhysicsRef.update(updates);
                }
            } catch (error) {
                console.error('Error updating player positions:', error);
            }
        }

        async function updatePongPhysics(roomId) {
            try {
                const snapshot = await pongPhysicsRef.once('value');
                if (!snapshot.exists()) {
                    console.log('No physics data yet, skipping update');
                    return;
                }

                const gameState = snapshot.val();
                console.log('Physics update - raw gameState:', gameState);

                // Create safe defaults if data is missing
                const ball = gameState.ball || { x: 400, y: 200, dx: 3, dy: 2 };
                const player1 = gameState.player1 || { y: 175, score: 0 };
                const player2 = gameState.player2 || { y: 175, score: 0 };

                // Ensure all values are numbers
                ball.x = isValidNumber(ball.x) ? ball.x : 400;
                ball.y = isValidNumber(ball.y) ? ball.y : 200;
                ball.dx = isValidNumber(ball.dx) ? ball.dx : 3;
                ball.dy = isValidNumber(ball.dy) ? ball.dy : 2;

                player1.y = isValidNumber(player1.y) ? player1.y : 175;
                player1.score = isValidNumber(player1.score) ? player1.score : 0;
                player2.y = isValidNumber(player2.y) ? player2.y : 175;
                player2.score = isValidNumber(player2.score) ? player2.score : 0;

                console.log('Physics update - after validation:', { ball, player1, player2 });

                // Update ball position
                const oldBallX = ball.x;
                const oldBallY = ball.y;
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                console.log(`Ball moved from (${oldBallX}, ${oldBallY}) to (${ball.x}, ${ball.y}) with velocity (${ball.dx}, ${ball.dy})`);

                // Wall collisions
                if (ball.y <= 8 || ball.y >= 392) {
                    ball.dy = -ball.dy;
                    ball.y = Math.max(8, Math.min(392, ball.y));
                }

                // Paddle collisions
                if (ball.x <= 20 && ball.dx < 0 && 
                    ball.y >= player1.y && ball.y <= player1.y + 50) {
                    ball.dx = Math.abs(ball.dx) + 0.1;
                    ball.dy += (ball.y - (player1.y + 25)) * 0.05;
                    ball.x = 20;
                }

                if (ball.x >= 780 && ball.dx > 0 && 
                    ball.y >= player2.y && ball.y <= player2.y + 50) {
                    ball.dx = -Math.abs(ball.dx) - 0.1;
                    ball.dy += (ball.y - (player2.y + 25)) * 0.05;
                    ball.x = 780;
                }

                // Limit ball speed
                const maxSpeed = 10;
                ball.dx = Math.max(-maxSpeed, Math.min(maxSpeed, ball.dx));
                ball.dy = Math.max(-maxSpeed, Math.min(maxSpeed, ball.dy));

                // Scoring
                if (ball.x < 0) {
                    player2.score++;
                    resetBall(ball);
                }
                if (ball.x > 800) {
                    player1.score++;
                    resetBall(ball);
                }

                // Check win condition
                if (player1.score >= 5 || player2.score >= 5) {
                    clearInterval(pongInterval);
                    pongInterval = null;

                    await realtimeDb.ref(`pong-rooms/${roomId}`).update({
                        status: 'completed',
                        winner: player1.score >= 5 ? 'player1' : 'player2',
                        completedAt: Date.now()
                    });
                }

                // Update physics state
                const updateData = {
                    ball: ball,
                    player1: player1,
                    player2: player2,
                    gameStarted: true,
                    lastUpdate: Date.now()
                };

                console.log('Updating physics with:', updateData);
                await pongPhysicsRef.update(updateData);

            } catch (error) {
                console.error('Error updating physics:', error);
            }
        }

        function isValidNumber(value) {
            return typeof value === 'number' && !isNaN(value) && isFinite(value);
        }

        function resetBall(ball) {
            ball.x = 400;
            ball.y = 200;
            ball.dx = (Math.random() > 0.5 ? 3 : -3);
            ball.dy = (Math.random() - 0.5) * 4;
            
            // Ensure ball speed is valid
            if (!isValidNumber(ball.dx)) ball.dx = 3;
            if (!isValidNumber(ball.dy)) ball.dy = 2;
            
            console.log('🏐 Ball reset to:', ball);
        }

        function renderPongGame(ctx, gameState, roomData) {
            // Validate input
            if (!ctx || !gameState) return;
            
            // Set defaults for missing game state
            const defaultGameState = {
                ball: { x: 400, y: 200, dx: 0, dy: 0 },
                player1: { y: 175, score: 0 },
                player2: { y: 175, score: 0 }
            };
            
            const safeGameState = {
                ball: { ...defaultGameState.ball, ...gameState.ball },
                player1: { ...defaultGameState.player1, ...gameState.player1 },
                player2: { ...defaultGameState.player2, ...gameState.player2 }
            };
            
            // Clear canvas
            ctx.fillStyle = '#1f1d2e';
            ctx.fillRect(0, 0, 800, 400);

            // Draw center line
            ctx.strokeStyle = '#403d52';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(400, 0);
            ctx.lineTo(400, 400);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw paddles with safe values
            ctx.fillStyle = '#9ccfd8';
            const p1Y = isValidNumber(safeGameState.player1.y) ? safeGameState.player1.y : 175;
            const p2Y = isValidNumber(safeGameState.player2.y) ? safeGameState.player2.y : 175;
            ctx.fillRect(10, p1Y, 10, 50);
            ctx.fillRect(780, p2Y, 10, 50);

            // Draw ball with safe values
            ctx.fillStyle = '#eb6f92';
            ctx.beginPath();
            const ballX = isValidNumber(safeGameState.ball.x) ? safeGameState.ball.x : 400;
            const ballY = isValidNumber(safeGameState.ball.y) ? safeGameState.ball.y : 200;
            ctx.arc(ballX, ballY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw scores with safe values
            ctx.fillStyle = '#e0def4';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            const player1Score = isValidNumber(safeGameState.player1.score) ? safeGameState.player1.score : 0;
            const player2Score = isValidNumber(safeGameState.player2.score) ? safeGameState.player2.score : 0;
            ctx.fillText(`${player1Score}`, 200, 40);
            ctx.fillText(`${player2Score}`, 600, 40);

            // Draw debug info for guests
            if (!isHost) {
                ctx.fillStyle = '#6e6a86';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                
                const syncAge = currentServerBall ? Date.now() - lastServerBallUpdate : 0;
                const usingPrediction = guestBallPrediction ? 'Local 60FPS' : 'Server';
                
                ctx.fillText(`Ball: ${usingPrediction}`, 10, 380);
                ctx.fillText(`Sync: ${syncAge}ms ago`, 10, 392);
                
                if (guestBallPrediction && currentServerBall) {
                    const distance = Math.sqrt(
                        Math.pow(guestBallPrediction.x - currentServerBall.x, 2) + 
                        Math.pow(guestBallPrediction.y - currentServerBall.y, 2)
                    );
                    ctx.fillText(`Drift: ${Math.round(distance)}px`, 150, 380);
                    ctx.fillText(`Speed: ${guestBallPrediction.dx.toFixed(1)}, ${guestBallPrediction.dy.toFixed(1)}`, 150, 392);
                }
            }

            // Update score display
            const p1ScoreElement = document.getElementById('player1-score');
            const p2ScoreElement = document.getElementById('player2-score');
            if (p1ScoreElement) p1ScoreElement.textContent = (safeGameState.player1 && safeGameState.player1.score) || 0;
            if (p2ScoreElement) p2ScoreElement.textContent = (safeGameState.player2 && safeGameState.player2.score) || 0;

            // Update connection status
            const connectionStatus = document.getElementById('connection-status');
            if (connectionStatus) {
                if (isHost) {
                    connectionStatus.textContent = 'Host (Authoritative)';
                } else {
                    const status = guestBallPrediction ? 'Smooth (60 FPS)' : 'Syncing...';
                    connectionStatus.textContent = status;
                }
            }

            // Show winner overlay
            if (roomData && roomData.status === 'completed') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 800, 400);
                ctx.fillStyle = '#e0def4';
                ctx.font = '48px Arial';
                const p1Score = (safeGameState.player1 && safeGameState.player1.score) || 0;
                const winner = p1Score >= 5 ? (roomData.hostName || 'Host') : (roomData.guestName || 'Guest');
                ctx.fillText(`${winner} Wins!`, 400, 200);
            }
        }

        function cleanupPongRoom() {
            console.log('🧹 Cleaning up pong room resources...');
            
            // Clean up disconnect handlers for pong
            cleanupDisconnectHandlers().catch(console.error);
            
            // Clear intervals
            if (pongInterval) {
                clearInterval(pongInterval);
                pongInterval = null;
            }
            if (guestPhysicsInterval) {
                clearInterval(guestPhysicsInterval);
                guestPhysicsInterval = null;
            }

            // Remove listeners with error handling
            try {
                if (pongRoomRef) {
                    pongRoomRef.off();
                    pongRoomRef = null;
                }
                if (pongPhysicsRef) {
                    pongPhysicsRef.off();
                    pongPhysicsRef = null;
                }
                if (pongPlayersRef) {
                    pongPlayersRef.off();
                    pongPlayersRef = null;
                }
                if (connectionRef) {
                    connectionRef.off();
                    connectionRef = null;
                }
            } catch (error) {
                console.warn('Error cleaning up pong listeners:', error);
            }

            // Remove canvas event listeners
            const pongCanvas = document.getElementById('pong-canvas');
            if (pongCanvas && pongCanvas.pongMouseHandler) {
                pongCanvas.removeEventListener('mousemove', pongCanvas.pongMouseHandler);
                pongCanvas.removeEventListener('touchmove', pongCanvas.pongTouchHandler);
                pongCanvas.pongMouseHandler = null;
                pongCanvas.pongTouchHandler = null;
            }

            // Reset all variables comprehensively
            isHost = false;
            currentRoom = null;
            currentGameData = null;
            guestBallPrediction = null;
            lastServerBallUpdate = 0;
            currentServerBall = null;
            currentServerGameState = null;
            lastPaddleUpdate = 0;
            guestPredictedBall = null;
            lastServerSync = 0;
            
            console.log('✅ Pong room cleanup complete');
        }

        // Session cleanup
        async function cleanupExpiredPongRooms() {
            try {
                const snapshot = await realtimeDb.ref('pong-rooms').once('value');
                if (!snapshot.exists()) return;

                const rooms = snapshot.val();
                const now = Date.now();
                const fiveMinutesAgo = now - (5 * 60 * 1000);

                Object.keys(rooms).forEach(async (roomId) => {
                    const room = rooms[roomId];
                    if (room.lastActivity && room.lastActivity < fiveMinutesAgo) {
                        console.log('🧹 Cleaning up expired pong room:', roomId);
                        await Promise.all([
                            realtimeDb.ref(`pong-rooms/${roomId}`).remove(),
                            realtimeDb.ref(`pong-physics/${roomId}`).remove(),
                            realtimeDb.ref(`pong-players/${roomId}`).remove()
                        ]);
                    }
                });
            } catch (error) {
                console.error('Error cleaning up pong rooms:', error);
            }
        }

        // Auto-cleanup disabled to avoid permission issues
        // Rooms will be cleaned up when players leave or disconnect
        // setInterval(cleanupExpiredPongRooms, 2 * 60 * 1000);

        // Enhanced error monitoring and recovery
        let gameErrorCount = 0;
        let lastGameError = 0;
        
        function recordGameError(error, context) {
            gameErrorCount++;
            lastGameError = Date.now();
            
            console.error(`Game Error #${gameErrorCount} in ${context}:`, error);
            
            // Show user-friendly notification based on error type
            if (error.code === 'permission-denied') {
                showNotification('Permission Error', 'Game access denied. Please refresh and try again.', 'error');
            } else if (error.code === 'unavailable') {
                showNotification('Connection Error', 'Game server temporarily unavailable.', 'error');
            } else if (error.code === 'resource-exhausted') {
                showNotification('Server Overloaded', 'Too many players online. Please try again later.', 'error');
            } else {
                showNotification('Game Error', 'An error occurred. The game will attempt to recover.', 'warning');
            }
            
            // Auto-recovery for certain error types
            if (gameErrorCount >= 3 && Date.now() - lastGameError < 10000) {
                console.log('Too many game errors, initiating auto-recovery...');
                autoRecoverGame();
            }
        }
        
        function autoRecoverGame() {
            try {
                // Clean up current game state
                if (currentRoom) {
                    leaveRoom();
                }
                
                // Reset error counter after recovery
                setTimeout(() => {
                    gameErrorCount = 0;
                    showNotification('Recovery Complete', 'Game system has been reset.', 'success');
                }, 2000);
                
            } catch (error) {
                console.error('Auto-recovery failed:', error);
                showNotification('Recovery Failed', 'Please refresh the page to continue.', 'error');
            }
        }
        
        // Enhanced touch controls for mobile reaction game
        function setupMobileOptimizations() {
            // Prevent zooming on touch games
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent context menu on long press for game elements
            document.addEventListener('contextmenu', (e) => {
                if (e.target.closest('#reaction-zone') || 
                    e.target.closest('#pong-canvas') || 
                    e.target.closest('#racing-canvas')) {
                    e.preventDefault();
                }
            });
            
            // Add visual feedback for touch devices
            if ('ontouchstart' in window) {
                document.body.classList.add('touch-device');
                
                // Add CSS for touch feedback
                const style = document.createElement('style');
                style.textContent = `
                    .touch-device button:active,
                    .touch-device .cursor-pointer:active {
                        transform: scale(0.95);
                        transition: transform 0.1s ease;
                    }
                    
                    .touch-device #reaction-zone:active {
                        transform: scale(0.98);
                        transition: transform 0.1s ease;
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Initialize mobile optimizations
        setupMobileOptimizations();
        
        // Performance monitoring
        let performanceMetrics = {
            gameStartTime: null,
            frameDrops: 0,
            lastFrameTime: 0,
            avgFrameTime: 0,
            frameCount: 0
        };
        
        function monitorPerformance() {
            const now = performance.now();
            if (performanceMetrics.lastFrameTime > 0) {
                const frameTime = now - performanceMetrics.lastFrameTime;
                performanceMetrics.avgFrameTime = (performanceMetrics.avgFrameTime * performanceMetrics.frameCount + frameTime) / (performanceMetrics.frameCount + 1);
                performanceMetrics.frameCount++;
                
                // Detect frame drops (>33ms = below 30 FPS)
                if (frameTime > 33) {
                    performanceMetrics.frameDrops++;
                }
                
                // Warn if performance is poor
                if (performanceMetrics.frameCount > 100 && performanceMetrics.avgFrameTime > 25) {
                    console.warn('Poor game performance detected. Average frame time:', performanceMetrics.avgFrameTime.toFixed(2) + 'ms');
                }
            }
            performanceMetrics.lastFrameTime = now;
        }
        
        // Global error handler for uncaught errors in games
        window.addEventListener('error', (e) => {
            if (currentRoom && currentGameData) {
                recordGameError(e.error || e, 'Uncaught Error');
            }
        });
        
        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (e) => {
            if (currentRoom && currentGameData) {
                recordGameError(e.reason, 'Unhandled Promise Rejection');
            }
        });
        
        // Debug functions for testing (only in development)
        if (window.location.hostname === 'localhost' || window.location.hostname.includes('127.0.0.1')) {
            window.debugMultiGame = {
                getCurrentGameData: () => currentGameData,
                getCurrentRoom: () => currentRoom,
                getPerformanceMetrics: () => performanceMetrics,
                getErrorCount: () => gameErrorCount,
                forceLeaveRoom: () => leaveRoom(),
                simulateError: (errorType) => recordGameError(new Error('Simulated ' + errorType), 'Debug'),
                resetErrorCount: () => { gameErrorCount = 0; lastGameError = 0; }
            };
            console.log('Debug functions available at window.debugMultiGame');
        }
        
        console.log('🎮 Carbon Multi - All systems initialized successfully!');
    </script>
</body>
</html>